{
  "id": "http://arxiv.org/abs/cs/0106016v1",
  "title": "File mapping Rule-based DBMS and Natural Language Processing",
  "authors": [
    "Vjacheslav M. Novikov"
  ],
  "abstract": "This paper describes the system of storage, extract and processing of\ninformation structured similarly to the natural language. For recursive\ninference the system uses the rules having the same representation, as the\ndata. The environment of storage of information is provided with the File\nMapping (SHM) mechanism of operating system. In the paper the main principles\nof construction of dynamic data structure and language for record of the\ninference rules are stated; the features of available implementation are\nconsidered and the description of the application realizing semantic\ninformation retrieval on the natural language is given.",
  "text": "1\nFile mapping Rule-based DBMS and Natural Language\nProcessing\nVjacheslav M. Novikov\nhbm@mail.radiant.ru\nVDO RSC Energia, Samara, Russian\nAbstract\nThis paper describes the system of storage, extract and processing of information structured\nsimilarly to the natural language. For recursive inference the system uses the rules having the\nsame representation, as the data. The environment of storage of information is provided with\nthe File Mapping (SHM) mechanism of operating system. In the paper the main principles of\nconstruction of dynamic data structure and language for record of the inference rules are\nstated; the features of available implementation are considered and the description of the\napplication realizing semantic information retrieval on the natural language is given.\n1. Introduction\nThe algorithms of information extract and its processing directly depend on structure, in\nwhich the information is represented. And the structural solutions can considerably simplify\nthe algorithmic ones, enabling to look at the problem from another point of view.\n    The modern systems of natural language processing are created, as a rule, on the basis of\ntext data, represented as records of relational databases. The algorithms of processing are\nrealized frequently by Prolog-similar means. Complexities of interaction of the programming\nlanguages, based on recursive inference of rules, and relational databases were earlier\nconsidered despite of external analogy of logical interpretation (in more detail in section 3).\nBesides the tabular form of representation is not always adequate to internal structure of the\ninformation processed. The last statement is correct in particular in relation to the traditional\nand most popular way of storage of the information, in the form of the natural language texts.\n    In this paper the concept of storage, extract and processing of information structured\nsimilarly to constructions of the natural language, with usage of the mechanism of shared\nsegments of memory (SHM) for operating system Unix or the File Mapping mechanism for\noperating system Windows is stated. The concept is realized in SHM_db DBMS. Further the\ndescription of the language used for record of inference rules is given and the way of\nautomatic generation of rules in learning process is considered.\n2. Structure and rules of the natural language\nLet's look at the problem of structuring of the textual information from the point of view of\ntraining and, as Turing offered [9], training the child, initially having no preliminary\ninformation on structure, constructions and rules of the natural language. Let's accept also,\nthat the training starts with the written language, first excepting the colloquial one.\n    The selection of characters, words and sentences in the text information does not raise\ndoubt. The obtaining of skills of their differentiation remains behind the frames of the given\n2\nresearch. If to consider words and sentences as structural units of more high levels in\ncomparison with characters, each of structural units on its level can participate in derivation\nof the definite sequences: combination of characters, combination of words etc. The unit of\nmore high level is concerned with some sequence of structural units of the corresponding\nlower level.\n    Besides, in the natural language structure it is possible to distinguish other constructions as\nwell. For example, let's represent sentence - question - answer\nTom played fair. Did Tom play fair ? Tom played fair.\nas\n((Tom played fair .)( Did Tom play fair ?))->( Tom played fair .);\nIn parentheses we shall designate the selected sequences of some structural units. (All entered\nhereinafter denotations are determined by the described below language of record of the\ninference rules or, to be more exact, by the features of its realization, and it is possible for\nthem not to coincide with the denotations accepted in logic programming or formal Backus-\nNaur form.) Let's suppose, that the construction containing the sign ->, defines a rule or\ninference rule. The inference rules will form a new higher structural level in relation to the\nsentences.\n    Now we shall assume, that in learning process, which purpose is the semantic structuring\nof the source texts, two rules are showed as samples:\n((Tom played fair .)( Did Tom play fair ?))->( Tom played fair .);\n((Bill played fair .)( Did Bill play fair ?))->( Bill played fair .);\nLet's compare appropriate sentences of rules. In case the rules differ only by the sentences\ncontaining an identical amount of terms and the differences concern only one of these terms,\nin this and only this case these rules can be replaced by one, composed from the schemes of\nthe sentences. It can look as\n             ((                 played fair .) (Did Tom play fair ?)) -> (              played fair .);            (1)\nHere the expression in square brackets                     plays a role of the disjunction.\n    Let's consider a more complex case. We assume that the rule (1) already exists and in\nlearning process the next rule is also showed\n                       ((Tom spoke fair .)( Did Tom speak fair ?))->( Tom spoke fair .);                  (2)\nFor generalization (1) and (2) there can be a construction\n   ((                                fair .) (Did                             fair ?)) -> (                               fair .)  (3)\n                                     |<(                                     )                                     >;\nTom\nBill\nTom\nBill\nTom\nBill\nTom\nBill\n played\n spoke\nTom\nBill\n play\nspeak\n play\n speak\n played\nspoke\n( play  played)\n( speak spoke)\nTom\nBill\n played\n spoke\n3\nThe sign  |  is followed by the logical expression specifying conditions, and the expression in\nangular brackets < > plays the role of conjunction.\n   The rule (3) includes not only three initial constructions presented in the course of training,\nbut also such as\n((Bill spoke fair .)( Did Bill speak fair ?))->( Bill spoke fair .);\nGenerally speaking, some of the constructions represented by the rule can be absent in the\nnatural language, despite of syntactical regularity.\n    The analysis mentioned above does not claim the linguistic entirety; it only characterizes\nthe initial premise of a structural data representation of the system described.\n3. To the history of the question\nA survey paper by Lashmanov A.V. \"Deductive databases: language aspect\", published in\njournal Databases and hypertext systems number 9â€˜91 [5] can be considered as the starting\npoint of the research described. The paper was written on the basis of the publications in such\nissues as Lecture Notes in Computer Science, Journal of Logic Programming, The Computer\nJournal, SIGMOD Record, Technology and Science of Informatics, Information Systems,\nData and Knowledge Engineering, Knowledge Bases Systems and others. The analysis of\nstate and perspectives of the logical programming languages development in relation to\ndatabase management systems was given in this paper.\n    It was marked that the development of logical (deductive) languages of databases goes in\ntwo directions. First - in the direction of modification and/or creation of Prolog-similar\nlanguages (on the basis of Horn formulas), including the mechanism of inquiries to the\ndatabase. Second - in the direction from relational languages to deductive databases by\ncreation of the specialized logical programming languages, which can be described as the\nSQL extension. It was emphasized that despite of rather long history of development,\naccompanied by high research activity, only some of them succeeded in commercial\nimplementation based in general on Prolog modifications. The tendency marked is likely to\nbe saved until now. Despite of logical relationship of the deductive programming languages\nand relational databases [6], the interfaces of access to relational bases from the languages of\nlogic programming are not applied widely now as well.\n    Speaking about natural language processing (NLP), it is necessary to remark that certain\ninternal generality of problems in implementation of NLP-systems with the problems of\ninteraction between the logical programming languages and DBMS is observed. The analysis\nof publications, accessible from the Internet at least, shows that though there is a definite\nsuccess of the information extract systems on inquiries in the natural language, the solution,\nequally suitable for the different natural languages, is not available till now. The scheme of\nsuch systems functioning remains, as a rule, the same that is, the inquiry on the natural\nlanguage - parser - translation in SQL - analysis of the extracted information. Quite often\nparser is being built on the basis of Prolog-similar resources. (See, for example, [1,3,8,10].) In\nthis scheme the parser and fulfillment of inquiries to the database are logically and\nstructurally divided. At the same time the attempts of implementation with usage of relational\nor Adabas-similar DBMS of the data constructions, described in the previous section, in the\ncombination with effective extraction of information and recursive disclosure of rules have\nnot reached any success.\n4\n4. File Mapping mechanism\nAs compared to the approaches described in A.V. Lashmanov's paper, the offered DBMS is\nfounded on data model essentially differed from the traditional one. One of the principal\ncomponents which permitted to realize the main ideas of the model and gave the first\nconditional title of DBMS - SHM_db, was the mechanism of shared segments of memory\n(SHM-segments) of operating system Unix.\n    The shared segments, having appeared in operating system Unix as a tool of inter-\nprocessing connection, were supplemented later by the mechanism of their saving. In\nWindows NT, Windows 95 the similar operation is fulfilled by API's File Mapping functions.\n    The mechanism described realizes the idea of non-volatile virtual storage with the\ncharacteristics of access, being the best, as a rule, in comparison with access to the file\nsystem, that allows to refuse completely from the input-output system calls at programming\nof DBMS kernel functions. Besides, the process connecting a shared segment, allocates it in\nthe limits of 4 Gb range of addresses for Unix or 2 Gb range for Windows NT. When\nprogramming on C the addresses can be stipulated and fixed beforehand. In SHM_db the\nmemory address simultaneously fulfills the function of the relation code or the type of the\narray. So, for example, in implementation for Unix the relations of the database are allocated\nalways on the negative semiaxis of addresses and the references to the positive one, herewith\nthe relations of more high levels having smaller addresses.\n    The similar system solutions have allowed:\n- \nfirstly, to obtain more high-speed load modules realizing basic functions, at the expense\nof primary usage of the computer instructions with direct addressing instead of indirect;\n- \nsecondly, to use data model, which seem prodigal from the point of view of size, that is,\nfor example, a non-byte representation of characters as relations of 0-th level of the\ndatabase.\n5. Some main concepts and definitions\nIn spite of the fact that at the description of algorithms of DBMS operations, such concepts as\n\"relation\", \"the scheme of storage of the relation\" etc. are widely used, they essentially differ\nfrom the concepts of the generally accepted relational data model.\nRelation is any aggregate of the relations or elementary relation of the same level. Each\nrelation has the pointer on the sequence (which can be empty) of direct references. Each non-\nelementary relation is being characterized by the inverse references and code. The relations,\ndepending on the level, are distinguished according to the type.\nLevel of the relation. Four levels of relations are identified.\n    0-th level - characters, elementary numbers, combinations of characters and their relations,\ncombinations of elementary numbers. The elementary relation of 0-th level defines the\ncharacter code or elementary number. Elementary numbers are hexadecimal numbers from\n0x00 up to 0xFF. In the database the numbers described on C as short, integer, float and\ndouble can be used. All numbers, except for elementary, are represented by sequences of\nelementary numbers. The order of creation of number sequences is reverse - at first rightmost\ndigits, then left. The non-significant zero in the sequences of elementary numbers and trailing\nblanks in the sequences of characters, as a rule, are not mapped in the database.\n5\n    1-st level is words, elementary relations of the 1-st level, combinations of words,\nelementary relations of the 1-st level and their relations. The word is a relation having the\ninverse reference to the relation of the 0-th level. The elementary relation of the 1-st level is a\nrelation defining an arbitrary sequence of characters (for non-descriptors or arbitrary bit\nmaps), or relation defining the address of the subroutine/function, or empty relation of the 1-\nst level.\n    2-nd level is sentences, aggregates of sentences. The sentence is a relation having the\ninverse reference to the relation of the1-st level.\n    3-rd level is rules, sequences (or files) of rules. The rule is a relation having the inverse\nreference to the relation of the 2-nd level.\nReferences. The direct and inverse references are distinguished. The direct references define a\nset of relations, the given relation being as the constituent. The inverse references define a set\nof relations, of which the given relation consists.\nCode of the relation. Except for the elementary relations the codes can be the following ones:\n0 - conjunction, in which the order of the relations is important (the term \"sequence\" is also\napplied);\n1 - the conjunction, in which the order of the relations is indifferent;\n2 - the disjunction, in which the order of the relations is indifferent;\n3 - the disjunction of sequences of the relations (the term \"list\" is also applied).\n    When recording the language sentences the relations with the code 0 are taken in\nparentheses ( ),  the relations with the code 1 - in angular brackets < >,  the relations with the\ncode 2 - in square brackets [ ] and the relations with the code 3 - in braces { } respectively.\nParadigm is the relation with code 2, containing the special relation unambiguously defining\nparadigm (for the 1-st level a role of special relations is played by variables, for the 2-nd\nlevel - by schemes), and the set of relations representing the saved data (the last can be\nabsent). In spite of the fact that a paradigm from the point of view of the search operations\nlogic is perceived as the disjunction, the order of creation of the inverse references can differ\nfrom the usual (for the relations with code 2) chronological order on the increase of\naddresses. If the word defining the paradigm is ended with sign +, the inverse references are\ncreated in ascending order of paradigm values, if it is ended with sign -, the references are\ncreated in decreasing order. The sign ` defines the inverse chronological sorting. In other\ncases the components of the paradigm are written in direct chronological sequence.\nType of the relation.\n    On the 0-th level all relations except for the names of variables have the type 0. A special\nelementary relation defining the combination of characters as the name of a variable has type\n1, and the combination of characters, including this special relation, has type 3.\n    On the1-st level variables, global variables and constants are distinguished. The variable\n(or the current variable) is a paradigm, containing a word with type 3, starting with a small\ncharacter; it is represented by the relation with type 1. The global variable is a paradigm,\ncontaining a word with type 3, starting with a large character, and is represented by the\nrelation with type 2. The constants and constant expressions are referred to type 0. And the\nrelations including variables have type 3.\n6\n    The sentences on the 2-nd level can be executable (code 2), i.e., calling the control transfer\nto some subroutine/function, or non-executable (code 1).\n    On the 3-rd level direct and inverse rules are distinguished. The inverse rules are referred\nto type 1, the direct rules - to type 2. The rules in which the right part is absent are used for\nthe definition of input data. Such rules are referred to type 1. The rules, in which there is no\nleft part, are intended for control transfer immediately from the main program and are\nreferred to type 2.\n    The types of the relations are stated by the system and are not analyzed by the programmer\ndirectly.\nScheme (scheme of storage). This concept, applicable only to the relations of the 2-nd level,\nmeans a sentence containing variables (both current, and global).\nFile. With reference to SHM_db this is the relation of the 2-nd level containing both the\nscheme and its corresponding saved data. In other words, it is possible to say that the file is a\nnon-executable paradigm of the 2-nd level.\nFile of rules is the relation of the 3-rd level, containing a set of rules mapping input data of\nthe rules representation program and a special relation defining the time of the last\nmodification of these data and their location.\n6. The language for record of inference rules\nIn spite of the fact that the work was primary aimed at programming on C language, the\nlanguage for the record of inference rules is not the extension C or C++ (as, for example,\nR++ of AT&T Bell Laboratories [7]). The language has arisen as a means of compact\nrepresentation of the relations of 4-level dynamic structure, its syntax being non-separable\nfrom the main SHM_db concepts and in many respects is defined by them.\n    The following agreements are accepted for the record of rules.\n    Here the word is a sequence of characters, digits and characters limited by separators. As\nseparators, the codes of the beginning and extremity of a line, blanks, single characters\n!\"(),/:;=<>?\\[]|{} are used (point and sign _ are not separators). The sequences of characters\ntaken in unary quotes ' ' are also considered as words. In double quotes the sequences of\nwords are specified taking into account the separators. All words enclosed in quotes are\nconsidered as constants.\n    The sign # has a special assignment. This sign always precedes the names of subroutines/\nfunctions. The translator of rules in the relation defining the subroutine/function allocates the\nplace for the linkage address. If the first character of the name is large - subroutine/ function\nis considered as a standard one.\n    The sign $ in the first position defines the name of the non-executable relation.\n    Any word not enclosed in quotes or which is not special, is interpreted by translator of\nrules as the name of a variable, being global if the word starts with a large character,\notherwise current.\n    Special sequences /* */ identify the comments, and  == != := += -= >= <= set the relations\ncausing calls to standard subroutines/functions.\n7\n    For any word in quotes, double or unary, the attempt is made to present it as a number\n(format is defined by external representation by rules accepted in C), at failure the word is\nconsidered a character one.\n    The separators, as well as relations, are grouped as follows:\n;  is a separator of the 3-rd level, i.e. any rule should be terminated in a semicolon.\n->, |  are the separators of the 2-nd level, they select sentences and groups of sentences,\nbesides -> separates the left part of the rule from the right, and the sign | separates the\nconditions.\nThe level of the relations selected with brackets ( ) < > [ ] { }, depends on the context. The\nremaining separators are considered as separators of the 1-st level.\n    The brackets always should be paired. The parentheses ( ) define the relations having the\ncode 0, the angular brackets < > - code 1, the square brackets [ ] - code 2 and the braces { } -\ncode 3 respectively.\n    The executable relations of level 2 always look like:\n#xxx (z1 z2 ... zN),\nwhere xxx is the name of the subroutine/function, and (z1 z2 ... zN) is the relation with code\n0 of the arbitrary number of the 1-st level relations (parameters of the subroutine/ function).\n    The non-executable relations of the 2-nd level look like:\n$xxx (z1 z2 ... zN).\nAs compared to the executable relations, they do not call control transfer to any subroutine/\nfunction, but initiate recursive search of derivative rules as the executable relations do. (In the\nmode of processing of semantic rules the role of non-executable relations is played by\nsentences and schemes of natural language sentences, but in the language of record of the\ninference rules the similar constructions have no reflection.)\n    The rule in a general view is written as:\nA ->  B | C;\nHere A is the left part of the rule, B is the right part, C is the conditions of transition from A\nto B. Sometimes some parts can be absent. The expression:\nA ->;\nsets the data defined immediately in the file of rules. And the expression:\n-> B | C;\nmeans the transition to B at execution of conditions C immediately from the main program.\nThe unconditional transition from A to B and unconditional control transfer from the main\nprogram respectively is possible also:\nA -> B;\n-> B;\n8\nA in a general view can be represented as the sequence\nA1, A2, A3,\nwhere  A1 is the initial sentence, the scheme of sentence A1 or list {A1};\n           A2 is scheme A2, defining some file, or list {A2};\n           A3 is a logical function defining the conditions of transition.\nThe relation A1, A2, A3 represents an inverse rule. If A has more than one term, the\nexpression is being treated as the check on existence (or search) of data of file A2, which\nvariables accept values corresponding to the relation A1. The search can be completed\nimmediately after finding the first variant, satisfying the criteria of the data search, or be\nfulfilled cyclically for all possible values. In the latter case A2 is enclosed in curly brackets.\nAt transition without check on existence A2 and A3 are absent.\n    B in a general view can be represented as a sequence\nB1, B2, ..., Bn.\nHere each of the constituent relations of level 2 is a sentence, either scheme, or list containing\nthe unique scheme. The list {Bi} in this case is an outcome of exhaustive search of all\npossible values of uncertain variables or their combinations for the non-executable relations;\nfor the executable relations it means the recurrence of operation.\n    As a result of executable relation the control is being transmitted sequentially to\nexpressions B1, B2, etc. Normal return code is code 1. The execution of the sequence can be\nstopped, if one of Bi is ended with a return code 0 or -1. -1 is treated as interruption. For the\nexecutable relations the interruptions of the derivative relations are analyses by the executed\nunit itself.  For non-executable lists {Bi} the completion of one of the components with code\n-1 results in leaving the list with the same return code.\n    Each of Bi relations can initiate the process of search of rules, in which A1 is the\nequivalent to Bi. And, for cutting the review of possible variants of prolongation, the search\nis started only in the case if Bi defines the non-executable relation or accesses to the\nsubroutine/function completing by the code >= 0410 (initially 0411-0427 were treated as\nfunction keys codes of the Unix-terminal).\n    C represents the logical expression\nL (C1,C2,...,Cn),\nin which Ci is a sentence or a scheme, and the logic operations AND, OR are set by brackets:\n    AND - ( ) or < >,\n    OR - [ ] or { },\nand in the case of usage of brackets ( ) or { } the procedure for conditions testing is being\ndetermined by the order of record of sentences. The negation NOT is being set by the\nfunction of the 2-nd level  !  or  #Not.\n9\n7. Transmission of values of variables\nAt the relations execution the transmission of values of variables to the following relation is\none of the key moments defining the form of algorithm record with the help of the language\ndescribed. From one relation to another the values of variables are being transmitted as tables\nof variables. The programs of the DBMS kernel for each of the processes generate tables of\ntwo types: the table of global variables TBLVAR and the tables of current variables TBLVar.\nTBLVAR is always unique - it allows transmitting values of variables from relation to\nrelation irrespective of their enclosure degree. The tables of current variables TBLVar are\ngenerated for each executable relation separately.\n    The modification of the table of global variables or creation of a derived table of current\nvariables happens during the relation execution. For global variables the changes are brought\nin the same table, further the updated variant is to be used, for current variables the changes\nhave concern only the tables generated (or derived).\n    Depending on the location of an executable relation in the relation specifying the rule,\nthere are two ways of filling in the tables derived:\n1-st, when the relation is the constituent of sequence Bi; the derived tables are generated only\non the basis of the parent table irrespective of outcomes of execution of other relations Bi.\n2-nd, when the relation is the constituent of sequence Ci; in this case the derived table is\nunique and coincides with the initial table. All changes, which have been brought in the table\nat execution of other Ci relations, influence its current state.\n    The system uses one special variable with the fixed name key. The programmer can work\nwith it as with a usual variable without inclusion into the argument list of the\nsubroutine/function. The key value assignment happens always after the call to the subroutine\ndefined by the relation from sequence Bi and ended by the return code > 0410.\n    Note. During the search the variables are stated according to the search relation A1 and are\nbeing updated by values, which they accept in file A2.\n8. Subroutines / functions\nEvery 1-st term of sentences written as #xxx, is interpreted as a call to the subroutine\n(function) with a name xxx. If the name of the subroutine starts with a large character, it is\nconsidered global (or standard) and is being searched among functions executing by the\nsystem kernel.\n    Not going into details of subroutines/functions description, we shall mark, that some of\nthem are functions of two arguments (#Belong, #Dec, #Eq, #Fix, #Ge, #Grtdat, #Inc, #Le,\n#Ltldat, #Move, #Ne, #Part, #Spawn), others have one argument (#Date, #List, #SystemR,\n#Time, #Tstdat), there are subroutines/functions not having arguments (#Break, #Delete,\n#Exit, #Not, #Save).\n    Such subroutines/functions as #Delete, #Not, #Save have no arguments too, but play the\nrole of functions of the 2-nd level. Their operation spreads to a sentence, standing in\nsequences Bi or Ci immediately after these functions. These functions are represented\nrespectively as:\n#Delete:\n! or #Not:\n#Save:\n10\nFunctions #Dec, #Eq, #Fix, #Ge, #Inc, #Le, #Ne besides the standard form   #xxx (z1 z2) can\nalso be written also respectively:\n#Dec (z1 z2 )   as     (z1 -= z2)\n#Eq  (z1 z2)     as    (z1 == z2)\n#Fix (z1 z2)     as     (z1 := z2)\n#Ge  (z1 z2)     as    (z1 >= z2)\n#Inc (z1 z2)     as    (z1 += z2)\n#Le  (z1 z2)     as    (z1 <= z2)\n#Ne  (z1 z2)    as     (z1 != z2)\nThe return codes of subroutines/functions accept one of three values: 1, 0 and -1, and 1 is\ntreated as an execution of a logical condition, 0 and -1 - as a failure, -1 is considered besides\nas an interrupt return code.\n9. The example of application using SHM_db as DBMS\nWe shall show the characteristic features of the interface and implementation of database\ninquiries with usage of the language of inference rules on the following example.\n    We assume that it is required to organize a record in a text database, using as a key the\nattribute \"number of article\", and sampling given from base on a key value or in ascending\norder of attributes values, if the key is not given. We shall limit the external interface to the\nfollowing windows (Fig.1):\nFigure 1.\n11\n    The algorithm given below has a demonstration character and the optimality of solution\nwas not pursued.\nparam = (art+ {s});\nT = (param);\nQUERY = 0413;\nSAVE = 0423;\nDELETE = 0424;\n/*** Writing in file \"Text\" ***/\n-> (Flag :=0), #win3a(Art), (Flag ==0), $query3b()\n| (key == QUERY),(Art :=' ');\n#win3a(Art) -> $query3a(art+) | (Art !=' '), (art+ :=Art);\n#win3a(Art)\n-> { $query3a(art+),} | (Art ==' ');\n$query3a(art+), T\n-> (Flag :=1), (Old := param), #win3b(param);\n$query3b() -> (Old :=\" \"), #win3b(param) | (Art !=' '),(art+ :=Art);\n#win3b(param) -> #Save: T, (Old := param) | (key == SAVE),\n(Old ==\" \");\n#win3b(param) -> $query3d(), $query3c(param)\n| (key == SAVE), Old !=\" \"), (param != Old);\n$query3d() -> #Delete: T | (param := Old);\n$query3c(param) -> #Save: T, (Old := param);\n#win3b(param) -> #Delete: T, #Break() | (key == DELETE);\n    One of the major features of algorithm representation with usage of the language of\ninference rules is that there is no necessity of the external description of data structure for\nbase. The first five sentences of the given text set substitutions and are introduced only with\nthe purpose of the greater readability of algorithm, and substitution T = (param); underlines\nthat the structure of the scheme of storage is identical to the structure of parameters of the\nwindow win3b.\n    Setting the system variable key should be provided by the programmer at implementation\nof event processing functions on pressing corresponding keys with the usage of resources of\nSHM_db program interface. (The creation of the interface units easily gives in to automation.\nIn variant for Unix V.3 the possibility of creation of units with the usage of extended text\neditor was realized.)\n    In the given text the first rule states that immediately from the head program, at pressing\nthe key QUERY with simultaneous assignment of value ' '(empty) for global variable Art,\nthe following sentences become active sequentially:\n    (Flag :=0) - reset of global variable Flag in 0;\n12\n    #win3a(Art) - control transfer to the unit (subroutine/function), realizing the program\ninterface with the window (form) win3a;\n    (Flag ==0) - check of Flag on 0;\n    query3b() - non-executable sentence generating transition to derivative rules.\n    The 2-nd rule defines the transition from the unit of window interface win3a to non-\nexecutable sentence $query3a(art+). The condition of transition is nonblank value Art,\nwhich is stated at fulfillment of unit win3a. Simultaneously this value is assigned to the local\nvariable art+ (presence of the sign + means that the inverse references of appropriate\nparadigm are ordered on increasing of values of variable).\n    The most essential for understanding of logic of operation SHM_db are the 3-rd and the 4-\nth rules.\n    The construction {$query3a (art+),} means initiation of transition to derivative rules\nsequentially for all values art+.\n    query3a(art+), T\n is the inverse rule realizing the search of sentences on the value of\nvariable art+  according to the scheme of storage T (in view of substitutions (art+ {s}) ).\n    It is necessary to remark, that the field Text is described as {s}, that is the list of values of\ns(that in the given example is not necessary, as the search on the contents is absent).\n    The functions of saving and deleting are carried out with the help of functions of the 2-nd\nlevel and are being written accordingly as  #Save: T   and   #Delete: T .\n    The standard function #Break() returns the code -1 to unit win3b in case the deleting is\nproduced.\n    The file containing rules in text format, by resources SHM_db is being analyzed and\nmapped as the relations of 4-th level's dynamic structure. It is impossible to treat this process,\nperhaps, as interpretation or compilation. The relations mapping the rules file are formed only\nat the first start of the program and are being adjusted in the case of change of file\nmodification date or creation date of load module.\n10.   SHM_db and natural language processing\nNow we shall dwell upon those possibilities, which SHM_db submits for the tasks of natural\nlanguage processing. For the recursive analysis of rules, described in the second section of\nthe present paper, some changes are entered into kernel of a DBMS. The mode, distinguished\nfrom the usual one by a little bit other processing of finite states and by usage of the\nadditional stack for preventing of loopholes at recursive search, is added. Besides, two files\nof rules are introduced (in a nomenclature SHM_db) with the fixed names RuleTrue and\nRuleFalse. At initialization of the system the files are empty, their filling is being carried out\nin the learning process. One more addition concerns the determining at input all possible\nreferences for sentences of the natural language to the schemes, available in the database. In\nother words it is possible to say, that the \"understanding\" process of the entered text as\napplied to SHM_db is equivalent to the determining the references of sentences to the\nschemes.\n    Let's consider two fragments of rules file of the demonstration application*.\n                                                          \n* The demonstration application can be submitted by the author for familiarizing in reply to inquiry by\nE-mail.\n13\n    The 1-st fragment is creation and modification of semantic rules in the learning process\n(Fig.2).\nQUERY1 = 0411;\nSAVE = 0423;\nDELETE = 0424;\n/*** Teaching ***/\n->\n#win11(s1 q1 a1) | (key == QUERY1),\n(s1 := \"Tom read ( a book ) .\"),\n(q1 := \"who read ( a book ) ?\"),\n(a1 := \"Tom read ( a book ) .\");\n#win11(s1 q1 a1) - > #winR() | (key == SAVE), #add_rule0(q1 s1 a1);\n#win11(s1 q1 a1) -> #winQ () | (key ==DELETE), #del_rule0(q1 s1 a1);\n. . . . . .\nFigure 2.\nHere variable s1 corresponds to the entered sentence, q1 - to the question, a1 - to the answer\nto the question. The value assignment for variables s1, q1, a1 is made for visualization. The\nparentheses select the steady collocations at training; it gives more large generalizations at\nmodification of the schemes. The subroutine/function  #add_rule0(q1 s1 a1)  realizes the\nsearch of similar rules, creation or modification of the schemes of rules and addition of\nparadigm values. This subroutine creates also direct references (references of belonging) of\ncreated schemes to the rules file RuleTrue. The subroutine/function #del_rule0(q1 s1 a1)\ndeletes the relations corresponding to the rule entered, and at impossibility of their deleting\nfrom the generalized schemes of rules, sets the given rule into the file RuleFalse.\n    Except training under the circuit sentence-question-answer in the demonstration\napplication the circuits condition-consequence and double condition-consequence are\nrealized also.\n14\n    The second fragment demonstrates the example of \"semantic search\", in which the context\nsearch of articles from the file Text and the answer to the entered question according to\nsemantic rules generated by the system in the learning process are shown (Fig.3).\nT = (art+ {s});\nQUERY4 = 0414;\nSEARCH = 0427;\n/*** Semantic search ***/\n-> #win4a(q) | (key == QUERY4), (q := \"who read a book ?\");\n#win4a (q) ->\n(Flag :=0), #trans4(q s),\n(Flag ==0), #win2b (\"I do not know.\" \" \")\n| (key == SEARCH);\n#trans4(q s), { T,} ->\n(Art := art+), (Q :=q), #trans3 ({s} s1);\n#trans3 ({s} s1) ->\n#trans2 (Q s1 a);\n#trans2 (Q s1 a)\n->\n(Flag :=1), #win2b(a Art);\nFigure 3.\n#trans4(q s)  realizes a search of sentences satisfying the condition of search, that is a\nsearch of sentences s, which together with a question q correspond to any inverse rule. And\nnot only sentences, directly responding to the inquiry, are taken into account, but also\nsentences them generating.\n#trans3({s} s1)   selects the sentences immediately contained in the article retrieved, and\nalso generates sentences being derivative from the sentences of the article and their\ncombinations.\n#trans2 (Q s1 a)  searches the rules, satisfied by pair Q s1 (here Q is the initial question,\ns1 is the sentence generated by subroutine/function trans3) and forms the answer.\n15\nNote. The reverse order of variables q and s in the argument list of subroutines/functions\ntrans2, trans4 is explained by search algorithm features of the inference rules and by\nrecord of inverse rules.\n    The application generates not only direct answers, but also answers being derivative as for\nthe questions (at the expense of the analysis of inverse rules) and for the answers as well\n(using direct rules). Assume the example, that in the database there are rules:\n          (P1 is elder than P2.  Who is elder than P2 ?)  ->  (P1 is elder than P2.);\n          (P2 is younger than P1.)  ->  (P1 is elder than P2.);\n          ((P3 is younger than P2.)(P2 is younger than P1.) )  ->  (P3 is younger than P1.);\nHere P1, P2, P3 are paradigms. We admit also, that article N contains sentences:\n          Tom is younger than Bill.\n          Bill is younger than Jon.\nThen to the question:    Who is elder than Tom?\n two answers will be obtained:           Bill is elder than Tom.\n                                                            Jon is elder than Tom.\n    The experiments with the program of semantic search suggest the idea, that (contrary to\nChomsky ideas [2], being the theoretical base of modern compilers) a \"concept\" or a\n\"semantic image\" in SHM_db can be treated as some aggregate of the connected points in the\nspace of recursive inferences. And natural language is taken as the basis of representation of\ninformation, which does not require further interpretation.\n11.    Some problems, which require further solution\n    The problem of convolution of the relations. Now on the 0-th level at data input the\nunambiguous convolution of character sequences on component combinations always is\nbeing carried out. By its means more compact allocation of the data in base is achieved. For\nexample, if in the database there already exists combination of characters (in), the word\n\"input\" will be represented as the relation ((in)put).\n    On the 1-st level in the semantic mode the convolution on collocations is also being\nrealized. But the analysis on a multivalent of convolution on the 1-st level now is not being\ncarried out. Besides, there is a non-realized possibility of creation of nested paradigms at\nrules modification.\n    The problem of anaphoric similarity requires additional study. It is closely connected with\nthe problems of the relations' convolution and gives additional information for paradigms\ngeneralization. It results, in the long run, in increasing the speed of training (more precisely,\nit decreases the amount of the initial rules presented as samples).\n    The most essential effect at training is achieved by the generalization of paradigms. This\nprocess cannot go completely automatically and requires obtaining additional information\n(under the initiative of the system). The generalization of paradigms in the dialogue for the\nsemantic mode SHM_db is now on the stage of debugging.\n16\n    Taking into account, that the overall performance of the system as a whole directly\ndepends on the speed of search of the derivative relations, the studies of algorithms of\nordering the relations on their usage probability were carried out. SHM_db allows doing it by\ncollection of statistical information in an additional shared segment with subsequent on-pair\nreordering of the relations by means of the service defragmentation procedure. The loss of\nproductivity in the mode of collection of statistical information practically was not observed.\n12.   Conclusion\n1.  The principle of construction of DBMS with the usage of the File Mapping mechanism of\nthe operating system has shown its ability for work. With the help of SHM_db some systems\nconcerning the tasks of management automation and CAD were realized. Limitations on the\ndata size concerned with 4 Gbytes address space of the 32 bit processors virtual storage will\nbe removed a bit later if to take into consideration the tendency of development of computer\nequipment in the direction of microprocessors digit capacity increase.\n2.  DBMS, using a non-byte data representation with fixing the relations on the space of\nvirtual addresses, despite seeming wastefulness concerning both the size of data and time of\nprocessing, is quite comparable to commercial implementations of DBMS, including\nrelational ones. For information: the dictionary of 10000 Russian words, including their\npossible forms, occupies about 10 Mbytes of the virtual storage.\n 3. The language for record of rules, considered in the paper, includes the peculiarities\npermitting to realize algorithms, based on recursive inference, in the combination with\nprocedural sequences.\n4.  Using the same structure of the relations for the record of both the language constructions\nand the data, the language expresses inquiries to the database within the framework of the\nsyntax.\n5.  The features of structuring of the information in SHM_db allow adequately representing\nsemantic structures, characteristic for natural languages. The application, described in the\npaper, demonstrates not only the search on the contents, but also the opportunity of reasoning\nsimulation.\n 6.  SHM_db could be used as a base for realization of research in the field of processing the\nnatural language, similarly to the system GATE [4], though in other direction.\nReferences\n1. Androutsopoulos I., Ritchie G., Thanisch P. Time, Tense and Aspect in Natural Language\nDatabase Interfaces. Natural Language Engineering, 4(3), pp. 229-276, Sept. 1998,\nCambridge Univ. Press. Available in the Computation and Language archive under cmp-\nlg/9803002.\n2. Higman B. A comparative study of programming languages. Mir, Moscow, 1974.\n3. Cardie C. Empirical Methods in Information Extraction, AI Magazine 18 (4), pp. 65-79,\n1997.\n4. Cunningham H., Gaizauskas R., Humphreys K., Wilks Y. Experience with a Language\nEngineering Architecture: Three Years of GATE. In Proceedings of the AISB'99\nWorkshop on Reference Architectures and Data Standards for NLP, The Society for the\nStudy of Artificial Intelligence and Simulation of Behaviour, Edinburgh, U.K. Apr, 1999.\n17\n5. Lashmanov A.V. Deductive databases: language aspect. Databases and hypertext\nsystems, 9, pp. 1-33, ELDOC, Moscow, 1991.\n6. Nilsson U. and Maluszynski J. Logic, Programming and Prolog (2ED), 1995. Available\nfrom URL = http://archive.comlab.ox.ac.uk/logic-prog.html.\n7. R++ User Manual, AT&T Bell Laboratories, 1995. Available from URL =\nhttp://www.research.att.com/sw/tools/r++/publications.html.\n8. Tang L.R. and Mooney R.J. Automated Construction of Database Interfaces: Integrating\nStatistical \nand \nRelational \nLearning \nfor \nSemantic \nParsing,\nProceedings of the Joint SIGDAT Conference on Empirical Methods in Natural\nLanguage Processing and Very Large Corpora (EMNLP/VLC-2000), pp. 133 - 141,\nHong Kong, October, 2000.\n9. Turing A.M. Computing Machinery and Intelligence. The Journal of the Mind\nAssociation, Oxford University Press, vol. LIX, 236, pp. 433-460, 1950.\n10. Zelle J.M. and Mooney R.J. Learning to Parse Database Queries Using Inductive Logic\nProgramming, Proceedings of the 14th National Conference on Artificial Intelligence, pp.\n1050-1055, Portland, OR, August 1996. AAAI Press/MIT Press.\n",
  "categories": [
    "cs.CL",
    "cs.AI",
    "cs.DB",
    "cs.IR",
    "cs.LG",
    "cs.PL",
    "D.3.2; H.2.4"
  ],
  "published": "2001-06-10",
  "updated": "2001-06-10"
}