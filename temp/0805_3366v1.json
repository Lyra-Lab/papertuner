{
  "id": "http://arxiv.org/abs/0805.3366v1",
  "title": "Computational Representation of Linguistic Structures using Domain-Specific Languages",
  "authors": [
    "Fabian Steeg",
    "Christoph Benden",
    "Paul O. Samuelsdorff"
  ],
  "abstract": "We describe a modular system for generating sentences from formal definitions\nof underlying linguistic structures using domain-specific languages. The system\nuses Java in general, Prolog for lexical entries and custom domain-specific\nlanguages based on Functional Grammar and Functional Discourse Grammar\nnotation, implemented using the ANTLR parser generator. We show how linguistic\nand technological parts can be brought together in a natural language\nprocessing system and how domain-specific languages can be used as a tool for\nconsistent formal notation in linguistic description.",
  "text": "Computational Representation of Linguistic\nStructures using Domain-Speciﬁc Languages\nFabian Steeg1, Christoph Benden2 & Paul O. Samuelsdorﬀ3\n1 Computer Science for the Humanities, University of Cologne\n2 German Institute of Medical Documentation and Information, Cologne\n3 General Linguistics, University of Cologne\nOctober 30, 2018\nAbstract. We describe a modular system for generating sentences from formal\ndeﬁnitions of underlying linguistic structures using domain-specific languages. The\nsystem uses Java in general, Prolog for lexical entries and custom domain-speciﬁc\nlanguages based on Functional Grammar and Functional Discourse Grammar no-\ntation, implemented using the ANTLR parser generator. We show how linguistic\nand technological parts can be brought together in a natural language processing\nsystem and how domain-speciﬁc languages can be used as a tool for consistent\nformal notation in linguistic description.\n1\nMotivation and Overview\nThis paper describes a system for generating sentences using domain-speciﬁc\nlanguages (DSL; see section 3) for the formal representation of underlying\nlinguistic structures and lexical entries.4 The DSL implemented for under-\nlying structures is based on representations in Functional Grammar (FG;\nDik 1997). The grammar module and the lexicon are based on a revised and\nextended version of the implementation described in Samuelsdorﬀ(1989).\nTo evaluate the ﬂexibility of our approach, we also implemented domain-\nspeciﬁc languages for formal representations in Functional Discourse Gram-\nmer (FDG), which as FG explicitly demands “formal rigor” (Hengeveld and\nMackenzie 2006:668). Creating a computational implementation is a valu-\nable evaluation tool for linguistic theories in general (cf. Bakker 1994:4).\nBy actually generating linguistic expressions from representations used in a\nlinguistic theory, an implementation can be used to evaluate and improve\nrepresentational aspects of the theory.\n4 The described implementation and infrastructure for collaborative development are available\nonline (http://fgram.sourceforge.net).\n1\narXiv:0805.3366v1  [cs.CL]  21 May 2008\n2\nSystem Architecture\nThe system consists of individual, exchangeable modules for creating an un-\nderlying structure, processing that input and generating a linguistic expres-\nsion from the input (cf. Fig. 1 for an overview of the system architecture). In\nthe input module an underlying structure is created, edited and evaluated.\nThe input is sent to the processing module, which communicates with the\ngrammar module. When the generation is done, the user interface displays\neither the result of the evaluation, namely the linguistic expression gener-\nated from the input, or an error message (cf. Fig. 3 for sample output of the\nconsole-based implementation of the input module). The system architecture\ncan be characterized as a three-tier architecture (Eckerson 1995).\nSuch a modular approach has two main advantages. First, modules can\nbe exchanged; for instance the input module is implemented both as a desk-\ntop application and as a web-based user interface with the actual processing\nhappening on a server (implemented using Java Server Pages on a Tomcat\nservlet container). Second, individual modules of our system can be com-\nbined with other natural language processing (NLP) components and so be\nreused in new contexts.\n3\nDomain-Speciﬁc Languages\nThe usage of languages which are tailored for a speciﬁc domain (domain-\nspeciﬁc languages, DSL) has a long tradition in computing (e.g. for conﬁg-\nuration ﬁles) and has been acknowledged as a best practice in recent years\n(cf. Hunt and Thomas 1999). Domain-speciﬁc languages are also a central\naspect of a programming paradigm called language-oriented programming\n(cf. Ward 2003).\nOur system uses Java as a general-purpose language, Prolog as a DSL\nfor lexical entries and expression rules (see section 4.3, cf. Macks 2002 for\na similar usage of Prolog), and a custom DSL for describing underlying\nstructures, implemented using ANTLR, a tool for deﬁning and processing\ndomain-speciﬁc languages (Parr 2007, http://www.antlr.org/). While e.g.\nin the domain of banking a DSL might describe credit rules, a linguist work-\ning with a model like FDG uses a DSL for linguistic description, in particular\nfor the formal notation of underlying linguistic structures. With ANTLR,\n2\nd1x:'man'[N]:'happy'[A]\nProcessing \nModule\nGrammar \nModule\nInput\nModule\nDisplay \nResult\nCreate \nInput\nProcess \nProlog \nRepr.\nGenerate \nLing. \nExpr.\nProcess \nInput\nProcess \nResult\nThe happy man\n Access \nLexicon\nApply \nExpr. \nRules\nProlog representation of \nthe input\nJava\nJava,\nANTLR\nProlog representation of \nthe result\nProlog\nFig. 1: System architecture\n3\nthe form of the DSL is deﬁned using a notation based on the Extended\nBackus-Naur Form (EBNF, cf. Wirth 1977, see Fig. 6 for the format used\nby ANTLR). From that grammar deﬁnition a Java parser that can process\nthe DSL is automatically generated by ANTLR.\n4\nLinguistic Structures\n4.1\nStructures in Functional Grammar\nThe processing module’s input format is a representation of the linguis-\ntic expression to be generated (cf. Fig. 2 and 3); its form is based on the\nrepresentation of underlying structures given in Dik (1997). The processing\nmodule parses the input entered by the user and creates an internal object\nrepresentation (cf. Fig. 4). This is then converted into the output format\nof the processing module, a Prolog representation of the input (cf. Fig. 5),\nwhich is used by the grammar module (cf. section 4.3). The mapping of the\nvalues used in the Prolog representation to those used in the input structure\n(like m to plural) is done in a Java properties ﬁle and therefore allows for\nconﬁguration of the formal aspects of the input (which uses e.g. m) inde-\npendently of the implementation code that generates the expression (which\nuses e.g. plural).\n(Past e:\n(d1x:’man’[N]:\n(Past Pf e:’give’[V]\n(d1x:’mary’[N])Ag\n(dmx:’book’[N]:’old’[A])Go\n(x:’man’[N])RecSubj\n)\n)\n(d1x:’john’[N])0\n)\nFig. 2: A nested underlying structure in Functional Grammar based on Dik\n(1997), which is parsable by the generated ANTLR v2 parser (rep-\nresents John is the man who was given the old book by Mary)\n4\n>> (e:’love’[V]:(x:’man’[N])AgSubj (x:’woman’[N])GoObj)\nThe man loves the woman\n>> (Past pf e:’give’[V]:\n(dmx:’farmer’[N]:’old’[A])AgSubj\n(imx:’duckling’[N]:’soft’[A])GoObj\n(dmx:’woman’[N]:’young’[A])Rec)\nThe old farmers had given soft ducklings to the young women\nFig. 3: Sample output of the console-based implementation of the input\nmodule: a linguistic structure conforming to Functional Grammar\nnotation is entered at the prompt (≫), for which the linguistic ex-\npression is generated using the linguistic knowledge in the grammar\nmodule\nlexeme = give\ntense = past\n...\nNode x1:Predicate\nlexeme = farmer\nmodif = old\n...\nNode x2:Term\nlexeme = duckling\nmodif = soft\n...\nNode x3:Term\nlexeme = woman\nmodif = young\n...\nNode x4:Term\nFig. 4: Internal representation of the second structure in Fig. 3 (represents\nThe old farmers had given soft ducklings to the young women): a\ntree of Java objects (in UML notation)\n5\nnode(x1, 0). node(x2, 1).\nnode(x3, 1). node(x4, 1).\nprop(x1, type, pred).\nprop(x1, tense, past).\nprop(x1, perfect, true).\nprop(x1, progressive, false).\nprop(x1, mode, ind).\nprop(x1, voice, active).\nprop(x1, subnodes, [x2, x3, x4]).\nprop(x1, lex, ’give’).\nprop(x1, nav, [V]).\nprop(x1, det, def).\nprop(x2, type, term).\nprop(x2, role, agent).\nprop(x2, relation, subject).\nprop(x2, proper, false).\nprop(x2, pragmatic, null).\nprop(x2, num, plural).\nprop(x2, modifs, [old]).\nprop(x2, lex, ’farmer’).\nprop(x2, nav, [N]).\nprop(x2, det, def).\nprop(clause, illocution, decl).\nprop(clause, type, mainclause).\nprop(x3, type, term).\nprop(x3, role, goal).\nprop(x3, relation, object).\nprop(x3, proper, false).\nprop(x3, pragmatic, null).\nprop(x3, num, plural).\nprop(x3, modifs, [soft]).\nprop(x3, lex, ’duckling’).\nprop(x3, nav, [N]).\nprop(x3, det, indef).\nprop(x4, type, term).\nprop(x4, role, recipient).\nprop(x4, relation, restarg).\nprop(x4, proper, false).\nprop(x4, pragmatic, null).\nprop(x4, num, plural).\nprop(x4, modifs, [young]).\nprop(x4, lex, ’woman’).\nprop(x4, nav, [N]).\nprop(x4, det, def).\nFig. 5: Prolog representation of the second structure in Fig. 3, which is\ngenerated from the object representation in Fig. 4 and used to create\nthe linguistic expression The old farmers had given soft ducklings to\nthe young women in the grammar module (cf. section 4.3)\n6\n4.2\nStructures in Functional Discourse Grammar\nTo evaluate the ﬂexibility of our approach, we implemented grammars for\nstructures on the Representational Level (RL) and the Interpersonal Level\n(IL) in Functional Discourse Grammar (FDG, Hengeveld and Mackenzie\n2006), the successor theory of FG. Fig. 6 shows the grammar for structures\non the RL, from which a parser is generated that can parse expressions like\nthe structure in Fig. 7 into a structure as in Fig. 8.\ngrammar Representational;\ncontent\n: ’(’ OPERATOR? ’p’ X ( ’:’ head ’(’ ’p’ X ’)’ )* ’)’ FUNCTION? ;\nsoaffairs\n: ’(’ OPERATOR? ’e’ X ( ’:’ head ’(’ ’e’ X ’)’ )* ’)’ FUNCTION? ;\nproperty\n: ’(’ OPERATOR? ’f’ X ( ’:’ head ’(’ ’f’ X ’)’ )* ’)’ FUNCTION? ;\nindividual : ’(’ OPERATOR? ’x’ X ( ’:’ head ’(’ ’x’ X ’)’ )* ’)’ FUNCTION? ;\nlocation\n: ’(’ OPERATOR? ’l’ X ( ’:’ head ’(’ ’l’ X ’)’ )* ’)’ FUNCTION? ;\ntime\n: ’(’ OPERATOR? ’t’ X ( ’:’ head ’(’ ’t’ X ’)’ )* ’)’ FUNCTION? ;\nhead\n: LEMMA? ( ’[’\n( soaffairs\n| property\n| individual\n| location\n| time )* ’]’ ) ? ;\nFUNCTION\n: ’Ag’\n| ’Pat’\n| ’Inst’ ; //etc.\nOPERATOR\n: ’Past’\n| ’Pres’ ; //etc.\nLEMMA\n: ’a’..’z’+ ;\nX\n: ’0’..’9’+ ;\nFig. 6: Complete ANTLR v3 grammar for structures on the Represen-\ntational Level in Functional Discourse Grammar, which describe\nnested structures as in Fig. 7: each head element can take diﬀer-\nent forms (content, soaﬀairs, property, individual, location, time),\nwhich themselves contain a head element again\n7\n(p1:[\n(Past e1:[\n(f1:tek[\n(x1:im(x1))Ag\n(x2:naif(x2))Inst\n](f1))\n(f2:kot[\n(x1:im(x1))Ag\n(x3:mi(x3))Pat\n](f2))\n](e1))\n](p1))\nFig. 7: Underlying structure of a serial verb construction in Jamaican Creole\n(for im tek naif kot mi, ’He cut me with a knife’, Patrick 2004:290)\non the Representational Level in Functional Discourse Grammar,\nwhich is parsable by the parser generated from the rules in Fig. 6.\nThis representation is based on our analysis of the serial verb con-\nstruction as a single event, which can be backed by native speaker\nintuition and semantic analysis (Durie 1997:291); an analysis of a se-\nrial verb construction with two events as given in Example 2 of van\nStaden (2006) can also be represented using the domain-speciﬁc lan-\nguage, while variations in the formal structure would be recognized\nas invalid\nFig. 8: Part of the parse tree the parser generated from the rules in Fig. 6\nproduces for the structure in Fig. 7\n8\nAn ANTLR grammar deﬁnition like this provides a validator for the\nformal structure of RL representations and can be used with a tool like\nANTLRWorks (http://www.antlr.org/works/) to analyse these represen-\ntations. Having an internal representation of the input (cf. Fig. 8), alter-\nnative processing to the creation of the corresponding linguistic expression\n(as have described for FG structures in section 4.1) is feasible, like output\nof typeset representations of underlying structures in diﬀerent formats. This\nwould allow the representation used for publication (e.g. with subscript index\nnumbers, with or without indentation, etc.) to be created from the formal,\nvalidated representation.\n4.3\nLexical Entries\nIn the grammar module the Prolog representation of the input generated by\nthe processing module (cf. Fig. 5) is used to generate a linguistic expression.\nProlog oﬀers convenient notation and processing mechanisms, e.g. lexical\nentries can be stored directly as Prolog facts (cf. Fig. 9). Prolog also has\na particular strong standing as an implementation language for FG (e.g.\nConnolly 1986; Samuelsdorﬀ1989; Dik 1992). By restricting the usage of\nProlog to the grammar module and combining5 it with other languages,\ninstead of using it as a general-purpose programming language for the entire\nprogram, we use Prolog as a DSL in one of its original domains.\nThe expression rules and the lexicon are based on a revised and extended\nversion of the implementation described in Samuelsdorﬀ(1989). To make\nthe implementation work as a module in the described system, the user\ndialog of the original version (in which the underlying structure is built step\nby step) was replaced by the formal representation that is created in the\ninput module and converted into a Prolog representation by the processing\nmodule (cf. section 4.1). This resembles the shift to a top-down organization\n(Hengeveld and Mackenzie 2006:668) in FDG, where the conceptualization\nis the ﬁrst step, not the selection of lexical elements, as it was in FG and in\nthe implementation described in Samuelsdorﬀ(1989).\n5 For\ncalling\nProlog\nfrom\nJava\nwe\nuse\nInterprolog\n(http://www.declarativa.com/\ninterprolog/). The Prolog implementation we use is SWI-Prolog (http://www.swi-prolog.\norg/).\n9\nverb(\nbelieve,\nstate,\n[regular, regular],\n[\n[experiencer, human, X1],\n[goal, proposition, X2]\n],\nSat\n).\nverb(\ngive,\naction,\n[gave, given],\n[\n[agent, animate, X1],\n[goal, any, X2],\n[recipient, animate, X3]\n],\nSat\n).\nFig. 9: Transitive and ditransitive verbs as Prolog facts in the lexicon\n5\nConclusion\nWe described a modular implementation of a language generation system,\nrepresenting underlying structures and lexical entries using domain-speciﬁc\nlanguages (DSL). The system makes use of an input format based on Dik\n(1997) and consists of modules implemented in Java, Prolog and ANTLR6.\nAs a ﬁrst result, this shows that a DSL can be used as a very ﬂexible linguistic\nexpert front-end to a knowledge base in a diﬀerent language (as we have\nshown in section 4.1 for underlying clause structures based on Functional\nGrammar that use a Prolog knowledge base). We believe this is a promising\nway how domain-speciﬁc linguistic knowledge can be applied in a natural\nlanguage processing system.\nAs all structures in FG and FDG, as well as the lexical entries (which\nare Prolog facts in our system) have a common tree structure, a uniﬁed\nimplementation using ANTLR to deﬁne and process all these structures in\nthe same manner as implemented and described for RL representations is\nfeasible. So as a second result, this shows that the concept of a DSL is ﬂexible\nenough to be applied for newer developments in linguistic theory (as we have\nshown for structures on the Representational Level in Functional Discourse\nGrammar in section 4.2) as well as for extensions of these (as we have shown\nfor structures describing lexical entries in section 4.3). Therefore domain-\nspeciﬁc languages can be used as a tool for consistent formal notation in\nlinguistic description. In our view this encourages the implementation of a\n6 ANTLR allows further processing in diﬀerent target languages including Java, C, C++, C#,\nObjective-C, Python and Ruby.\n10\nfull set of grammars for all the structures a linguist creates in linguistic\ndescription, which could be the core of software tools that would allow a\nlinguist to create linguistic representations like a programmer writes code,\na mathematician writes formulas or a musician writes notes: as something\nthat can actually be validated and even executed in a reproducible manner.\nReferences\nBakker, D. (1994). Formal and Computational Aspects of Functional Gram-\nmar and Language Typology. PhD thesis, Universiteit van Amsterdam.\n1\nConnolly, J. H. (1986). Testing functional grammar placement rules using\nprolog. International Journal of Man-Machine Studies, 24(6):623–632. 9\nDik, S. C. (1992). Functional Grammar in Prolog: an Integrated Implemen-\ntation for English, French and Dutch. Mouton de Gruyter, Berlin, New\nYork. 9\nDik, S. C. (1997). The Theory of Functional Grammar. Part 1: The Structure\nof the Clause (edited by Kees Hengeveld). Mouton de Gruyter, Berlin,\nsecond edition. 1, 4, 10\nDurie, M. (1997). Grammatical structures in verb serialization. In Alsina,\nA., Bresnan, J., and Sells, P., editors, Complex Predicates. Center for the\nStudy of Language and Information, Stanford, CA, USA. 8\nEckerson, W. W. (1995). Three tier client/server architecture: Achieving\nscalability, performance, and eﬃciency in client server applications. Open\nInformation Systems, 10(1). 2\nHengeveld, K. and Mackenzie, L. J. (2006). Functional discourse grammar.\nIn Brown, K., editor, Encyclopedia of Language and Linguistics, pages\n668–676. Elsevier, Oxford, second edition. 1, 7, 9\nHunt, A. and Thomas, D. (1999). The Pragmatic Programmer: From Jour-\nneyman to Master. Addison-Wesley Professional. 2\nMacks, A. (2002). Parsing akkadian verbs with prolog. In Proceedings of\nthe ACL-02 workshop on Computational approaches to semitic languages,\npages 1–6. 2\nParr, T. (2007). The Deﬁnitive ANTLR Reference: Building Domain-Speciﬁc\nLanguages. The Pragmatic Bookshelf, Raleigh. 2\n11\nPatrick, P. (2004). Jamaican creole: Morphology and syntax. In Kortmann,\nB., Schneider, E. W., Upton, C., Mesthrie, R., and Burridge, K., editors,\nA Handbook of Varieties of English. Vol 2: Morphology and Syntax, Topics\nin English Linguistics, pages 407–438. Mouton de Gruyter, Berlin & New\nYork. 8\nSamuelsdorﬀ, P. O. (1989). Simulation of a functional grammar in prolog.\nIn Connolly, J. H. and Dik, S. C., editors, Functional Grammar and the\nComputer, pages 29–44. De Gruyter. 1, 9\nvan Staden, M. (2006). Papuan narratives in functional discourse grammar.\nPoster presented at the Eleventh Biennial Symposium: Intertheoretical\nApproaches to Complex Verb Constructions. Houston: Rice University. 8\nWard, M. (2003). Language oriented programming. Science Labs Durham.\n2\nWirth, N. (1977). What can we do about the unnecessary diversity of nota-\ntion for syntactic deﬁnitions? Commun. ACM, 20(11):822–823. 4\n12\n",
  "categories": [
    "cs.CL",
    "I.2.4; I.2.7"
  ],
  "published": "2008-05-21",
  "updated": "2008-05-21"
}