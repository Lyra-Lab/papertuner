{
  "id": "http://arxiv.org/abs/1204.0221v1",
  "title": "MyProLang - My Programming Language: A Template-Driven Automatic Natural Programming Language",
  "authors": [
    "Youssef Bassil",
    "Aziz Barbar"
  ],
  "abstract": "Modern computer programming languages are governed by complex syntactic\nrules. They are unlike natural languages; they require extensive manual work\nand a significant amount of learning and practicing for an individual to become\nskilled at and to write correct programs. Computer programming is a difficult,\ncomplicated, unfamiliar, non-automated, and a challenging discipline for\neveryone; especially, for students, new programmers and end-users. This paper\nproposes a new programming language and an environment for writing computer\napplications based on source-code generation. It is mainly a template-driven\nautomatic natural imperative programming language called MyProLang. It\nharnesses GUI templates to generate proprietary natural language source-code,\ninstead of having computer programmers write the code manually. MyProLang is a\nblend of five elements. A proprietary natural programming language with\nunsophisticated grammatical rules and expressive syntax; automation templates\nthat automate the generation of instructions and thereby minimizing the\nlearning and training time; an NLG engine to generate natural instructions; a\nsource-to-source compiler that analyzes, parses, and build executables; and an\nergonomic IDE that houses diverse functions whose role is to simplify the\nsoftware development process. MyProLang is expected to make programming open to\neveryone including students, programmers and end-users. In that sense, anyone\ncan start programming systematically, in an automated manner and in natural\nlanguage; without wasting time in learning how to formulate instructions and\narrange expressions, without putting up with unfamiliar structures and symbols,\nand without being annoyed by syntax errors. In the long run, this increases the\nproductivity, quality and time-to-market in software development.",
  "text": "MyProLang – My Programming Language \nA Template-Driven Automatic Natural Programming Language \n \nYoussef A. Bassil, Aziz M. Barbar \n \n \n \n \nAbstract—Modern computer programming languages are \ngoverned by complex syntactic rules. They are unlike natural \nlanguages; they require extensive manual work and a \nsignificant amount of learning and practicing for an individual \nto become skilled at and to write correct programs. Computer \nprogramming is a difficult, complicated, unfamiliar, non-\nautomated, and a challenging discipline for everyone; \nespecially, for students, new programmers and end-users. \nThis paper proposes a new programming language and an \nenvironment for writing computer applications based on \nsource-code generation. It is mainly a template-driven \nautomatic natural imperative programming language called \nMyProLang. It harnesses GUI templates to generate \nproprietary natural language source-code, instead of having \ncomputer programmers write the code manually. MyProLang \nis a blend of five elements. A proprietary natural programming \nlanguage \nwith \nunsophisticated \ngrammatical \nrules \nand \nexpressive syntax; automation templates that automate the \ngeneration of instructions and thereby minimizing the learning \nand training time; an NLG engine to generate natural \ninstructions; a source-to-source compiler that analyzes, parses, \nand build executables; and an ergonomic IDE that houses \ndiverse functions whose role is to simplify the software \ndevelopment process. \nMyProLang is expected to make programming open to \neveryone including students, programmers and end-users. In \nthat sense, anyone can start programming systematically, in an \nautomated manner and in natural language; without wasting \ntime in learning how to formulate instructions and arrange \nexpressions, without putting up with unfamiliar structures and \nsymbols, and without being annoyed by syntax errors. In the \nlong run, this increases the productivity, quality and time-to-\nmarket in software development. \nFuture research can improve upon MyProLang so much so \nthat it can be internationalized to support more natural \nlanguages. It can also benefit from OOP capabilities and from \nreusable programming libraries. \n \nIndex Terms—Automatic Programming Language, Natural \nLanguage Generation, Source-Code Generation, Source-to-\nSource Compiler. \n \nI.  INTRODUCTION \nAlthough today's programming languages are well \nobserved and used worldwide, they are still syntactically \nsophisticated [1] since they contain confusing structures, \ncomplex expressions and uncommon symbols. Furthermore, \n \n \nManuscript received July 1, 2008. This project won the local Microsoft \nImagine Cup 2007 competition. The team members were Youssef Bassil, \nFarid Khalil and Elias Eid. \nA. M. Barbar is the chairperson of the Computer Science Department at \nthe American University of Science & Technology, Beirut, Lebanon \n(phone: +961-1-218716; fax: +961-1-339302; email: abarbar@aust.edu.lb). \nY. A. Bassil is a Computer Science graduate student at the American \nUniversity \nof \nScience \n& \nTechnology, \nBeirut, \nLebanon \n(email: \nybassil@aust.edu.lb).         \n \nthe extra details and notations related to the formality and \ndesign of the language, like include-directives, compiler \nprimitives, classes declaration, functions prototype and \ninitialization statements, must be handled explicitly by the \nprogrammer, albeit they are of no use to his algorithm. Such \nintricacies and extra vestigial complexities prevent the \nlanguage from being a good learning instrument, hamper the \nprogramming practice, and increase the probability of \ncompilation and logical errors. Additionally, programming \nlanguages are inexpressive in that they don’t use human \nnatural language to represent codes and instructions. \nNaturalness of the language makes it possible for people to \nexpress their ideas in the same way they think about them, \n[2] this eases the process of implementing a mental plan into \ncode. Finally, programming is not an automatic generative \nprocess, it completely relies on the programmer to manually \nconstruct the source-code word by word and instruction by \ninstruction. This would consume time and slow down the \ndevelopment procedure. \nAs a result, we can admit that modern programming \nlanguages are not that easy to learn and manage, they bring \nin a lot of complications, they are erroneous, they don't \nreflect the programmer's intention, they are still manual, and \nthey impose barriers for beginners and average people with \nno previous training and experience.  \nWhat we are proposing is this paper is a programming \nlanguage characterized by its syntax simplicity and \nexpressiveness, its ease to learn and use, its ability to \nautomate programming processes, and its facility for rapid \napplication development (RAD). Ultimately, programming \nwould become a straightforward task, open to everyone in a \nway that end-users would simply become programmers. \n \n \nII. TERMINOLOGY \nIn this section, definitions of some concepts and key \nsubjects that are in some way connected to our work, are \ngiven. \nA.  Computer Programming \nProgramming is the process of building executable \napplications from the arrangement of certain words and \nsymbols called instructions. This arrangement is specified \nby a set of grammatical rules and other rules indicated by \nthe programming language itself [3]. \nAt early stages, the programmer has first to type \ninstructions in a text editor, and then he has to compile the \nsource-code to check for syntax errors, and generate \nmachine code that can be linked and executed as a \nstandalone application on a specific platform. \nB.  Source-to-Source Compiler \nA compiler is usually another computer program whose \njob is to scan and parse programmer's source-code to \nProceedings of the World Congress on Engineering and Computer Science 2008\nWCECS 2008, October 22 - 24, 2008, San Francisco, USA\nISBN: 978-988-98671-0-2\nWCECS 2008\ncapture syntax errors, and eventually generate machine code \nunderstandable by a particular machine-native instruction \nset [4]. \nA source-to-source compiler is a type of compilers that \ntakes a high-level language as input and produces another \nhigh-level language as output. Such type of compilers \nshould operate upon another traditional compiler whose \npurpose is to convey higher abstractions into lower native \ncode. \nC.   Source-Code Generation \nSource code generation is the process of generating \nprogramming source-code through any of various means \nsuch as XML schemas, graphical templates or UML models. \nSuch means are the input for the code generator, and the \nspawned source-code is the output. Code generators are \nusually separate applications or they can be embedded into \ndevelopment-environment tools. \nGUI Template-driven source-code generators are a type of \ncode generators that guide the user through an automated \nprocess of pop-up graphical windows or forms in order to \ngenerate a predefined piece of code. For instance, the query \nby example (QBE) system helps you create your own SQL \nqueries by selecting combo boxes, and filling up text fields \nwithout manually writing any line of code. \nD.  Natural Language Generation \nNatural Language Generation (NLG) is one of the \nemerging fields in natural language processing. An NLG \nsystem converts non-linguistic data, such as graphical \nmodels or templates, into natural linguistic information such \nas an English text [5]. An NLG source-code generator is a \nsystem that generates natural source-code pulled out from a \ncertain form of input. \nOne of the central goals of NLG is to investigate how \ncomputer programs can be made to produce high-quality, \nexpressive, uncomplicated and natural language text from \ncomputer-internal \nsophisticated \nrepresentations \nof \ninformation. An NLG system can be defined as follows [6]: \nGoal: Computer software which produces understandable \nand appropriate text in English or other human languages.  \nInput: Some underlying non-linguistic representation of \ninformation. \nOutput: Documents, reports, explanations, help messages, \nand other kinds of texts.  \nKnowledge sources required: Knowledge of the domain of \nthe system being constructed. \nE.  Automatic Programming Languages \nAutomatic programming languages are types of computer \nlanguages that generate the coding for you. They are built \nover a source-code generator, which uses a variety of gears \nsuch as templates or models, to extract specifications from \nthe user, and to ultimately produce the desired instructions \nand code. These generated instructions can be represented in \na well-known programming language such as C++, or it can \nbe represented in a proprietary language and thus a \nproprietary compiler should be built to do the translation to \nlower layers. \nAn automatic programming language can exploit natural \nlanguage generation techniques with the purpose of \nproducing natural source-code instead of the 3GL source-\ncode. \n \nIII. PREVIOUS WORK \nA lot of automatic programming languages and code \ngenerators exist nowadays. However, in this section, we are \nmostly concerned with known and acknowledged automatic \nprogramming languages oriented to IBM compatible PCs. \nQBE, otherwise known as query by example, is a form of \nautomatic programming language. It was developed by \nMoshé M. Zloof at IBM Research during the mid 1970s. \nQBE is a database automatic query language for relational \ndatabases. It is composed of graphical tables through which \nthe user would select table names, choose elements and set \nsearch conditions. The QBE system would then generate and \nexecute the appropriate SQL statement [7]. This approach \nallows the user to carry out powerful searches without the \nneed of having to learn the formal syntax of SQL. \nMicrosoft Corporation in the early 1990's introduced the \nMS Visual Studio IDE to support a group of programming \nlanguages. MS Visual Studio allows the designing of \ngraphical user interfaces in an interactive manner, while the \ncompiler, invisibly, generates the corresponding source-\ncode. In MS Visual Studio 2005 ADO.NET connections and \nobjects can be created via templates while the environment \ngenerates the corresponding source-code, without the \nprogrammer's knowledge. \nSnippet is yet another form of automatic programming \nthat was introduced by Microsoft Corporation. They are a \ncollection of predefined and reusable source-codes inserted \nby the programmer in the current document. Examples of \nSnippets could be if-blocks and for-loops structures. Their \npurpose is to relieve the programmer from the burden of \nmemorizing certain structures. With Snippets, programmers \ncan easily drop in code the same way they \"copy-paste\" text. \nMacros are also another common form of source-code \ngeneration. Macros usually hide numerous and complex \ninstructions by a single program statement, thus making the \nprogramming task more comprehensive and error-free. \nAlmost all Assembly languages implement a macro \nprocessor that replaces patterns in source-code according to \nrelatively simple rules. \n \n \nIV. PROJECT MOTIVATIONS \nThe chief problems that are tackled in this paper are \ndescribed herein. \n  \nSyntax Complexity and Programming Errors: All the \nprogramming languages available today on the market have \ntheir own syntax and grammar. Usually such syntax is not \nclear-cut since it has special format and rules, and it contains \nweird symbols and unusual notations. This poses barriers \nwhich, in turn complicates the programming process. \nMoreover, it ignites dozens of compilations and syntax \nerrors that make the language error-prone and subject to \nbugs and flaws. For instance, to create a string of characters \nin C, you may write char* name=\"John\";. Notice the \nmeaningless use of *, the double quotes and the semicolon. \nAnother form of complexity can be manifested in the subtle \ndistinctions in syntax that lead to confusion and non-\nconsistency [8]. For instance, in C, there are three different \nkinds of braces used in various situations: {}, () and []. In \nthe Java language, all control structures do not end with a \nsemicolon except for the do-while. Also in C, indexing of \narrays is done with square brackets; however, initialization \nProceedings of the World Congress on Engineering and Computer Science 2008\nWCECS 2008, October 22 - 24, 2008, San Francisco, USA\nISBN: 978-988-98671-0-2\nWCECS 2008\nis done with curly braces. As a result, novices get confused \nwhen a single notation can accomplish different effects [9]. \n \nTransparency \nand \nAbstraction: \nIn \ntraditional \nprogramming languages, low-level details and unnecessary \nterms must be handled by the programmer and not by the \nlanguage itself. For instance, the compiler directives and \nprimitives, the superfluous keywords and symbols, must be \ncarried out by the programmer even though it does not serve \nand it is not related to his logical algorithm. For instance in \nJava, to just print on the screen the message \"hello world\" \nyou still require a bunch of additional keywords and \nstatements. \n  \n          public class TestApp { \n \n   public static void main(String[] args)  \n                 { \n \n         System.out.println(\"Hello World\") ; \n                   } \n            } \n \nSyntax Inexpressiveness: In available programming \nlanguages, it is impossible to express your program's source-\ncode in a human natural English-like sentence. The odd \nformat of expressions and instructions in the language \nwould increase the gap between the programmer's natural \nplan and the practical implementation. As a design principle \nfor all learning environments, the translation process from \nthe student’s internal plans to the solution’s external \nrepresentation should be minimized [10]. It is more familiar \nto \nsay \nprint \nhello \non \nthe \nscreen \nthen \nsaying \nSystem.out.println(\"Hello\") ;. \n \nNon-automation of Programming Proceedings: Nearly \nall programming instructions are written manually by the \nprogrammer through traditional ways. Every instruction and \ndeclaration must be typed literally in a text editor through \nthe machine keyboard. This involves time, effort and \nreserves resources. \n \nLanguage Learn Ability: Mixed together, all the previous \nproblems would hinder people from learning programming \neffortlessly. In other words, gaining knowledge of the \nlanguage would not be that easy and would require days or \neven months to become skilled at. Yet it would constitute an \nobstacle and a nightmare for the new learners and the new \nprogrammers. \n \nOur incentive is to provide an uncomplicated, transparent, \nless error-prone, natural, automatic, and an easy to learn \nprogramming language, yet has the ability to develop \ngeneral-purpose computer programs. \n \n \nV. PROPOSED SOLUTION \nOur proposed solution is a template-driven automatic \nnatural programming language used to develop computer \nprograms. It is MyProLang which allows you to build \ncomputer applications based on source-code generation. It \nutilizes graphical templates or GUI forms, populated \ninteractively with specifications data by the programmer, to \ngenerate natural proprietary-language source-code. This \nsource-code can be eventually compiled into executables.  \nMyProLang \nis \na \ncombination \nof \na \nproprietary \nprogramming language; a set of automation templates to \nautomate programming procedures; an NLG engine to \nconvert user specifications from templates into natural text; \na source-to-source compiler to compile and generate \nexecutables; and an IDE to better interface the programmer \nwith the machine. Fig. 1 depicts the five logical modules or \nchunks of MyProLang. \n \n \nFig. 1 - Logical Modules \n \nA.  Programming Language \nMyProLang is a general-purpose imperative procedural, \nstatically \ntyped, \ntype \nsafe \nand \ncompiled \nnatural \nprogramming language oriented to IBM compatible PCs. It \nis used to write general-purpose standalone computer \nexecutables. It embraces a set of concepts that exist in any \nmodern procedural language. For instance, MyProLang \nincludes declaration of variables with different data types \n(Number and String). It also provides a one-dimensional \nstatic array structure. In addition, it supports arithmetic and \nlogical calculations and provides relational operations. Its \ndifferent operators can be summarized as follows: +,-,*, /, \n%,(), And, Or, Greater, Smaller, Greater or Equal, Smaller \nor Equal, Equal, Not Equal and the assignment operator =. \nFurthermore, the ampersand operator & is used for string \nconcatenation. MyProLang also supports different control \nstructures such as IF, IF-ELSE and IF-ELSEIF, REPEAT, \nSELECT with block compound statements and multiple \noperands condition statements. Moreover, MyProLang \nprovides an input and output dialog boxes to read in data \nfrom the keyboard, and to display information on the screen.  \nB.  Automation Templates \nThe automation templates play a leading role in our \nsolution. They are used to systematically guide the \nprogrammer while generating instructions. MyProLang's \nautomation templates are GUI based, in that they are \ncomposed of GUI elements such as text fields, combo \nboxes, list views and buttons. For each type of instruction \nthere exits an appropriate template that the programmer \nopens, sets specification data such as the name of a variable, \nits type and its initial value or the message to be printed on \nthe screen, and then, with just a button click, the proper \ninstruction would be generated. This automated approach \nrelieves programmers from hand-writing their source-code. \nIn that way, programmers don't have to bother themselves \nwith putting together expressions and arranging keywords \nand identifiers in the proper and correct order. They have \njust to follow the graphical templates to generate \ninstructions. More to the point, automation templates \nprovide a transparent layer that shields the programmer from \nthe sophisticated low-level inner structure of the syntax. In \nother words, programmers don't have to care anymore about \nmemorizing and learning terms and notations since \neverything is mimicked by the automation process. Besides, \nautomation \npromotes \nRAD \ndiscipline \nby \nspeeding \nProceedings of the World Congress on Engineering and Computer Science 2008\nWCECS 2008, October 22 - 24, 2008, San Francisco, USA\nISBN: 978-988-98671-0-2\nWCECS 2008\napplication development, and by focusing on building \napplications in a very short period of time. \nC.  NLG Engine \nThe NLG engine is considered a Template Filling NLG \nsystem type because it generates programming instructions \nin English natural language through filling variable slots in a \ntemplate primarily represented by a graphical template. \nMyProLang's NLG engine can be described as follows: \nGoal: Generator of natural source-code \nInput: GUI Templates populated with data by the \nprogrammer. \nOutput: Natural programming source-code. \nDomain: General-purpose computer programming. \n \nFig. 2 shows the MyProLang's NLG system with its major \ncomponents. \n \n \nFig. 2 - NLG System \n \nD.  Source-to-Source Compiler \nMyProLang's compiler is a source-to-source compile\nwhich converts specifications from templates into a high-\nlevel language mainly C#. For this reason another off-the\nshelf compiler is needed to do the conversion to lower level. \nMyProLang's source-to-source compiler is composed of a \nlexical analyzer, recursive-descent parser of context-free \ngrammar, a semantic analyzer and a code generator. At the \nbeginning it validates the data supplied into the templates \nagainst the predefined language rules e.g. if a variable being \ndeclared already exists or if an assignment is incompatible \nwith the variable data type or if an identifier contains illegal \ncharacters etc. Then it scans and parses several input fields \nto produce tokens and verify that no grammatical rules are \nviolated. For instance correctness of arithmetic expressions, \nrelevant arrangement of string concatenation operators and \nstructure of logical conditions are all examined at this stage. \nNext, it internally produces an equivalent intermediate \nlanguage representated in C#.NET 2.0. The NLG engine \nnow runs and generates the corresponding natural source-\ncode. This natural code is the only code visible to the \nprogrammer. The inner intermediate C# code produced \npreviously, is then send to a C# compiler whose job is to \nconvert the C# code generated by our source-to-source \ncompiler into MS .NET bytescode also called Microsoft \nIntermediate Language (MSIL) [11], [12]. Eventually they \nwill be transformed into an executable application by the \n.NET linker. Once completed, the produced executable file \ncan be run on top of any .NET 2.0 Common Language \nRuntime (CLR). Fig. 3 depicts the MyProLang process flow \ndiagram \nrepresenting \nthe \ndifferent \nstages and the \ncorresponding actions. \nr \n-\n \n \nFig. 3 - Process Flow \n \nTo make things clearer, a series of steps that show the \nflow of MyProLang processes, starting from opening a \ntemplate till the production of an executable program, are \nwritten \n \n1. Step 1: A Programmer opens a particular template with the \npurpose of generating a particular instruction. \n2. Step 2: The Programmer follows the template and fills-in \nthe required fields. \nStep 3: Once done, the programmer clicks on the generate \nbutton to generate the instruction, and finally dismiss the \ntemplate. \nStep 4: MyProLang's source-to-source compiler extracts the \npopulated data from GUI elements. It then scans, parses and \nwarns of any errors found. Finally, it generates, internally, \nan intermediate language represented in C#. \nStep 5: MyProLang's NLG engine then generates the natural \nsource-code represented in our proprietary language. The \noutput of the NLG engine is the only code visible to the \nprogrammer.  \nStep 6: When the programmer clicks on compile, in the \nmain IDE toolbar, he is in fact only calling the off-the-shelf \nC#.NET compiler which reads the C#.NET instructions \nproduced in step 4 from an internal buffer, and then \ngenerates .NET bytescode to eventually build the executable \napplication. \nE.  Integrated Development Environment \nMyProLang's IDE is the major container of all other \ncomponents. It is characterized by a friendly, ergonomic and \nintuitive programming interface. It is fully integrated with \nGUI items, automation templates and houses the source-to-\nsource compiler and the NLG engine. Besides, it features a \nset of tools that promote extensibility, storage and \nmultimedia such as saving source-code on local disk and \nprinting it. It also supports C# and Java translators, and a \nvoice assistant tool that helps pin point compilation errors. \n \nProceedings of the World Congress on Engineering and Computer Science 2008\nWCECS 2008, October 22 - 24, 2008, San Francisco, USA\nISBN: 978-988-98671-0-2\nWCECS 2008\n \nFig. 4 - Main panel of the IDE \n \nFig. 4 illustrates the main development environment and \ninterface of MyProLang. It is composed of two \nplaceholders, one for global variables generation, and the \nother for instructions generation, a toolbar along with a \nmenu bar that contains a set of functionalities such as \nsaving, printing and compiling, and a left panel that contains \na set of graphical icons used to launch templates, necessary \nto generate instructions. \n \n \nVI. IMPLEMENTATION AND TESTING \nMyProLang is implemented in MS C#.NET 2005 using \nMS Visual Studio 2005 under the MS .NET Framework 2.0, \nwith more than 20000 lines of code.  \nA demonstration of a sample test that exhibits how to \ngenerate a variable declaration is presented. The variable is \ncalled Radius, it is of type Number, and contains the value \n25. Fig. 5 shows the particular template for declaring a \nvariable. Fig. 6 shows the generated natural variable \ndeclaration instruction. Fig. 7 depicts a complete generated \nsource-code program for finding the average of three \nnumbers. \n \n \nFig. 5 - Automation template for generating a variable \ndeclaration \n \n \nFig. 6 - Natural source-code generated after dismissing the \ntemplate \n \n \nFig. 7 - Complete generated program for finding the average \nof three numbers \n \n \nVII. RESULTS \nThe MyProLang presented a distinctive approach to help \nease, simplify, familiarize, and automate the writing of \ncomputer programs. \nA proprietary natural programming language based on \nunsophisticated syntax and grammatical rules was presented. \nIn addition, to a programming environment that leverages \nthe concept of automatic programming through graphical \ntemplates and natural source-code generation. It is a \ncomplete \nframework \nfor \nproducing \ngeneral-purpose \ncomputer applications with just few mouse clicks. \nThe problem of syntax complexity and programming \nerrors were solved by designing a plain natural \nprogramming language, which is undemanding, and easy to \nlearn and use. It features a very expressive and familiar way \nto construct source-codes. \nAutomation \ntemplates \nautomated \nprogramming \nprocedures by substituting manual coding with the \nautomatic generation of source-code. Besides, it also \nshielded the programmer from arranging and putting words \ntogether to mold instructions. Hence, programmers have no \nneed to learn in depth and dig into the basic language \nspecifications, they have just to follow intuitive templates, \nand the rest is automatically handled, implicitly, by the \ncomputer. Additionally, it accelerated the development time \nand promoted RAD practice.   \n \n \nVIII. CONCLUSIONS \nMyProLang is an open programming language for all, \nincluding end-users, students, junior developers and expert \nprogrammers. Consequently, anyone can program and build \nprograms in a clear, familiar, systematic and rapid manner \nwithout dealing with ambiguous notations and bizarre \nsymbols, without spending time in learning rules and formal \nstructures, and without becoming frustrated by syntax errors \nand programming hazards. \nOn the long run, MyProLang would increase the \nproductivity, quality, and time-to-market in software \ndevelopment. \n \n \nIX. FUTURE WORK \nAs further research, programming key technologies are to \nbe added to the language such as classes, objects and other \nOOP features. Also a reusable set of built-in libraries \nbeneficial for accelerating the development time are to be \nProceedings of the World Congress on Engineering and Computer Science 2008\nWCECS 2008, October 22 - 24, 2008, San Francisco, USA\nISBN: 978-988-98671-0-2\nWCECS 2008\nprovided. Such libraries may include networking, file \nprocessing and database manipulation. \nFinally, and since the NLG engine is loosely-coupled with \nthe source-to-source compiler, the language is to be \ninternationalized by supporting more human languages such \nas French, German and Arabic. \n \nACKNOWLEDGEMENT \nWe thank Mrs. Henriette Skaff in the Department of \nLanguages and Translation at AUST for her help in editing \nthis article. \n \nREFERENCES \n[1] \nBrad A. Myers, Towards More Natural Functional Programming \nLanguages, \nICFP \ninternational \nconference \non \nfunctional \nprogramming, 2002. \n[2] \nBrad A. Myers, John F. Pane and Andy Ko, Programming \nlanguages and environments, Communications of the ACM \nSeptember, 2004. \n[3] \nMichael L. Scott, Programming Language Pragmatics, Second \nEdition, Morgan Kaufmann, 2005. \n[4] \nKenneth C. Louden, Compiler Construction, Principles and Practice, \nPWS, 1997. \n[5] \nDaniel Jurafsky and James Martin, Speech and Language \nProcessing, Prentice Hall, 2000. \n[6] \nEhud Reiter and Robert Dale, Building Natural Language \nGeneration Systems, Cambridge University Press, 1999. \n[7] \nJeffrey Hoffer, Mary Prescott and Fred McFadden, Modern \nDatabase Management, 7th edition, Prentice Hall, 2005. \n[8] \nJ.F. Pane and B.A. Myers, Usability Issues in the Design of Novice \nProgramming Systems, Carnegie Mellon University, Technical \nReport, 1996. \n[9] \nEisenberg, Resnick and Turbak, Understanding Procedures as \nObjects, Empirical Studies of Programmers: Second Workshop, \nNorwood, NJ, 1987. \n[10] \nMerrill, D.C. and B.J. Reiser, Scaffolding the Acquisition of \nComplex Skills with Reasoning-Congruent Learning Environments, \nProceedings of the Workshop in Graphical Representations, \nReasoning, and Communication from the World Conference on \nArtificial Intelligence in Education. Edinburgh, Scotland, 1993. \n[11] \nH. M. Deitel and P. J. Deitel, C# How to Program, 2nd edition, \nPrentice Hall, 1999. \n[12] \nAnders Hejlsberg and Scott Wiltamuth, C# Language Reference, \n2000. \n  \n \n \n \n \nProceedings of the World Congress on Engineering and Computer Science 2008\nWCECS 2008, October 22 - 24, 2008, San Francisco, USA\nISBN: 978-988-98671-0-2\nWCECS 2008\n",
  "categories": [
    "cs.PL"
  ],
  "published": "2012-04-01",
  "updated": "2012-04-01"
}