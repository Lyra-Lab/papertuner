{
  "id": "http://arxiv.org/abs/1301.1950v1",
  "title": "Syntactic Analysis Based on Morphological Characteristic Features of the Romanian Language",
  "authors": [
    "Bogdan Patrut"
  ],
  "abstract": "This paper refers to the syntactic analysis of phrases in Romanian, as an\nimportant process of natural language processing. We will suggest a real-time\nsolution, based on the idea of using some words or groups of words that\nindicate grammatical category; and some specific endings of some parts of\nsentence. Our idea is based on some characteristics of the Romanian language,\nwhere some prepositions, adverbs or some specific endings can provide a lot of\ninformation about the structure of a complex sentence. Such characteristics can\nbe found in other languages, too, such as French. Using a special grammar, we\ndeveloped a system (DIASEXP) that can perform a dialogue in natural language\nwith assertive and interogative sentences about a \"story\" (a set of sentences\ndescribing some events from the real life).",
  "text": "International Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\nDOI : 10.5121/ijnlc.2012.1401\n1\nSYNTACTIC ANALYSIS BASED ON MORPHOLOGICAL\nCHARACTERISTIC FEATURES OF THE ROMANIAN\nLANGUAGE\nBogdan Pătruţ1,2\n1Department of Mathematics and Informatics, Vasile Alecsandri University of Bacau,\nBacau, Romania\n2EduSoft Bacau, Romania\n1,2bogdan@edusoft.ro\nABSTRACT\nThis paper refers to the syntactic analysis of phrases in Romanian, as an important process of natural\nlanguage processing. We will suggest a real-time solution, based on the idea of using some words or\ngroups of words that indicate grammatical category; and some specific endings of some parts of sentence.\nOur idea is based on some characteristics of the Romanian language, where some prepositions, adverbs or\nsome specific endings can provide a lot of information about the structure of a complex sentence. Such\ncharacteristics can be found in other languages, too, such as French. Using a special grammar, we\ndeveloped a system (DIASEXP) that can perform a dialogue in natural language with assertive and\ninterogative sentences about a “story” (a set of sentences describing some events from the real life).\nKEYWORDS\nNatural Language Processing, Syntactic Analysis, Morphology, Grammar, Romanian Language\n1. INTRODUCTION\nBefore making a semantic analysis of natural language, we should define the lexicon and\nsyntactic rules of a formal grammar useful in generating simple sentences in the respective\nlanguage (for example, English, French, or Romanian).\nWe shall consider a simple grammar, having some rules for the lexicon, and some rules for the\ngrammatical categories. The rules for the lexicon will be of the type (1):\nG →W\n(1)\nwhere G is a grammatical category (or part of speech) and W is an word from a certain dictionary.\nThe other syntactic rules will be of the type (2):\nG1 →G2 G3\n(2)\nmeaning that the first grammatical category (G1) forms out of the concatenation of the other two\n(G2 and G3), from the right side of the arrow.\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n2\nOur simple grammar is presented in Figure 1. It contains only few Romanian words and the\nsyntax rules constitute a subset of the Romanian syntax rules:\nLexicon:\nDet\n→\norice\n(any)\nDet\n→\nfiecare\n(every)\nDet\n→\no\n(a, an (fem.))\nDet\n→\nun\n(a, an (masc.))\nPron\n→\nel\n(he)\nPron\n→\nea\n(she)\nN\n→\nbărbat\n(man)\nN\n→\nfemeie\n(woman)\nN\n→\npisică\n(cat)\nN\n→\nșoarece\n(mouse)\nV\n→\niubeşte\n(loves)\nV\n→\nurăşte\n(hates)\nA\n→\nfrumoasă\n(beautiful)\nA\n→\ndeşteaptă\n(smart (fem.))\nA\n→\ndeştept\n(smart (masc.))\nC\n→\nşi\n(and)\nC\n→\nsau\n(or)\nSyntax:\nS\n→\nNP VP\nNP\n→\nPron\nNP\n→\nN\nNP\n→\nDet N\nNP\n→\nNP AP\nAP\n→\nA\nAP\n→\nAP CP\nCA\n→\nC A\nVP\n→\nV VP\nVP\n→\nV NP\nFigure 1. Example of simple grammar for Romanian language\nIn Figure 1, we used these notations: S = sentence, NP = noun phrase, VP = verb phrase, N =\nnoun, Det = determiner (article), AP = adjectival phrase, A = adjective, C = conjunction, V = verb,\nCA = group made up of a conjunction and an adjective.\nThis grammar generates correct sentences in English, such as:\n•\nOrice femeie iubeşte. (Every woman loves.)\n•\nUn șoarece urăște o pisică. (A mouse hates a cat.)\n•\nFiecare bărbat deștept iubește o femeie frumoasă și deșteaptă. (Every smart man\nloves a beautiful and smart woman.)\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n3\nOn the other hand, this grammar rejects incorrect phrases, such as “orice iubește un bărbat” (“any\nloves a man”). The previously phrases contains words only from the chosen vocabulary.\nHowever, our grammar overgenerates, that is, it generates sentences that are grammatically\nincorrect, such as \"Ea frumoasă sau deșteaptă iubește\" (“She beautiful or smart loves”), “El\niubește el” (“He loves he”), and \"O bărbat iubește pisică\" (“An man loves cat”), even these\nphrases contain words from the selected lexicon.\nAlso, the grammar subgenerates, meaning that there are many sentences in Romanian that\ngrammar rejects, such as \"Orice femeie iubește sau urăște un bărbat\". This phrase is correct in\nRomanian, and contains words from the given dictionary. Also, the phrase \"niște câini urăsc o\npisică\" (\"some dogs hate a cat\"), although syntactically correct in Romanian, is not accepted\nbecause it contains words that have not been entered into our vocabulary.\nThe syntactic analysis or the parsing of a string of words may be seen as a process of searching\nfor a derivation tree. This may be achieved either starting from S and searching for a tree with the\nwords from the given phrase as leaves (top-down parsing) or starting from the words and\nsearching for a tree with the root S (bottom-up parsing). An algorithm of efficient parsing is based\non dynamic programming: each time that we analyze the phrase or the string of words, we store\nthe result so that we may not have to reanalyze it later. For example, as soon as we have\ndiscovered that a string of words is a NP, we may record the result in a data structure called chart.\nThe algorithms that perform this operation are called chart-parsers. The chart-parser algorithm\nuses a polynomial time and a polynomial space. In (Pătruţ & Boghian, 2010) we developed a\nchart-parser, based on the Cocke, Younger, and Kasami algorithm. We presented a Delphi\napplication that analyzes the lexicon and the syntax of a sentence in Romanian. We used a\nChomsky normal form (CNF) grammar (Chomsky, 1965).\n2. USING THE DEFINITE CLAUSE GRAMMARS\nIn order for our grammar not to generate incorrect sentences, we should use the notions of gender,\nnumber, case etc. specifying, for example, that \"femeie” and “frumoasă\" have the feminine\ngender, and the singular number. The string “El iubește ea” is incorrect, because “ea” is in\nnominative case, and we should use the “pe” preposition in order to obtain the accusative case.\nThe correct phrase is “El iubește pe ea”, or even“El o iubește pe ea.” (“He loves her”).\nIf we take into account the case, grammar is no longer independent from the context: it is not true\nthat any NP is equal to any other NP irrespective of the context. Nevertheless, if we want to work\nwith a grammar that is independent from the context, we may split the category NP into two, NPN\nand NPA, in order to represent verbal groups in the nominative (subjective), respectively\naccusative (objective) case. We shall also have to split the category Pron into two categories,\nPronN (including \"El\" and PronA (including \"pe ea\" (“her”), which contains the preposition “pe”\nin front of the pronoun “ea”) (Russel & Norvig, 2002)\nAnother issue concerns the agreement between the subject and main verb of the sentence\n(predicate). For example, if \"Eu\" (“I”) is the subject, then \"Eu iubesc\" (“I love”) is grammatically\ncorrect, whereas \"Eu iubește\" (“I loves”) is not. Then we shall have to split NPN and NPA into\nseveral alternatives in order to reach the agreement. As we identify more and more distinctions,\nwe eventually obtain an exponential number.\nA more efficient solution is to improve (\"augment\") the existing grammar rules by using\nparameters for non-terminal categories. The categories NP and Pron have parameters called\ngender, number and case. The rule for the NP has as arguments the variables gender, number and\ncase.\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n4\nThis formalism of improvement is called definite clause grammar (DCG) because each grammar\nrule may be interpreted as a definite clause in Horn’s logic (Pereira & Warren, 1980), (Giurca,\n1997).\nUsing adequate predicates, a CFG (context free grammar) rule as S →NP VP will be written in\nthe form of the definite clause NP(s1) VP(s2) => S(s1+s2), with the meaning that if s1 is NP, s2 is\nVP, then the concatenation of s1 with s2 is S. DCGs allow us to see parsing as a logical inference\n(Klein, 2005). The real benefit of the DCG approach is that we can improve the symbols of\ncategories with additional arguments, for example the rule NP(gender)→N(gender) turns into the\ndefinite clause N(gender, s1) ⇒NP(gender, s1), meaning that if s1 is a noun with the gender\ngender, then s1 is also a noun phrase with the same gender. Generally, we may supplement a\nsymbol of category with any number of arguments, and the arguments are parameters that\nconstitute the subject of unification like in the common inference of Horn’s clauses (Russel &\nNorvig, 2002).\nEven with the improvements brought by DCG, incorrect sentences may still be overgenerated. In\norder deal with the correct verbal groups in some situations, we shall have to split the category V\ninto two subcategories, one for the verbs with no object and one for the verbs with a single object,\nand so on. Thus, we shall have to specify which expressions (groups) may follow each verb, that\nis, realize a subcategorization of that verb by the list of objects. An object is a compulsory\nexpression that follows the verb within a verbal group.\nBecause there are a lot of problems in dealing with the syntactic analysis or a phrase, the time of\nthe processing the complex situations of the texts in Romanian language, describing real life\nsituations, we decided to use some morphological characteristic features of the Romanian words,\nthat can be useful in order to determine the parts of the sentences.\n2. THE IDEA FOR SYNTACTIC ANALYSIS BASED ON MORPHOLOGICAL\nCHARACTERISTIC FEATURES OF THE LANGUAGE\nAs we explain in the introduction, the classic ideas of syntactic analysis uses lexicons\n(dictionaries), CFG or DCG grammars and chart-parsers, as that developed by us in (Pătruţ &\nBoghian, 2010).\nIn the previous sections, we note the following:\n1.\nUsing a CFG grammar, syntactically correct sentences (in Romanian) are accepted, as\nwell as incorrect ones.\n2.\nThe power of the analysis system (for example a chart-parser), based on such a grammar\ndepends on the extent of the vocabulary used.\n3.\nThe power of a chart-parser can be improved using DCG grammars. This implies to\nextent the set of the syntactic rules, with a lot of new rules, using special variables (like\ngender, case, number etc.).\nAs concerns the first and the last issues, let us assume that the system will not be required to\nanalyze incorrect sentences, therefore we consider the grammar satisfactory. Regarding the\nsecond problem, it could be solved by strongly enriching the vocabulary, a fact that would require\nthe elaboration and implementing of some data structures and searching techniques as efficient as\npossible, which, however, will not function in real time, in some cases. Of course, the main\nproblem would be to write as comprehensive a grammar as possible, close to the linguistic\nrealities of Romanian morphology, taking into consideration the diversity of forms (and\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n5\nmeanings) that a sentence can get in the Romanian language. However, the extent and complexity\nof grammar leads to slowing the analysis, therefore this will not be done in real-time, in all cases.\nIn this section we will suggest a real-time solution, based on the idea of using:\n•\nsome words or groups of words that indicate grammatical category;\n•\nsome specific endings of the inflected words that indicate some parts of sentence.\nOur idea is based on some characteristics of the Romanian language, where some prepositions or\nsome specific endings can provide us a lot of information about the structure of a complex phrase.\nSuch characteristics can be found in other languages, too, such as French. Using our ideas, we\ndeveloped a system that uses a special grammar, which we will explain.\nThe morphology of the Romanian language allows the developing of a special syntactic analysis\nthat makes full use of certain characteristics of words when they are inflected (declined or\nconjugated) or under different hypostases.\nWith a view to \"understanding\" a Romanian sentence, to finding the constituent parts, which\nwould favor the translation of the sentence into another language, in real time, we suggest a\nsimple solution, based on patterns:\n•\nthere is a minimal vocabulary of key words: prefixes1, linking words, endings;\n•\na relatively limited grammar is realized in which the terminals are some words, either with\ngiven endings or from another given vocabulary;\n•\nthe user is asked to respect some restrictions of sentence word order (relatively a few);\n•\nthe user is assumed to be well meaning.\nIn Figure 2 it is presented the general scheme for such an analyzer (Pătruţ & Boghian, 2012).\nIn Figure 2, we select the concrete case of the sentence: \"Copii cei cuminţi au recitat o poezie\npărinţilor, în faţa şcolii.\" (\"The good children recited a poem to their parents, in front of the\nschool\").\nIn stage 2 predicate nouns and adjectives are identified (introduced by pronouns or prepositions),\ndirect or indirect objects, \"inarticulate\" (used without an article) (introduced by articles,\nprepositions and prepositional phrases respectively), adverbials; in stage 3 \"articled\" direct and\nindirect objects are identified etc.\nFollowing the logic of processes within the analyzer, we notice that the final result (that is correct\nin our case, up to an additional detailing) is approximate because the system is based on the\nobservations made by us, which are:\n•\nIn Romanian, the subject usually precedes the predicate: \"copiii\" (\"the children\") before \"au\nrecitat\" (\"recited\");\n•\nThere are some words (or groups of words) (that we call prefixes or indicators) that introduce\nadverbials (\"în faţa...\"( \"in front of\") = place adverbial; \"fiindcă...\" (\"because\"), \"din cauză\ncă...\" = cause adverbial; \"pentru a...\" (\"for\")= purpose adverbial;\n•\nThe predicate nouns, the adjectives and the objects (direct and indirect) can be introduced by\nindicating prefixes (\"lui...\" (Ion, Gheorghe etc.) (\"to...\") = indirect object (or predicate noun),\n1 by prefixes we understand words or groups of words, having the role to indicate the \"sense\" of the next\nwords from the phrase.\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n6\n\"o...\" (\"fată\" (\"girl\"), \"pisică\" (\"cat\") etc.) (\"a…\") = direct object, if these have not been\nalready identified as subject. Thus, it is to assume that we will say: \"un băiat citeşte o carte\"\n(\"a boy is reading a book\") and not \"o carte (e ceea ce) citeşte un băiat\" or \"o carte este citită\nde un băiat\" (\"a book (is that which) a boy is reading\" or \"a book is being read by a boy\"),\ntherefore the subject precedes the object);\n•\nSome endings offer sufficient information about the nature of the respective words (in the\nword ‘părinţilor’ the ending ‘-ilor’ indicates an indirect object2, just like ‘-ei’ from ‘fetei’,\n‘mamei’ indicates the same type of object, the ‘-ul’ from ‘băiatul’, ‘creionul’ indicate\nhowever a direct object (\"articled\").\nFigure 2. Stages of the analysis\nWe thus notice that our sentence, recognized by an analyzer of the type presented above is\n(structurally) complex enough as compared to the famous \"orice bărbat iubeşte o femeie\" (\"any\nman loves a woman\"), given as an example for classic chart-parsers.\nIt should also be noted that the sentence \"I o i pe M, deoarece M e f\" (\"J l M, because M i b\")\ncould be recognized by the analyzer on the basis of the pattern:\n•\n<subiect> <predicat> pe <complement direct>, deoarece <circumstanţial de cauză>.\n•\n(<subject> <predicate>[on] <direct object>because <cause adverbial>)\nThus, the above \"sentence\", although meaningless in Romanian, would enter the same category\nas: \"Ion o iubeşte pe Maria, deoarece Maria este frumoasă\" (\"John loves Mary because Mary is\nbeautiful\"), a category represented by the pattern mentioned above.\n2 Of course, “părinţilor” could be an indirect object as well as a predicative noun, like in the sentence \"the\ngood children recited the poems of their parents in front of the school\"/ \"copiii cei cuminţi au recitat\npoeziile părinţilor, în faţa şcolii\", therefore frequently not even grammar can solve the system’s\nambiguities.\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n7\n3. CREATING AND CONSULTING A DATABASE\nOf course, by introducing more such sentences (phrases), the user can create a table in a database\nwith the structure of a sentence; therefore each entry would contain the fields: subject, predicate,\npredicative noun, direct object, indirect object, place adverbial etc. The detailed structure of the\ntable is presented in section 5, when we will discuss about the DIASEXP shystem we developed.\nConsulting such a database would be made through Romanian interrogative sentences (phrases),\nfor example:\n•\nCine <predicat> <complement direct>\n? (\"Cine citeşte cartea ?\")\n(Who\n<predicate><direct object>? (\"Who is reading the book?\"))\nin order to find out the <subject>, using a search engine based on pattern-matching (matching\npatterns), in which the search clues would be the predicate (‘is reading’), and also the direct\nobject (‘book’).\nAlthough the results of the analysis (and by this the answers to the questions also) have a high\ndegree of precision that depends on respecting the word order restrictions imposed by the\nvocabulary taken into consideration, such a system that we have realised and that works in real\ntime can be successfully used. (Moreover, the system realised by us may enrich, through learning,\nits vocabulary so that, by using only the 300 initial words and endings it may cover a wide range\nof situations).\n4. A GENERATIVE GRAMMAR MODEL FOR SYNTACTIC ANALYSIS\nWe present below (Figure 3) the grammar used by our system in the syntactic analysis3:\n1.\nSentence\n→\nSubject Predicate Subject Predicate Other_part_of_sen\n2.\nOther_part_of_sent→\nPart_of_sentence Part_of_sentence Other_parts_of_sent\n3.\nPart_of_sentence\n→\nAdverbial Object\n4.\nSubject\n→\nSimple_subject Simple_subject Attrib_sub\n5.\nObject\n→\nDirect_object Indirect_object\n6.\nAdverbial\n→\nWhere When How Goal Why\n7.\nDirect_object\n→\nDir_obj Dir_obj Attrib_do\n8.\nIndirect_object\n→\nIndir_objIndir_obj Attrib_io\n9.\nAtrib_sub\n→\nAttribute\n10. Atrrib_do\n→\nAtrribute\n11. Atrrib_io\n→\nAtrribute\n12. Atrribute\n→\nAdjective Possesion_word Pref_attrib Words T \nPref_attrib Word Word + T_pos Word + ‘ând’ Words T\n13. Dir_obj\n→\nWord + T_do Pref_do Word\n14. Indir_obj\n→\nWord + T_io Pref_ci Word\n15. Where\n→\nAdv_where Pref_where Words T\n16. When\n→\nAdv_when Pref_when Words T\n17. How\n→\nAdv_howPref_how Words T\n18. Goal\n→\nPref_goal Words T\n19. Why\n→\nPref_why Words T\n20. Pref_attrib\n→\n‘al’ ‘a’ ‘ai’ ‘ale’ ‘cu’ ‘de’ ‘din’ \n‘cel’ ‘cea’ ‘cei’ ‘cele’ ‘ce’ ‘care’ ...\n21. Pref_do\n→\n‘pe’\n22. Pref_io\n→\n‘lui’ ‘de’ ‘despre’ ‘cu’ ‘cui’ ...\n23. Pref_where\n→\n‘la’ ‘în’ ‘din’ ‘de la’ ‘lângă’ ‘în spatele’ ‘în josul’\n3 the symbols from the grammar are written using Romanian\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n8\n‘spre’ ‘unde’ ‘aproape de’ ‘către’\n24. Pref_when\n→\n‘când’ ‘peste’ ‘pe’ ‘înainte de’ ‘după’ ...\n25. Pref_how\n→\n‘altfel decât’ ‘astfel ca’ ‘în felul ‘ ‘cum’ ‘ aşa ca’ ‘în modul’ ...\n26. Pref_goal\n→\n‘pentru’‘pentru ca să’‘în vederea’‘cu scopul’‘pentru ca’...\n27. Pref_why\n→\n‘căci’ ‘pentru că’ ‘deoarece’ ‘fiindcă’ ‘întrucât’ ...\n28. Adjective\n→\n‘mare’ ‘mic’ ‘bun’ ‘frumos’ ‘înalt’ ...\n29. Posession_word\n→\n‘meu’ ‘tău’ ‘lor’ ‘tuturor’ ‘nimănui’ ...\n30. Adv_where\n→\n‘aici’ ‘acolo’ ‘dincolo’ ‘oriunde’ ...\n31. Adv_when\n→\n‘acum’‘atunci’ ‘vara’‘iarna’ ‘luni’‘totdeauna’‘seara’...\n32. Adv_how\n→\n‘aşa’ ‘bine’ ‘frumos’ ‘oricum’ ‘greu’ ...\n33. T_pos\n→\n‘lui’ ‘ei’ ‘ilor’ ‘elor’\n34. T_do\n→\n‘a’ ‘ul’ ‘ele’ ‘ile’\n35. T_io\n→\n‘ei’ ‘ului’ ‘elor’ ‘ilor’\n36. T\n→\n‘,’ ‘.’\n37. Simple_subject\n→\nWords\n38. Predicate\n→\nWords | Forms_of_to_be\n39. Forms_of_to_be\n→\n‘este’ | ‘e’ | ‘sunt’  | ‘ești’…\n40. Direct_obj\n→\nWords\n41. Indir_obj\n→\nWords\n42. Adjective\n→\n‘mare’ ‘mic’ ’frumos’ ’roșu’…\n43. Adv_where\n→\n‘aici’ ‘acolo’ ’sus’ ’jos’…\n44. Adv_when\n→\n‘dimineața’ ‘miercuri’ ’iarna’ ’atunci’…\n45. Adv_how\n→\n‘așa’ ‘bine’ ’repede’ ’frumos’…\n46. Words\n→\nWord Words Words Words+’,‘ Words\n47. Word\n→\nCharacter | Word+Character\n48. Character\n→\n‘A’ ‘B’ ... ‘Z’ ‘a’ ... ‘z’ ‘0’ ‘1’ ... ‘9’ ‘-’ ...\nFigure 3. A grammar for Romanian, based on morphological characteristics\nIt is to be noted that the adverbs used are the \"general’ ones, and the adjectives are those most\nfrequently used in common speech. Also, please note that by \"+\" we noted the concatenation of\ntwo words: ‘fete’ + ‘lor’ = ‘fetelor’. This concatenation can be influenced, in some cases, by a\nphonemic alternance, like in “fată”+”ei”=”fetei”, where we have the phonemic alternance a→e\n(see (Pătruţ, 2010) for details).\n4. DIASEXP\nUsing the grammar from the previous section, we developed the DIASEXP system. DIASEXP\nhave a simple text interface, where the user can introduce different phrases describing some\nknowledge about some real life events. This collection of phrases is recorded as a “story”. Each\nphrase of the story is analyzed by the system, which will automatically detect the parts of the\nsentence and will add these into a table with the following fields:\n1.\nSubject – this will represent the simple subject of the sentence (a noun or a pronoun) (see\nrules 4 and 37 in Figure 3);\n2.\nAttrib_sub – this will be the attribute of the subject (it can be, for example an adjective,\nsee rules 9 and 12 in the same figure);\n3.\nPredicate – the predicate of the sentence will represent the main action of the assertive\nsentence; the predicate can be represented by a normal verb or the copulative verb “a fi”\n(“to be”), which will be folowed by a predicative noun (nume predicativ) - see rules 38\nand 39;\n4.\nDir_obj – the direct object or the predicative noun (see rules 7, 13, 21, and 34);\n5.\nAttribute_do – this will be the attribute of the direct object (see rules 7, 10, 12, and 28)\n6.\nIndir_obj – the indirect object (see rules 8, 14, 22, and 35)\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n9\n7.\nAttribute_io – this will be the attribute of the indirect object (the attributes will be\nrepresented by adejectives or by some prepositional phrases) – see rules 8,11,12, and 28;\n8.\nWhere – this will be the place adverbial; see rules 3, 6, 15, 23, and 30;\n9.\nWhen – this will be the time adverbial; see rules 3, 6, 16, 24, and 31;\n10. How – this will be the manner adverbial; see rules 3, 6, 17, 25, and 32;\n11. Goal – this will be the goal adverbial; it will be the answer at the question “Pentru ce…”\n(“For what…”); see rules 3, 6, 18, and 26;\n12. Why – this will be the cause adverbial; see rules 3, 6, 19, and 27.\nWhen DIASEXP isn’t sure about which part of the sentence a word is, it will ask the user with\ntwo or three variants, and the user will indicate the correct version. The next time, in a similar\nsituation, DIASEXP will know the answer, and it will not ask again. However, the use of commas\nwill be very helpful, in order to avoid the ambiguities.\nAfter entering some assertive sentences, the user can enter some interrogative sentences. When\nthe user will ask something DIASEXP, it will answer consulting the assertive sentences it known\nby that moment.\nBelow (Table 1) you can find an example of a “story”, from a dialogue between DIASEXP and a\nhuman user. The assertive sentences are prefixed by A, the interogative sentences are prefixed by\nI, and the DIASEXP’s answers are prefixed by R. In the right column the English translation is\npresented.\nTable 1. An example of a dialogue with DIASEXP (A=assertions, I=interogations, R=answers)\nA: Elena este frumoasa, deoarece are ochi frumosi.\nHelen is beautiful, because she has beautiful\neyes.\nA: Elena este frumoasă, deoarece are păr lung.\nHelen is beautiful, because she has long hair.\nA: Elena este frumoasă, căci e suplă.\nHelen is beautiful, as she is slim.\nA: Elena este placută, întrucât e sociabilă.\nHelen is enjoyable, as she is sociable.\nA: Elena e placută, deoarece e harnică.\nHelen\nis\nenjoyable, because she is hard-\nworking.\nA: Elena este sociabilă mereu.\nHelen is always sociable.\nA: Elena e prietenoasă cu oamenii inteligenți.\nHelen is amiable with intelligent people.\nA: Elena este prietena lui Adrian.\nHelen is Adrian’s girlfriend.\nA: Adrian o iubeste pe Elena, căci e frumoasă și\nharnică.\nAdrian loves Helen, because she is beautiful and\nhard-working.\nA: Adrian nu iubește altă fată.\nAdrian doesn’t love another girl.\nA: Adrian va dărui Elenei o floare mâine, deoarece\no iubește.\nAdrian will give Helen a flower tomorrow\nbecause he loves her.\nA: Elena va fi bucuroasă de floare.\nHelen will be happy about the flower.\nA: Părinții Elenei vorbesc despre Adrian.\nHelen’s parents talk about Adrian.\nA: Părinții Elenei îl vor invita pe Adrian la cină,\npoliticos.\nHelen’s parents will invite politely Adrian to\ndinner.\nA: Părinții Elenei îl plac pe Adrian, deoarece este\nbăiat bun.\nHelen’s parents like Adrian, because hs is a\ngood boy.\nA: Adrian este băiat bun, deoarece este student.\nAdrian is a good guy, because he is a student.\nA: Adrian, cel bun, este student la facultate, fiindcă\na învățat mult.\nAdrian, the good guy, is student in college,\nbecause he learned a lot.\nA: Adrian, studentul, este pasionat de informatică.\nAdrian, the student,\nis passionate about\ncomputer science.\nA: Adrian este student la informatică.\nAdrian is a student of computer science.\nA: Elena, cea frumoasă, este elevă silitoare la liceu.\nHelen, the beautiful one, is a sedulous student in\nhigh school.\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n10\nA: Elena va citi azi bine lecția de istorie, pentru ca\nsă ia notă mare.\nElena read good history lesson today, so she\nwants high grades.\nA: Elena iubește pe Adrian.\nElena loves Adrian.\nA: Elena iubeste pe părinții ei.\nA: Elena loves her parents.\nA: Elena s-ar căsători cu Adrian, fiindcă îl iubește.\nElena would marry Adrian because he loves.\nA: Adrian va pleca repede, astăzi la bunicii lui,\npentru ca să ii vadă.\nAdrian \nwill \ngo \nquickly, \ntoday, \nat \nhis\ngrandparents to see them.\nI: Cum este Elena?\nHow is Helen?\nR: Elena este frumoasă.\nElena este plăcută.\nElena este elevă.\nHelen is beautiful.\nHelen is enjoyable.\nHelen is a student.\nI: Pe cine iubeşte Adrian.\nWhom does Adrian love?\nR: Adrian iubeşte pe Elena.\nAdrian nu iubeşte altă fată.\nAdrian loves Helen.\nAdrian doesn’t love another girl.\nI: Unde va pleca Adrian?\nWhere will Adrian go?\nR: Adrian va pleca la bunicii lui?\nAdrian will go to his grandparents?\nI: Când va pleca Adrian la bunicii lui?\nWhen will Adrian go to his grandparents?\nR: Adrian va pleca astăzi la bunicii lui\nAdrian will go today to his grandparents.\nI: De ce este plăcută Elena?\nWhy is enjoyable Helen?\nR: Elena este plăcută întrucât e sociabilă.\nHelen is enjoyable because she is sociable.\nR: Elena este placută deoarece e harnică.\nHelen is enjoyable because she is hard-working.\nÎ: Cui va dărui Adrian?\nWhom will gives Adrian the book?\nR: Adrian va dărui Elenei.\nAdrian will give the book to Helen.\nI: Ce va dărui Adrian Elenei?\nWhat will give Adrian to Helen?\nR: Adrian va dărui Elenei o floare.\nAdrian will give a flower to Helen.\nThe “story” represented by the assertions from Figure 4 are stored in the table of the database like\nyou can see in Table 2. It is to be noted that the system correctly detected the parts of sentence,\nfor every assertions. In the table, the blank spaces correspond to those parts of sentence that are\nnot present in that phrase.\nTable 2. The table of the database, with the records of the story from Table 1\nSubject\nAttrib_sub\nPredicate\nDir_obj\nAttribute_d\no\nIndir_obj\nAttribute_io\nWhen\nWhere\nHow\nGoal\nWhy\nElena\neste\nfrumoasă\ndeoarece\nare \nochi\nfrumoși\nElena\neste\nfrumoasă\ndeoarece\nare \npăr\nlung\nElena\neste\nfrumoasă\ncăci \ne\nsuplă\nElena\neste\nplăcută\nîntrucât e\nsociabila\nElena\ne\nplăcută\ndeoarece\ne harnică\nElena\neste\nsociabilă\nmere\nu\nElena\neste\nprietenoa\nsă\ncu\noame\nInt\neli\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n11\nnii\nge\nnți\nElena\neste\nprietena\nlui\nAdria\nn\nAdria\nn\no\niubește\npe Elena\ncăci \ne\nfrumoasă\nși harnică\nAdria\nn\nnu\niubește\nfată\naltă\nAdria\nn\nva\ndărui\no floare\nElenei\nmâin\ne\ndeoarece\no iubește\nElena\nva fi\nbucuroas\nă\nde\nfloare\npărinț\nii\nElene\ni\nvorbes\nc\ndespre\nAdria\nn\npărinț\nii\nElene\ni\nîl vor\ninvita\npe\nAdrian\nla ei\npol\nitic\nos\npărinț\nii\nElene\ni\nîl plac\npe\nAdrian\ndeoarece\neste băiat\nbun\nAdria\nn\neste\nbăiat\nbun\ndeoarece\neste\nstudent\nAdria\nn\ncel\nbun\neste\nstudent\nla\nfacu\nltate\nfiindcă\na\nînvățat\nmult\nAdria\nn\nstude\nntul\neste\npasionat\nde\ninfor\nmatic\nă\nElena\ncea\nfrum\noasă\neste\nelevă\nsilitoa\nre\nla\nlice\nu\nElena\niubește\npe\nAdrian\nElena\niubește\npe\npărinții\nei\nElena\ns-ar\ncasator\ni\ncu\nAdria\nn\nfiindcă\nîl\niubeste\nAdria\nn\nva\npleca\nastăz\ni\nla\nbuni\ncii\nlui\nrep\nede\npentr\nu ca\nsa ii\nvada\nThe system was developed in Pascal programming language and was tested by our team on\ndifferent situations. In graph from Figure 3 you can see the results of analyzing 4 stories, after\nentering respectively 20, 50, 100, and 300 sentences. The average of good results is over 80%.\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n12\n0%\n20%\n40%\n60%\n80%\n100%\n120%\nStory 1\nStory 2\nStory 3\nStory 4\n20 sentences\n50 sentences\n100 sentences\n300 sentences\nFigure 3. Results of testing DIASEXP on different stories\n5. CONCLUSIONS\nCFG and DCG are types of generative grammars used in the syntactic analysis of a phrase in\nnatural language. Sometimes, long or complex phrases will be a problem for the classic chart-\nparsers. The characteristic features of the Romanian language related to the morphology of words\nor the way in which adverbials are formed can be successfully used in the syntactic analysis by\nusing a system based on patterns. This system will work in real-time and will not record the\nwhole dictionary of Romanian language. It will use a small dictionary of “prefixes” (prepositions,\nadverbs etc.), and some endings and linking words.\nACKNOWLEDGEMENTS\nThe authors would like to thank to professors Dan Cristea, Grigor Moldovan and Ioan Andone for\ntheir advices and observations during the research activities.\nREFERENCES\n[1]\nChomsky, N. (1965). Aspects of the Theory of Syntax. MIT Press, 1965. ISBN 0-262-53007-4\n[2]\nCristea, Dan (2003). Curs de Lingvistică computaţională, Faculty of Informatics, \"Alexandru Ioan\nCuza\" University of Iaşi, Romania.\n[3]\nGiurcă, Adrian (1997). Procesarea limbajului Natural. Analiza automată a frazei. Aplicaţii, University\nof Craiova, Faculty of Mathematics-Informatics, Romania.\n[4]\nKlein, \nE. \n(2005). \nContext \nFree \nGrammars. \nRetrieved \nfrom\nwww.inf.ed.ac.uk/teaching/courses/icl/lectures/2006/cfg-lec.pdf at 1st December 2012\n[5]\nPătruţ Bogdan (2010). “ADX — Agent for Morphologic Analysis of Lexical Entries in a Dictionary”.\nBRAIN. Broad Research in Artificial Intelligence and Neuroscience, vol. 1 (1), 2010, ISSN 2067-\n3957.\n[6]\nPătruţ, Bogdan & Boghian, Ioana (2012). Natural Language Processing: Syntactic Analysis, Lexical\nDisambiguation, Logical Formalisms, Discourse Theory, Bivalent Verbs, Germany, Munich: AVM –\nAkademische Verlagsgemeinschaft München, ISBN 978-3869242071.\n[7]\nPătruţ, Bogdan & Boghian, Ioana (2010). \"A Delphi Application for the Syntactic and Lexical\nAnalysis of a Phrase Using Cocke, Younger, and Kasami Algorithm\" in BRAIN: Broad Research in\nArtificial Intelligence and Neuroscience, Vol. 1, Issue 2, EduSoft: 2010.\n[8]\nPereira, F. & D. Warren (1986). “Definite clause grammars for language analysis”. Readings in\nnatural language processing, pp. 101-124, USA, San Francisco: Morgan Kaufmann Publishers Inc.,\nISBN:0-934613-11-7.\n[9]\nRussel, Stuart & Norvig, Peter (2002). Artificial Intelligence - A Modern Approach, 2nd International\nEdition, USA, Menlo Park: Addison Wesley.\nInternational Journal on Natural Language Computing (IJNLC) Vol. 1, No.4, December 2012\n13\nAuthor\nBogdan Pătruţ\nBogdan Pătruţ is associate professor in computer science at Vasile Alecsandri\nUniversity of Bacau, Romania, with a Ph D in computer science and a Ph D in\naccounting. His domains of interest/ research are natural language processing, multi-\nagent systems and computer science applied in social, economic and political sciences.\nHe published papers in international journals in these domains. Also, Dr. Pătruţ is the\nauthor or editor of more books on programming, algorithms, artificial intelligence,\ninteractive education, and social media.\n",
  "categories": [
    "cs.CL",
    "cs.AI",
    "68T50"
  ],
  "published": "2013-01-09",
  "updated": "2013-01-09"
}