{
  "id": "http://arxiv.org/abs/1406.4057v1",
  "title": "Embedded Controlled Languages",
  "authors": [
    "Aarne Ranta"
  ],
  "abstract": "Inspired by embedded programming languages, an embedded CNL (controlled\nnatural language) is a proper fragment of an entire natural language (its host\nlanguage), but it has a parser that recognizes the entire host language. This\nmakes it possible to process out-of-CNL input and give useful feedback to\nusers, instead of just reporting syntax errors. This extended abstract explains\nthe main concepts of embedded CNL implementation in GF (Grammatical Framework),\nwith examples from machine translation and some other ongoing work.",
  "text": "Embedded Controlled Languages\nAarne Ranta\nDepartment of Computer Science and Engineering\nChalmers University of Technology and University of Gothenburg\nAbstract. Inspired by embedded programming languages, an embedded CNL\n(controlled natural language) is a proper fragment of an entire natural language\n(its host language), but it has a parser that recognizes the entire host language.\nThis makes it possible to process out-of-CNL input and give useful feedback to\nusers, instead of just reporting syntax errors. This extended abstract explains the\nmain concepts of embedded CNL implementation in GF (Grammatical Frame-\nwork), with examples from machine translation and some other ongoing work.\nKeywords: controlled language, domain-speciﬁc language, embedded language,\nGrammatical Framework, machine translation\nPreprint version of paper presented at CNL 2014, Galway.\n1\nIntroduction\nA controlled natural language (CNL) is a strictly deﬁned fragment of a natural language\n[1]. As fragments of natural languages, CNLs are analogous to embedded domain-\nspeciﬁc languages, which are fragments of general purpose programming languages\n[2]. Such languages have been introduced as an alternative to traditional domain-speciﬁc\nlanguages (DSL), which have their own syntax and semantics, and require therefore a\nspeciﬁc learning effort. An embedded DSL is a part of a general-purpose programming\nlanguage, the host language, and is therefore readily usable by programmers who al-\nready know the host language. At its simplest, an embedded DSL is little more than a\nlibrary in the host language. Using the library helps programmers to write compact,\nefﬁcient, and correct code in the intended domain. But whenever the library does not\nprovide all functionalities wanted, the programmer can leave its straight-jacket and use\nthe host language directly, of course at her own risk.\nEmbedding a language fragment in the full language presupposes that a grammar\nof the full language is available. In the case of natural languages, this is by no means\na trivial matter. On the contrary, it is widely acknowledged that “all grammars leak”,\nwhich means that any formal grammar deﬁning a natural language is bound to be either\nincomplete or overgenerating. As a consequence, deﬁning CNLs formally as subsets of\nnatural languages looks problematic.\nHowever, if a grammar of the host language exists, then it is useful to deﬁne the\nCNL as an embedded language. It enables us to build systems that provide, at the same\ntime, the rigour of controlled languages and the comfort of graceful degradation. The\nuser of the system can be guided to stay inside the controlled language, but she will also\nbe understood, at least to some extent, if she goes outside it.\narXiv:1406.4057v1  [cs.CL]  16 Jun 2014\n2\nAarne Ranta\nIn this extended abstract, we will outline some recent work on building controlled\nlanguages in the embedded fashion. Our focus will be on multilingual systems, where\nthe CNL yields high-quality translation and the host language yields browsing quality.\nBut the same structure should be useful for other applications of CNLs as well, such as\nquery languages.\nIn Section 2, we will summarize how CNLs are traditionally deﬁned by using GF,\nGrammatical Framework. In Section 3, we will show how they can be converted to\nembedded CNLs. In Section 4, we summarize some on-going work and suggest some\nmore applications.\n2\nDeﬁning Controlled Languages in GF\nGF [3] is a grammar formalism based on a distinction between abstract syntax and\nconcrete syntax. The abstract syntax is a system of trees. The concrete syntax is a re-\nversible mapping from trees to strings and records, reminiscent of feature structures\nin uniﬁcation-based grammar formalisms. The separation between abstract and con-\ncrete syntax makes GF grammars multilingual, since one and the same abstract syntax\ncan be equipped with many concrete syntaxes. The abstract syntax is then usable as an\ninterlingua, which enables translation via parsing the source language string into a\ntree followed by the linearization of the tree into the target language.\nAs an example, consider a predicate expressing the age of a person. The abstract\nsyntax rule is\nfun aged : Person -> Numeral -> Fact\ndeﬁning a function with the name aged, whose type is a function type of two argu-\nments, of types Person and Numeral, yielding a value of type Fact. A simple concrete\nsyntax rule for English is\nlin aged p n = p ++ \"is\" ++ n ++ \"years old\"\nstating that a function application (aged p n) is linearized to the string where the\nlinearization of p is concatenated (++) with the string \"is\", the linearization of n, and\nthe string \"years old\". The corresponding rule for French is\nlin aged p n = p ++ \"a\" ++ n ++ \"ans\"\nproducing sentences literally equivalent to p has n years. Thus the concrete syntax\nallows the production of different syntactic structures in different languages, while the\nabstract syntax form (aged p n) remains the same, and stands in a compositional\nrelation to the linearizations.\nGF is widely used for deﬁning CNLs; [4,5,6,7,8] are some examples. Much of its\npower comes from the resource grammar libraries (RGL), which are general purpose\ngrammars enabling GF grammar writers to delegate the “low-level” linguistic details\nto generic library code [9,10]. If we dig deeper into the concrete syntax of the aged\npredicate, we will ﬁnd lots of such details to cope with: number agreement (one year\nEmbedded Controlled Languages\n3\nvs. ﬁve years), subject-verb agreement: (I am, you are, she is), word order (you are\nin declaratives vs. are you in questions), etc; French generally poses harder problems\nthan English. The use of feature structures instead of plain strings does make it possi-\nble to express all this compositionally in GF. But these details can make the grammar\nprohibitively difﬁcult to write, especially since controlled language designers are not\nalways theoretical linguists but experts in the various domains of application of CNLs.\nThe RGL addresses this problem by providing general-purpose functions such as\nmkCl : NP -> VP -> Cl\nwhich builds a clause (Cl) from a noun phrase (NP) and a verb phrase (VP) and takes\ncare of all details of agreement and word order. The CNL linearization rules can be\nwritten as combinations of such functions. The English rule, in full generality, comes\nout as compact as\nlin aged p n = mkCl p (mkVP (mkAP (mkNP n year_N) old_A))\nand the French,\nlin aged p n = mkCl p (mkVP avoir_V2 (mkNP n an_N))\nIf a function quest is added to turn facts into questions, the linearization is in both\nlanguages just a simple RGL function call:\nlin quest fact = mkQS fact\nThe API (application programmer’s interface) is the same for all languages in the RGL\n(currently 29), but the low-level details that it hides are language-dependent.\n3\nEmbedding a Controlled Language in the Host Language\nThe standard practice in GF is to deﬁne CNLs by using the RGL rather than low-level\nhand-crafted linearization rules. In addition to saving effort, this practice guarantees\nthat the CNL is a valid fragment of a natural language. The reason is that the RGL is\ndesigned only to allow grammatically correct constructions.\nBut what is missing in a CNL built in this way is the rest of the host language—\nthe part that is not covered by the RGL rule combinations actually used in the CNL.\nIn general, a random sentence has a probability close to zero to be recognized by the\nparser. The standard solution is to guide the user by a predictive editor [11,4,12]. But\nthere are many situations in which this does not work so well: for instance, with speech\ninput, or when processing text in batch mode. Then it can be more appropriate to include\nnot only the CNL but also the host language in the system. The system as a whole will\nthen be similar to an embedded DSL with its general-purpose host language.\nThe easiest way to combine a CNL with a host language is to introduce a new start\ncategory S with two productions: one using the CNL start category as its argument type,\nthe other using the host language start category:\n4\nAarne Ranta\nfun UseCNL\n: S_CNL\n-> S\nfun UseHost : S_Host -> S\nThe CNL trees can be given priority by biasing the weights of these functions in prob-\nabilistic GF parsing [13]. The CNL parse tree will then appear as the ﬁrst alternative,\nwhenever it can be found. Since the system sees where the tree comes from, it can give\nfeedback to the user, for instance by using colours: green colour for CNL trees, yellow\nfor host language trees, and red for unanalysed input, as shown (in greyscale in the\nprinted version) in Figure 1.\nSince the RGL is designed to guarantee grammaticality, and since all grammars\nleak, the RGL does not cover any language entirely. But if the purpose is wide-coverage\nparsing, we can relax this strictness. An easy way to do this is to extend the grammar\nwith chunking. A chunk can be built from almost any RGL category: sentences, noun\nphrases, nouns, adjectives, etc:\nfun ChunkS\n: S_Host -> Chunk\nfun ChunkNP : NP\n-> Chunk\nfun ChunkN\n: N\n-> Chunk\nThe top-level grammar has a production that recognizes lists of chunks ([Chunk]):\nfun UseChunks : [Chunk] -> S\nIt is relatively easy to make the chunking grammar robust, in the sense that it re-\nturns some analysis for any combination of words. If the input has out-of-dictionary\nwords, they can be dealt with by named entity recognition and morphological guessing.\nWeights can be set in such a way that longer chunks are favoured. For instance, this old\ncity should be analyzed as one NP chunk rather than a determiner chunk followed by an\nadjective chunk and a noun chunk. The user can be given feedback, not only by a red\ncolour indicating that chunks are used, but also by showing the chunk boundaries.\nA further step of integration between CNL and the host language is obtained if CNL\nsentences are treated as chunks:\nfun ChunkCNL : S_CNL -> Chunk\nIn the resulting trees, one can use different colours for different chunks inside one and\nthe same sentence.\nBut since both the CNL and the host language are deﬁned in terms of the same RGL\nstructures, one can take the integration much further, by intertwining the CNL and host\nlanguage rules. Consider again the CNL predicate\nfun aged : Person -> Numeral -> Fact\nwhere Person and Fact are CNL categories and Numeral is an RGL category. One\ncan generalize the use of this predicate and other ones by introducing coercions from\nRGL categories to CNL categories used as arguments, and from CNL categories used\nas values to RGL categories (making sure that no cycles are created):\nEmbedded Controlled Languages\n5\nfun np2person : NP -> Person\nfun fact2cl\n: Fact -> Cl\nThe effect of this is seen when we analyse the English sentence\nJohn does not believe that the queen is sixty-ﬁve years old\nThe resulting tree is\nmkS negativePol (mkCl John believe_VS (fact2Cl\n(aged (np2person (mkNP the_Det queen_N)) (mkNumeral \"65\"))))\nwhere those parts that belong to the CNL are boldfaced. Thus the predicate aged is\nfrom the CNL, but uses as argument the queen, which is not in the CNL. The resulting\nFact is used as a complement to the verb believe, which requires an RGL clause. The\nresulting French translation is\nJohn ne croit pas que la reine ait soixante-cinq ans\nwhich correctly renders the aged idiom deﬁned by the CNL, even though its subject\nis not in the CNL, and even though the negated main verb puts it into the subjunctive\nmood, which might never occur in the CNL itself.\nFig. 1. From left: CNL embedded in general purpose RGL embedded in a chunk grammar; the\ncorresponding levels in the Vauquois triangle; a mobile translation application showing the level\nof conﬁdence in colours (from top: semantic translation from CNL, syntactic translation from\nRGL, chunk-based translation).\n4\nWork in Progress\nThe translation example with the aged predicate shows that embedded CNL func-\ntions introduce semantic structures in translation. This has been exploited in the wide-\ncoverage GF-based translation system [14] 1 where three levels are distinguished by\n1 \"The Human Language Compiler\", http://grammaticalframework.org/demos/app.\nhtml\n6\nAarne Ranta\ncolours: green for the CNL (the MOLTO phrasebook [6]), yellow for the RGL syntax,\nand red for chunks (Figure 1). These levels correspond to levels in the Vauquois trian-\ngle, where translation systems are divided on the basis of whether they use a semantic\ninterlingua, syntactic transfer, or word-to-word transfer [15]. The effect of the layered\nstructure with an embedded CNL is that these levels coexist in one and the same system.\nThe system is currently implemented for 11 languages. Its architecture permits easily\nchanging the CNL to some other one and also including several CNLs in a single sys-\ntem. At least two experiments are in progress: one with a mathematical grammar library\n[5], another with the multilingual version of Attempto Controlled English [8].\nIn addition to translation, embedded CNLs could be used in query systems, where\n“green” parse trees are semantically well-formed queries and other colours are inter-\npreted as key phrases and key words. It can also be interesting to match out-of-CNL\ntrees with CNL trees and try to ﬁnd the closest semantically complete interpretations.\nYet another application of embedded CNLs would be to implement languages of the\n“Simpliﬁed English” type, which are not deﬁned by formal grammars but by restric-\ntions posed on the full language [1]. Such a language could be parsed by using the\nhost language grammar together with a procedure that checks on the tree level how the\nrestrictions are followed.\nAcknowledgement\nThanks to Krasimir Angelov and Normunds Gruzitis for useful comments. Swedish\nResearch Council (Vetenskapsrådet) has supported this work under grant nr. 2012-5746\n(Reliable Multilingual Digital Communication).\nReferences\n1. Kuhn, T.: A Survey and Classiﬁcation of Controlled Natural Languages. Computational\nLinguistics 40(1) (2014) 121–170\n2. Hudak, P.:\nBuilding domain-speciﬁc embedded languages.\nACM Computing Surveys\n(CSUR) 28(4es) (1996) 196\n3. Ranta, A.:\nGrammatical Framework: Programming with Multilingual Grammars.\nCSLI\nPublications, Stanford (2011)\n4. Ranta, A., Angelov, K.: Implementing Controlled Languages in GF. In: Proceedings of\nCNL-2009, Athens. Volume 5972 of LNCS. (2010) 82–101\n5. Saludes, J., Xambo, S.: The GF mathematics library. In: THedu’11. (2011)\n6. Ranta, A., Détrez, G., Enache, R.: Controlled language for everyday use: the molto phrase-\nbook. In: CNL 2012: Controlled Natural Language. Volume 7175 of LNCS/LNAI. (2012)\n7. Davis, B., Enache, R., Van Grondelle, J., Pretorius, L.: Multilingual Verbalisation of Modular\nOntologies using GF and lemon. In: Controlled Natural Language. Springer (2012) 167–184\n8. Kaljurand, K., Kuhn, T.: A multilingual semantic wiki based on Attempto Controlled English\nand Grammatical Framework. In: The Semantic Web: Semantics and Big Data. Springer\n(2013) 427–441\n9. Ranta, A.: The GF Resource Grammar Library. Linguistics in Language Technology 2\n(2009)\n10. Ranta, A.: Grammars as Software Libraries. In Bertot, Y., Huet, G., Lévy, J.J., Plotkin, G.,\neds.: From Semantics to Computer Science. Essays in Honour of Gilles Kahn, Cambridge\nUniversity Press (2009) 281–308\nEmbedded Controlled Languages\n7\n11. Khegai, J., Nordström, B., Ranta, A.:\nMultilingual Syntax Editing in GF.\nIn Gelbukh,\nA., ed.: Intelligent Text Processing and Computational Linguistics (CICLing-2003), Mexico\nCity, February 2003. Volume 2588 of LNCS., Springer-Verlag (2003) 453–464\n12. Kuhn, T.:\nCodeco: A Practical Notation for Controlled English Grammars in Predictive\nEditors. In: Controlled Natural Language (CNL), Springer (2012)\n13. Angelov, K., Ljunglöf, P.: Fast statistical parsing with parallel multiple context-free gram-\nmars. In: Proceedings of the 14th Conference of the European Chapter of the Association for\nComputational Linguistics, Gothenburg, Sweden, Association for Computational Linguistics\n(April 2014) 368–376\n14. Angelov, K., Bringert, B., Ranta, A.: Speech-enabled hybrid multilingual translation for mo-\nbile devices. In: Proceedings of the Demonstrations at the 14th Conference of the European\nChapter of the Association for Computational Linguistics, Gothenburg, Sweden, Association\nfor Computational Linguistics (April 2014) 41–44\n15. Vauquois, B.: A survey of formal grammars and algorithms for recognition and transforma-\ntion in mechanical translation. In: IFIP Congress (2). (1968) 1114–1122\n",
  "categories": [
    "cs.CL"
  ],
  "published": "2014-06-16",
  "updated": "2014-06-16"
}