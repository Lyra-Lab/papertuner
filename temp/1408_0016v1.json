{
  "id": "http://arxiv.org/abs/1408.0016v1",
  "title": "Architecture of a Web-based Predictive Editor for Controlled Natural Language Processing",
  "authors": [
    "Stephen Guy",
    "Rolf Schwitter"
  ],
  "abstract": "In this paper, we describe the architecture of a web-based predictive text\neditor being developed for the controlled natural language PENG$^{ASP)$. This\ncontrolled language can be used to write non-monotonic specifications that have\nthe same expressive power as Answer Set Programs. In order to support the\nwriting process of these specifications, the predictive text editor\ncommunicates asynchronously with the controlled natural language processor that\ngenerates lookahead categories and additional auxiliary information for the\nauthor of a specification text. The text editor can display multiple sets of\nlookahead categories simultaneously for different possible sentence\ncompletions, anaphoric expressions, and supports the addition of new content\nwords to the lexicon.",
  "text": "Architecture of a Web-based Predictive Editor\nfor Controlled Natural Language Processing\nStephen Guy and Rolf Schwitter\nDepartment of Computing\nMacquarie University\nSydney, 2109 NSW, Australia\n{Stephen.Guy|Rolf.Schwitter}@mq.edu.au\nAbstract. In this paper, we describe the architecture of a web-based\npredictive text editor being developed for the controlled natural language\nPENGASP . This controlled language can be used to write non-monotonic\nspeciﬁcations that have the same expressive power as Answer Set Pro-\ngrams. In order to support the writing process of these speciﬁcations, the\npredictive text editor communicates asynchronously with the controlled\nnatural language processor that generates lookahead categories and ad-\nditional auxiliary information for the author of a speciﬁcation text. The\ntext editor can display multiple sets of lookahead categories simultane-\nously for diﬀerent possible sentence completions, anaphoric expressions,\nand supports the addition of new content words to the lexicon.\nKeywords: controlled natural language processing, predictive editor,\nweb-based authoring tools, answer set programming\n1\nIntroduction\nWriting a speciﬁcation in a controlled natural language without any tool support\nis a diﬃcult task since the author needs to learn and remember the restrictions\nof the controlled language. Over the last decade, a number of diﬀerent tech-\nniques and tools [3,5,12,13] have been proposed and implemented to minimise\nthe learning eﬀort and to support the writing process of controlled natural lan-\nguages. The most promising approach to alleviate these habitability problems\nis the use of a predictive text editor [13,17] that constrains what the author\ncan write and provides predictive feedback that guides the writing process of\nthe author. In this paper, we present the architecture of a web-based predictive\ntext editor being developed for the controlled natural language PENGASP [15].\nThe text editor uses an event-driven Model-View-Controller based architecture\nto satisfy a number of user entry and display requirements. These requirements\ninclude the display of multiple sets of lookahead categories for diﬀerent sentence\ncompletions, the deletion of typed words, the addition of new content words to\nthe lexicon and the handling of anaphoric expressions. Additionally, the text\neditor displays a paraphrase for each input sentence and displays the evolving\nAnswer Set Program [11].\narXiv:1408.0016v1  [cs.CL]  27 Jun 2014\n2\nStephen Guy, Rolf Schwitter\n2\nOverview of the PENGASP System\n2.1\nClient-Server Architecture\nThe PENGASP system is based on a client-server architecture where the predic-\ntive editor runs in a web browser and communicates via an HTTP server with\nthe controlled natural language processor; the language processor uses in our\ncase an Answer Set Programming (ASP) tool as reasoning service (Fig. 1):\nFig. 1. Client-Server Architecture of the PENGASP System\nThe communication between the predictive editor and the HTTP server oc-\ncurs asynchronously with the help of AJAX technologies and by means of JSON1\nobjects. The predictive editor is implemented in JavaScript2 and JQuery3. The\nHTTP server as well as the controlled natural language processor are imple-\nmented in SWI Prolog4. The Prolog server translates JSON objects into JSON\nterms and vice versa so that these terms can be processed directly by the lan-\nguage processor. The language processor incrementally translates the controlled\nlanguage input via discourse representation structures [8] into an ASP program\nand sends this ASP program to the ASP tool clingo [6,7] that tries to generate\none or more satisﬁable answer sets for the program.\n2.2\nHTTP Server\nSWI-Prolog provides a series of libraries for implementing HTTP server capabil-\nities. Our server is based on this technology and can be operated as a stand-alone\nserver on all platforms that are supported by SWI-Prolog. The following code\nfragment illustrates how an HTTP server is created, a port (8085) speciﬁed, and\na request (Request) dispatched using a handler registration (http handler/3):\nserver(Port) :- http_server(http_dispatch, [port(Port)]).\n:- http_handler(’/peng/’, handle, []).\nhandle(Request) :- ...\n:- server(8085).\n1 http://json.org/\n2 http://www.ecmascript.org/\n3 http://jquery.com/\n4 http://www.swi-prolog.org/\nArchitecture of a Web-based Predictive Editor for CNL Processing\n3\nIn our case, we can now connect via http://localhost:8085/peng/ from\nthe web browser to the server that uses speciﬁc JavaScript and stylesheet han-\ndlers to load the predictive editor and to establish the communication between\nthe editor and the controlled language processor.\n2.3\nPredictive Editor\nThe predictive editor is implemented in JavaScript and JQuery, with the Super-\nﬁsh5 plug-in providing pull-down menu functionality. These technologies allow\nthe editor to be run in most browsers, which in conjunction with the capabilities\nof a potentially remote language processor coded in Prolog, provides a highly\nportable system. Data communication with the server provides for both com-\nmand functions, such as ﬁle saving and loading, as well as data transfer between\nthe language processor and the predictive editor system. The JSON data for\nparsing sent from the predictive editor to the HTTP server includes the current\ntoken of a word form, its position in the relevant sentence and relevant sentence\nnumber. For each word form or completed sentence submitted by the predictive\neditor, the lookahead categories and word forms along with the output of the\nlanguage processor are returned.\nAn overview of a typical predictive editor display is presented in Figure 2.\nCommand function menus are presented at the top, below which is the main\ntext input ﬁeld displaying the current sentence. Lookahead categories for the\navailable sentence completion are highlighted using the pull-down menus. Below\nthese lookahead categories is a display summarising relevant information in the\nsystem, at both the client and server. First is a summary of previously entered\ntext at the client side. Second are the generated paraphrases at the server, with\nany anaphoric references being highlighted (which may also be accessed from\nthe pull-down menus). Third is a summary of the current answer set program\nfor the input, followed by the ﬁnal section of output from answer set tool clingo.\nThe editor allows entering text speciﬁcations manually by typing in the text\nentry ﬁeld, plus using pull-down menus of lookahead categories to enter text\ninto the input ﬁeld. The reasons for allowing direct input of text include that\nsome users, especially those experienced in the structure of the controlled natural\nlanguage, can type faster than they can enter via menus, even with some level\nof auto-completion. Additionally, the system allows entering new content words\ninto the lexicon, via the text ﬁeld, that do not appear in the displayed lookahead\ncategories.\n3\nProcessing and Reasoning in the PENGASP System\n3.1\nControlled Natural Language Processor\nThe controlled natural language processor of the PENGASP system consists of\na chart parser, a uniﬁcation-based grammar, a lexicon and a spelling corrector.\n5 http://users.tpg.com.au/j_birch/plugins/superfish/\n4\nStephen Guy, Rolf Schwitter\nFig. 2. Predictive Editor Display\nThe chart parser is initialised for the ﬁrst time when the author moves the\ncursor into the textﬁeld of the predictive editor and reset at the beginning of\neach new sentence and generates lookahead categories using the grammar and\nthe lexicon of the controlled language processor. These lookahead categories\ninform the author of a speciﬁcation how to start a sentence and are generated\ndynamically for each word form that the author enters into the textﬁeld of the\neditor. This mechanism guarantees that the author can only input word forms\nand construct sentences that follow the rules of the controlled language. If a word\nis misspelled, then the spelling corrector is used to generate a list of candidates\nthat occur in the lexicon. If a content word is not in the lexicon, then the author\ncan add this word to the lexcion during the speciﬁcation process.\nThe controlled natural language PENGASP [15] that the author uses as input\nlanguage has been designed as a high-level interface language to ASP programs.\nIn certain aspects the language PENGASP is similar to PENG Light [18] and\nAttempto Controlled English [5], since it uses a version of discourse representa-\ntion theory (DRT), in the spirit of [2,8], as intermediate representation language.\nHowever, PENGASP does not rely on full ﬁrst-order logic (FOL) as target lan-\nArchitecture of a Web-based Predictive Editor for CNL Processing\n5\nguage as the use of DRT would suggest but on the language for ASP programs.\nThe language of FOL is in some respects more expressive than the language\nof ASP but unfortunately FOL is not adequate for representing commonsense\nknowledge, because FOL cannot deal with non-monotonic reasoning. ASP, on\nthe other hand, allows us to represent and process commonsense knowledge be-\ncause of its unique connectives and non-monotonic entailment relation. Beyond\nthat, ASP is still expressive enough to represent function-free FOL formulas of\nthe ∃∗∀∗preﬁx class in form of a logic program [10]. Below is an example speci-\nﬁcation in PENGASP that uses a default rule in (5), a cancellation axiom in (6),\nand sentence with strong negation in (7):\n1. Sam is a child.\n2. John is the father of Sam and Alice is the mother of Sam.\n3. Every father of a child is a parent of the child.\n4. Every mother of a child is a parent of the child.\n5. Parents of a child normally care about the child.\n6. If a parent of a child is provably absent then the parent abnormally cares\nabout the child.\n7. John does not care about Sam.\n8. Alice is absent.\nOf course, the speciﬁc features of the ASP language have an impact on what\nwe can express on the level of the controlled natural language and therefore rely\non the support of the predictive editor.\n3.2\nReasoning Service\nSince we are interested in specifying commonsense theories in PENGASP , we\nneed a non-monotonic reasoning service. ASP is a relatively novel logic-based\nknowledge representation formalism that has its roots in logic programming\nwith negation, deductive databases, non-monotonic reasoning and constraint\nsolving [1,7]. An ASP program consists of a set of rules of the following form:\nL0 ; ... ; Lk :- Lk+1, ..., Lm, not Lm+1, ..., not Ln.\nwhere all Li’s are literals. A literal is an atom or its negation. A positive atom\nhas the form p(t1, ..., tn) where p is a predicate symbol of arity n and t1,\n..., tn are object constants or variables. A negative atom has the form -p(t1,\n..., tn) where the symbol - denotes strong negation. The symbol :- stands\nfor an implication. The expression on the left-hand side of the implication is\ncalled the head of the rule and the expression on the right-hand side is called\nthe body of the rule. The head may consist of an epistemic disjunction of literals\ndenoted by the symbol ;. Literals in the body may be preceded by negation\nas failure denoted by the symbol not. The head or the body of a rule can be\nempty. A rule with an empty head is called an integrity constraint and a rule\nwith an empty body is called a fact. For instance, the example speciﬁcation in\nSection 3.1 is translated automatically via discourse representation structures in\nthe subsequent ASP program:\n6\nStephen Guy, Rolf Schwitter\nchild(sam).\nfather(john,sam).\nmother(alice,sam).\nparent(A,B) :- father(A,B), child(B).\nparent(C,D) :- mother(C,D), child(D).\ncare(E,F) :- parent(E,F), child(F), not ab(d_care(E,F)),\nnot -care(E,F).\nab(d_care(G,H)) :- parent(G,H), child(H), not -absent(G).\n-care(john,sam).\nabsent(alice).\n4\nPredictive Editor Requirements\nIn addition to the generic requirements outlined in Section 2.3, a number of\ndetailed user input and system display requirements for the lookahead categories\nare determined to aid in the design of the predictive editor architecture. The main\nrequirements are that the system should allow appropriate editing of information\nalready entered, that the lookahead categories for a particular sentence position\nare displayed until all possibilities are no longer possible and that the lookahead\ncategories for the next sentence position are displayed as soon as the relevant\noptions are possible. These requirements are presented in detail in the following\nsections.\n4.1\nUser and System Requirements\nUser Entry Requirements\nRequirement E.1.1: The system will allow deletion of characters or words\nalready typed, or all or part of a sentence not yet submitted. (This deletion\nwill be referred to as backward editing).\nRequirement E.2.1: A new sentence is not commenced (via the chart\nparser being reset) until a submit or an enter event or a beginning of sentence\ncharacter/word occurs after an end-of-sentence marker (full stop or question\nmark). A new sentence being commenced means that the previous sentence\nhas been submitted.\nRequirement E.3.1: A user is allowed to enter a content word not in the\nlexicon and force its submission to the language processor as the next content\nword.\nRequirement E.3.2: A user may enter a misspelt word that is yet to be\ncompleted with the word still subject to backward editing.\nRequirement E.4.1: A word is completed if it followed by a space or directly\nby a valid punctuation character which in turn is followed by a space or\nsentence submission. This latter requirement of a space after the punctuation\nallows the system to distinguish the state from the case of an incomplete\nmisspelt word with an erroneous punctuation character at the end.\nArchitecture of a Web-based Predictive Editor for CNL Processing\n7\nSystem Display Requirements\nRequirement D.1.1: Before and whilst a word is being entered at position\nA (or for a new sentence commencing at position A), the system should\ndisplay all the lookahead categories for position A until all of those categories\nare no longer possible.\nAssertion D.1.1: All lookahead categories for position A are no longer\npossible if the next non-punctuation word at position A+1 has commenced,\nor a word is completed according to Requirement E.4.1.\nRequirement D.2.1: The system should display the lookahead categories\nfor position A+1 when a word entered at position A matches the lookahead\ncategories for position A.\nNote that in terms of displaying one set of lookahead categories for a particu-\nlar word, requirements D.1.1 and D.2.1 are not mutually exclusive, that is there\noccur system states where the lookahead categories at position A and position\nA+1 need to be displayed concurrently.\nAssertion D.2.1: If a word at position A matches the lookahead categories\nfor position A, then other lookahead categories for position A may still be\npossible.\n4.2\nDisplay of Multiple Sentence Completions\nSome examples are presented to help clarify the requirements detailed above.\nThe two main cases which are catered for are the existence of subsets within the\nlookahead categories for one sentence position and the allowed juxtaposition of\npunctuation directly after a word without an intervening space.\nFor the case of subsets in lookahead categories, consider the commencement\nof a sentence and the above two display requirements D.1.1 and D.2.1. Initial\nlookahead categories may include “The”, “There is”, “A”, “Thelma”, “John”\nand “Johnathan” for example, which according to D.1.1 should all be displayed\nby the system. A user entering the characters “The” would then satisfy require-\nment D.2.1, whereby the lookahead categories for the next position would be\ndisplayed. If these categories included the word “child”, the user could enter this\nword and the entered text would be “The child”, illustrating that a display of\nthis sentence completion option was necessary. However, the original situation\nof the user entering the characters “The” may have been the precursor to the\nentry of the words “There is” or even “Thelma”. Thus even though requirement\nD.2.1 is satisﬁed after the entry of “The”, requirement D.1.1 still holds for the\npresentation of the original lookahead categories whilst the user completes this\nentry, thus illustrating assertion D.2.1. Whether the user has entered “Thelma”\nor “The” without a subsequent character, requirement E.4.1 has not been sat-\nisﬁed, so a user may backward edit from the word “Thelma” back to “The” or\n“Thelma”/“The” back to “A”.\n8\nStephen Guy, Rolf Schwitter\nFor the case of juxtaposition of word forms with punctuation and require-\nments E.4.1 and D.2.1, the lexicon and grammar allows phrases such as “John,\nThelma and Pete are parents.”. Here, a word is followed directly by punctuation,\nso that once the characters “John” are entered, according to requirement D.2.1,\nthe system must display the options for the next lookahead categories which\ninclude the comma which could be clicked or typed directly. Alternatively, a\nuser may have been intending to type “Johnathan”, so as for the case of subsets\nmust see the original set of lookahead categories. If a user accidentally hit the\ncomma on the ﬁfth character, leaving “John,” (John comma), as the current\nword, the system should still display the original lookahead categories, includ-\ning “Johnathan”, as the word has not been completed according to requirement\nE.4.1.\n5\nArchitecture of the Predictive Editor\nThe predictive editor is designed to meet the requirements of the PENGASP\nsystem, the asynchronous client-server communications, the diﬀerent modes of\nthe editor input as well as user entry and system display requirements.\n5.1\nModel-View-Controller Architecture\nThe architecture of the predictive editor is based approximately on that of a\nModel-View-Controller (MVC) system [4,16] in terms of separation and inde-\npendence.\nThe Model includes the currently active sentence, including that entered by\nthe user and that submitted to the HTTP server, all previously entered sen-\ntences and all data (including lookahead categories) received from the language\nprocessor via the HTTP server. The model also stores all variables relevant to\ndetermining the state of the system.\nThe View includes the events-triggered input text ﬁeld, the pull-down menu\ndisplay of lookahead categories and the input of word forms via mouseover selec-\ntion. It also displays the overall model of entered sentences and the ASP model\ngenerated by the language processor.\nThe Controller synchronises all functions, and importantly monitors for the\nneed of a state change in the Model, such as when the user has input data that\nis diﬀerent from the currently active sentence and if so, whether to submit new\ndata to the server or not. Additionally, the Controller co-ordinates loading of all\nthe returned lookahead categories into data structures and determines which of\nthese lookahead categories are displayed to the user as dependent on the current\nstate of the system.\n5.2\nEvent-Triggered Implementation\nA key issue with the implementation of the MVC architecture is the require-\nment to have event-driven data processing and control to be compatible with\nArchitecture of a Web-based Predictive Editor for CNL Processing\n9\nthe asynchronous AJAX communication between the predictive editor and the\nHTTP server and events-triggered predictive editor input. When content words\nare submitted to the HTTP server via JSON data, the predictive editor system\nmust wait until corresponding lookahead data is returned by the server.\nOnce this information is received, it may then be stored in the model and only\nthen can the Controller process this model data to determine if the model state\nvariables should be changed and update the display if necessary. To implement\nthis, the Controller organises run-time execution of events in a pipe and ﬁlter\narchitecture, where each element of the pipe is a data structure containing the\nrelevant primary data for that event, the relevant processing function and an\noptional link to the next data structure in the pipe.\nWhilst this may not be a classical MVC implementation, it provides a robust\nmethod of ensuring model data is in a consistent state for process control. Thus\nfor the above example of sending a new content word to the server, the AJAX\nsend/receive routine will trigger the return data storage event, which when com-\nplete will trigger the model state change assessment functionality, which when\ncomplete may cause a trigger of the display of the next lookahead categories to\nthe display.\nAny multi-stage data processing may also be organised as a pipe and ﬁlter\nstructure using the above data structures, with the next stage of the processing\nfunction only allowed once the model data from the previous processing function\nbecomes stable.\n5.3\nData Structures\nAs with many client-server systems, some model data is stored and processed at\nthe predictive editor client side to allow for optimal processing and control. The\nmodel data is stored in objects deﬁned by JavaScript functions, with appropriate\nobject methods declared to allow for this data to be processed conveniently and\nallowing functionality beyond the capabilities of using raw JSON objects for\nstorage. For example, the model data includes stack objects (containing stacks\nof anything from word forms to whole sentences), individual send and received\nobjects plus a single object of correlated send and receive data. Methods can\ndetect if a beginning or end of sentence token is present, or whether a word\nform matches a lookahead category and whether it is also a subset of another\nlookahead category (such as “The” being a subset of “There”). Display objects\nallow storage of diﬀerent sets of lookahead categories and the ability to switch\nthe display from ‘displayed’ to ‘hidden’ and vice versa.\n5.4\nPredictive Editor Controller\nGiven the user entry and system display requirements discussed Section 4.1\nand generic requirements presented in Section 2.3, the control system for the\npredictive editor has been designed to allow displaying of multiple lookahead\ncategories for diﬀerent sentence completions and strict control over when data\nentered by a user is ultimately committed to the server. The currently active\n10\nStephen Guy, Rolf Schwitter\nsentence is stored in two forms, namely from a tokenisation of the user input\nand from a summary of the data submitted to the server. By comparing a stack\nof the set of tokens in each sentence, a diﬀerence stack is generated to aid the\ncontroller in determining a change in the model state. Any newly entered valid\nwords, or changes in the current word are assessed for submission, or alternately\nearlier submitted tokens/words may be removed and new tokens sent in their\nplace (such as in the case of backward editing).\nAs discussed regarding requirement D.2.1 in Section 4.1, if an entered word\nmatches a lookahead category for that position, the controller automatically sub-\nmits this word to the server and retrieves the next set of lookahead categories for\nthis new token. However, this data transfer is just the predictive editor gather-\ning information and doesn’t directly synchronise with the totality of the display\nto the user. If the controller doesn’t detect a word completion, or ﬁnds that at\nleast one lookahead category from the previous word is still possible, the previous\nlookahead categories are not cleared as per assertion D.2.1.\nAs described in Section 5.3, display data structures allow easy addition and\ndisplay of data and hiding of data as necessary. As well as automatically sub-\nmitting a word matching the current lookahead categories, a word matching the\nprevious set of lookahead categories where the previous word is a subset of the\nnew word will also trigger an automatic submission of the token to the HTTP\nserver. This would be the case for “Thelma” being typed after “The” has been\nsubmitted to the server and lookahead categories already returned for the next\nsentence position.\n5.5\nAdding Content Words to the Lexicon\nRecall from requirement E.3.1 that a user may forcibly submit a word form\nto the language processor that does not correspond to the lexicon. When this\noccurs, the language processor may oﬀer a set of spelling suggestions (assuming\nthat an incorrect word has been submitted by mistake) or the predictive editor\nwill oﬀer an option to add this new word to the lexicon in this current context.\nIf the user selects to add a word, then the position in the sentence, the lexical\ncategory and the new word form are collected and sent to the server where the\nnew word is added to the lexicon. The new word is then parsed again by the\nlanguage processor and a new set of lookahead categories is generated and sent\nto the predictive editor.\n6\nFuture Research\nThe current predictive editor may be extended for multiple users in line with\nthe web-based portability of the system. A user login would allow for a number\nof features, such as a user-group based lexicon depending on the nature of the\nspeciﬁcation system for that group (e.g. medical, engineering, automotive, etc.).\nAdditionally, an individual could have their own extended lexicon for any content\nwords added to the lexicon. A user could set a level of knowledge for their\nArchitecture of a Web-based Predictive Editor for CNL Processing\n11\ngrammar, which would aid in controlling the complexity of the pull-down menus,\nin that instead of displaying all possible lexical categories, a user with limited\nknowledge could display a smaller number of less-technial word categories, such\nas “function words” instead of individual groups such as “adjective”, “adverb”,\n“noun”, etc. The user login could be used to set preferences for any further\nadjustable enhancements.\n7\nConclusion\nIn this paper, we introduced the architecture of a web-based predictive text ed-\nitor developed for the PENGASP system. This system is suitable for writing\nnon-monotonic speciﬁcations that have the expressive power of Answer Set Pro-\ngrams. The web-based predictive editor supports the writing process of these\nspeciﬁcations and is based on a portable client-server architecture and is pre-\ndominantly implemented in JavaScript. An event-driven Model-View-Controller\nbased architecture was used for the editor, allowing strict control of system func-\ntionality to satisfy a set of user entry and display requirements that included\nthe display of multiple sets of lookahead categories for diﬀerent sentence com-\npletions. The predictive editor allows for new content words to be added to the\nlexicon and supports the selection of anaphoric expressions An extension of a\nuser login would allow tailoring of preferences and a user-based lexicon.\nReferences\n1. Brewka, G., Eiter, T., Truszczy´nski, M.: Answer Set Programming at a Glance. In:\nCommunications of the ACM, Vol. 54, No. 12, December (2011)\n2. van Eijck, J., Kamp, H.: Discourse Representation in Context. In: J. van Benthem\nand A. ter Meulen (eds.), Handbook of Logic and Language, Second Edition, Elsevier,\npp. 181–252 (2011)\n3. Franconi, E., Guagliardo, P., Trevisan, M., Tessaris S.: Quelo: an ontology-driven\nquery interface. In: Proceedings of the 24th International Workshop on Description\nLogics (DL 2011), (2011)\n4. Freeman, E., Robson, E., Bates, B., Sierra, K.: Head First Design Patterns, O’Reilly,\npp. 526–577, (2004)\n5. Fuchs, N.E., Kaljurand, K., Kuhn, T.: Attempto Controlled English for Knowledge\nRepresentation. In: C. Baroglio, P.A. Bonatti, J. Maluszynski, M. Marchiori, A.\nPolleres, S. Schaﬀert, (eds.), Reasoning Web, Fourth International Summer School\n2008, LNCS 5224, pp. 104–124 (2008)\n6. Gebser, M., Kaminski, R., Kaufmann, B., Ostrowski, M., Schaub, T., Schneider, M.:\nPotassco: The Potsdam Answer Set Solving Collection. In: AI Communications, Vol.\n24, No. 2, pp. 105–124, (2011)\n7. Gebser, M., Kaminski, R., Kaufmann, B., Schaub, T.: Answer Set Solving in Prac-\ntice. In: Synthesis Lectures on Artiﬁcial Intelligence and Machine Learning, Vol. 6,\nNo. 3, pp. 1–238 (2012)\n8. Kamp, H., Reyle, U.: From Discourse to Logic. Kluwer, Dordrecht (1993)\n9. Kuhn, T., Schwitter, R.: Writing Support for Controlled Natural Languages. In:\nProceedings of ALTA, Tasmania, pp. 46–54, (2008)\n12\nStephen Guy, Rolf Schwitter\n10. Lierler, Y., Lifschitz, V.: Logic Programs vs. First-Order Formulas in Textual In-\nference. In: Proceedings of the 10th International Conference on Computational Se-\nmantics (IWCS 2013), Potsdam, Germany, pp. 340–346, (2013)\n11. Lifschitz, V.: What is Answer Set Programming? In: Proceedings of AAAI 2008,\npp. 1594–1597, (2008)\n12. Power, R.: OWL Simpliﬁed English: a ﬁnite-state language for ontology editing.\nIn: Kuhn, T. and Fuchs, N.E. (eds): Proceedings of CNL 2012, Springer, Heidelberg,\npp. 44–60, (2012)\n13. Schwitter, R., Ljungberg, A., Hood, D.: ECOLE: A Look-ahead Editor for a Con-\ntrolled Language. In: Proceedings of EAMT-CLAW03, Dublin, pp. 141–150, (2003)\n14. Schwitter, R.: Controlled Natural Languages for Knowledge Representation. In:\nProceedings of COLING 2010, Beijing, China, pp. 1113–1121, (2010)\n15. Schwitter, R.: The Jobs Puzzle: Taking on the Challenge via Controlled Natural\nLanguage Processing. In: Journal of Theory and Practice of Logic Programming,\nVol. 13, Special Issue 4-5, pp. 487–501 (2013)\n16. Sommerville, I.: In: Software Engineering, International Edition, Ninth Edition,\nPearson, pp. 155–164, (2011)\n17. Tennant, H.R., Ross, K.M., Saenz, R.M., Thompson, C.W., Miller, J. R.: Menu-\nbased natural language understanding. In: Proceedings of ACL, pp. 151–158, (1983)\n18. White, C., Schwitter, R.: An Update on PENG Light. In: L. Pizzato and R. Schwit-\nter (eds.), Proceedings of ALTA 2009, Sydney, Australia, pp. 80–88, (2009)\n",
  "categories": [
    "cs.CL",
    "cs.AI"
  ],
  "published": "2014-06-27",
  "updated": "2014-06-27"
}