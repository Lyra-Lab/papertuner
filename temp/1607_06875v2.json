{
  "id": "http://arxiv.org/abs/1607.06875v2",
  "title": "Processing Natural Language About Ongoing Actions",
  "authors": [
    "Steve Doubleday",
    "Sean Trott",
    "Jerome Feldman"
  ],
  "abstract": "Actions may not proceed as planned; they may be interrupted, resumed or\noverridden. This is a challenge to handle in a natural language understanding\nsystem. We describe extensions to an existing implementation for the control of\nautonomous systems by natural language, to enable such systems to handle\nincoming language requests regarding actions. Language Communication with\nAutonomous Systems (LCAS) has been extended with support for X-nets,\nparameterized executable schemas representing actions. X-nets enable the system\nto control actions at a desired level of granularity, while providing a\nmechanism for language requests to be processed asynchronously. Standard\nsemantics supported include requests to stop, continue, or override the\nexisting action. The specific domain demonstrated is the control of motion of a\nsimulated robot, but the approach is general, and could be applied to other\ndomains.",
  "text": "Processing Natural Language About Ongoing Actions\nSteve Doubleday, Sean Trott, Jerome Feldman\nAbstract— Actions may not proceed as planned; they may\nbe interrupted, resumed or overridden. This is a challenge\nto handle in a natural language understanding system. We\ndescribe extensions to an existing implementation for the control\nof autonomous systems by natural language, to enable such sys-\ntems to handle incoming language requests regarding actions.\nLanguage Communication with Autonomous Systems (LCAS)\nhas been extended with support for X-nets, parameterized\nexecutable schemas representing actions. X-nets enable the\nsystem to control actions at a desired level of granularity, while\nproviding a mechanism for language requests to be processed\nasynchronously. Standard semantics supported include requests\nto stop, continue, or override the existing action. The speciﬁc\ndomain demonstrated is the control of motion of a simulated\nrobot, but the approach is general, and could be applied to\nother domains.\nI. INTRODUCTION\nA challenge for natural language understanding systems\nthat interface with robots is responding to changes in the\nsituation. Actions may need to be interrupted, cancelled,\nstopped, resumed, or overridden. Underlying these responses\nare assumptions about the state of events. The temporal\nstructure of events is expressed in linguistic constructions\ntermed aspect [13]; an action can be about to start, or\nongoing, or just completed. An action that is interrupted or\nstopped is presumed to be ongoing; one that is cancelled is\npresumed not to have started yet.\nWe have extended an existing system, Language Commu-\nnication with Autonomous Systems (LCAS) [17], to enable\nit to handle language requests regarding the actions of sim-\nulated robotic agents. The extensions center around the use\nof X-nets [13], which implement parameterized executable\nschemas representing actions. An X-net is implemented as an\nextension to a Petri net [12]. The Petri net formalism is useful\nfor the description and analysis of concurrent processing\nin distributed systems. An X-net implements many of the\nstandard semantics we associate with action. Actions can\nbe enabled, started, ongoing, or done, which expresses the\nnormal execution path. Actions can also be suspended,\nresumed, or restarted, and handle exception conditions. In\naddition to having a shared standard action semantics, each\nX-net is tailored to meet the demands of a set of related tasks.\nIn this case, a Move X-net serves as an interface to drive the\nmotion of a simulated robot. Asynchronous communication\nlinks the language side of the system, handling new user\nrequests as they arrive, to the action side of the system, which\ndrives the motion of the simulated robot.\nII. X-NETS AND SIMULATION SEMANTICS\nThere is considerable evidence that language understand-\ning proceeds in part by simulating the actions implied by the\ntext [1], [2]. Actions and the simulation of actions can be\nmodeled by executable schemas parameterized by language\n[13], [14]. For example, verbs concerning motion can be\norganized in terms of an implicit ascending speed parameter:\n“crawl”, “amble”, “walk”, “run”, “dash”. Linguistic aspect\ninvolves the use of grammar to parameterize the state of\nactions in reference to a general event model. An action can\nbe impending, under way, or completed.\nAn executable schema can be implemented as an X-net,\na parameterized Petri net representation of an action. The\nPetri net formalism models distributed processing as a set\nof states and transitions among states, connected by directed\narcs. Transitions ﬁre when the pre-conditions deﬁned by their\ninput arcs are met, generating updates to the places connected\nto their output arcs. The pre- and post-conditions take the\nform of one or more tokens in a place. The vector of token\ncounts for all places in the Petri net constitutes its current\nstate, or marking. Figure 1 depicts a transition that will not\nﬁre; Figure 2 depicts an enabled transition before and after\nﬁring; after ﬁring the transition is disabled. In this case, ﬁring\nconsumes two tokens and creates one token.\nFig. 1.\nTransition not yet enabled, as all input places are not marked.\nX-nets deﬁne a standard action semantics, states and\ntransitions that are common to all actions. Depicted as an\nevent graph in Figure 3, this serves as a useful intermediate-\nlevel abstraction for the representation of actions [14], [6].\nScalar parameters can be passed to an X-net, enabling it\nFig. 2.\nWhen all input places are marked, transition is enabled and ﬁres,\nmarking the output place\n1\narXiv:1607.06875v2  [cs.AI]  30 Jul 2016\nFig. 3.\nEvent graph (controller) depicting the structure of events [14]\nto perform computations to modify its processing, e.g., to\nmove faster or slower. X-nets can also be composed of\nmore granular X-nets, where each X-net has some ability\nto perform error recovery locally, with escalation to higher\nlevels as needed.\nThese X-net capabilities enable a system to control ac-\ntions. They also enable a system to reason in a consistent\nway about actions. X-nets provide a natural way to model\nlinguistic aspect. By examining the current marking of an\nX-net, we can distinguish between actions that are about to\nbegin, or are ongoing, or just completed. X-nets can also\nsupport reasoning about events in general [15], including\nhypothetical or counter-factual language.\nIII. SYSTEM ARCHITECTURE\nA. System for Natural Language Understanding\nWe have implemented a system for natural language\nunderstanding [17], [11], [9]. The general architecture for\nthis system is depicted in Figure 4. Most of our previous\nwork has focused on extending the core system framework\nto the robotics domain, in applications such as Morse [7]\nand ROS [8], but the system was designed to facilitate sim-\nple re-targeting to new domains and applications. Ongoing\nwork includes applications such as real-time strategy games\n(StarCraft), metaphor analysis, and mental space modeling.\nFig. 4.\nSystem Architecture for natural language understanding.\nThe system is modular; at the highest level, it can be\ndivided into a language side and an action side. The language\nside, depicted on the left in Figure 4, receives speech or\ntext as input, and produces a structured representation of the\ntext’s meaning called an Action Speciﬁcation (ActSpec). This\nActSpec, which can describe a command, query, or assertion\nabout the world, is communicated as a JSON object to the\naction side of the system. The action side, depicted on the\nright in Figure 4, consists of a Problem Solver, a world\nmodel, and a Task API. The Problem Solver unpacks the\nActSpec to determine what task is to be accomplished and\nwith what parameters. The Problem Solver refers to the world\nmodel to determine the constraints on the possible solutions\nto the problems posed by the target task, and computes\na solution. Finally, the Problem Solver makes API calls\nto the underlying application, which constitute the actions\nnecessary to accomplish the target task. Communication\nbetween the language and action sides is enabled by shared\nActSpec templates, which guide ActSpec creation, and a\nshared ontology. The separation of the language and action\nsides allows them to be run on separate processes; thus,\nthe action-side can solve ActSpecs while the language-side\ncontinues to receive text and speech input.\nA crucial theoretical underpinning of the system design\nis previous work on mental simulation of language [2]. The\nlanguage side produces the parameters for the simulation of\nan event, which can then be simulated or executed by the\naction side.\nMore concretely, the ECG Analyzer [4], a cognitively\nplausible language parser, uses an Embodied Construction\nGrammar [1], [10] to produce a Semantic Speciﬁcation\n(SemSpec) of the events described in language. The Sem-\nSpec maps constructional information to the meaning of the\nsentence. Task-relevant information from the SemSpec is\nextracted by the Specializer and formatted into an ActSpec.\nThis ActSpec provides the parameters for the simulation of\nlanguage.\nIn the system described in [11], [17], the action side\nexecuted these incoming ActSpecs as they arrived. In the\ncurrent work, X-nets are introduced to provide additional\nmechanisms for simulation and control.\nB. Integration of X-nets\nThe architecture depicted in Figure 4 has been modiﬁed\nto have the Problem Solver execute one or more X-nets to\nrepresent the action being undertaken through the task API.\nThe Problem Solver examines the state of the X-net either\nduring or after execution to make inferences about progress\non the task. Integrating X-nets into the architecture enables\nthe system to deal with the following types of tasks, events,\nor requests:\n• suspension: “Robot1, stop moving!”\n• resumption: “Robot1, continue moving!”\n• interruption and redirection: while a move is in progress,\ne.g. “Robot1, move to the green box!”, a new target is\nspeciﬁed: “Robot1, move to the blue box!”\nFor the application of controlling a simulated robot, the\nProblem Solver invokes the Move X-net (Figure 5). The\n2\nMove X-net supports an additional parameterization, imple-\nmenting different speeds for different verbs: amble (slow),\nmove (normal), dash (fast).\nC. X-net Problem Solver\nThe incorporation of X-nets into the LCAS architecture\nallows a systematic decoupling of the language side and\naction side of the architecture, such that the user can interact\nwithout restriction with the system, often in response to\nthe current system behavior. The user can interrupt, cancel,\nresume, or restart the action, as appropriate, without being\nconstrained by blocking or synchronous control ﬂows. As is\nseen in both biological and mechanical action loops, there is\nsome inherent delay between a new request and the action\nresponse, but the asynchronous nature of Petri net execution\nenables this to be handled in a principled way, without resort\nto complex logic or ad hoc exception handling.\nTo support this decoupling, the execution of an X-net\nProblem Solver involves two threads, one that listens on a\nqueue for new incoming requests from the language side,\nand a second thread that interacts with the particular X-net\nappropriate to the task at hand. In turn, the X-net interacts\nwith the task API to accomplish the objective. For an ongoing\naction, a new incoming request will be translated by the\nProblem Solver into an update to one or more places in the\ncurrently executing X-net, which in turn will cause a change\nin the X-net ﬂow of control, corresponding to the meaning\nof the new request. Requests regarding actions that have not\nyet started or have completed may result in the invocation\nof a new X-net, or no change.\nD. Petri net Extensions to Support External Systems\nX-net support is built on PIPE V5, an open source Java\nPetri net editor and debugging environment1 [3], [5], [16].\nTo support the current work, PIPE was extended to provide\nsupport for interfaces to and from external systems, and for\nexecution through an API2. The extensions include:\n• External Transition: an extension to a Petri net tran-\nsition, providing a mechanism to execute Java code\nwhenever the transition ﬁres. The External Transition\nhas access to the state of the Petri net, and is option-\nally given a context passed from the external system,\nconsisting of an instance of an arbitrary Java class.\n• External Input Place: an extension to a Petri net place,\nproviding a mechanism for an external system to update\nthe marking of the place with one or more tokens.\n• External Output Place: an extension to a Petri net place,\nproviding a mechanism for an external system to be\nnotiﬁed whenever the marking of the place changes.\n• PNML extensions: extensions to the Petri Net Markup\nLanguage, which deﬁnes the speciﬁcation of a Petri\nnet in XML format, to support external transitions and\nplaces.\n1https://github.com/sarahtattersall/PIPE\n2Current code is here: https://github.com/sjdayday/PIPECore/tree/hierarchical-\nnets, and is documented here: https://github.com/sjdayday/PIPECore/wiki.\nAt some point, the extensions will be integrated as a release into PIPE V5\n• Merge Place: an extension to a Petri net place, enabling\na Petri net to be composed of multiple other Petri nets\nfor purposes of design and coding. Merge places serve\nto connect the various Petri nets together, and are then\ncollapsed to single places at execution time, creating a\nsingle executable Petri net.\n• Runner: the Runner interface enables an external system\nto interact with a Petri net. The interface supports the\nfollowing functions:\n– load a Petri net from a PNML ﬁle\n– start Petri net execution\n– mark a place in a Petri net\n– subscribe to notiﬁcations of a change in marking\nof a place in a Petri net\n– pass an object to be made available to a Petri net\ntransition when it ﬁres\n– subscribe to notiﬁcations of global Petri net events,\nincluding starting or stopping execution, and ﬁring\na transition\nE. Standard Action Semantics and the Move X-net\nFigure 5 shows the Move X-net, which controls the motion\nof a simulated robot. The upper portion of the X-net is an\nimplementation of a subset of the standard action semantics\ndepicted in Figure 3. Updating or reading places in this X-\nnet provides a simple, standard interface to many of the\noperations that we assume should be available in any action\n– starting, stopping, resuming or restarting an action.\nThe lower portion of the Move X-net depicts the logic\nspeciﬁc to controlling motion. This is a simpliﬁed interface\nthat defers speciﬁcs of trajectory planning to the Problem\nSolver and to the Morse simulator, but additional logic could\nbe added as needed for other domains, without affecting\nthe operation of the standard action semantics in the upper\nportion of the X-net.\nFig. 5.\nMove X-net\nF. X-net Interface to an External System\nThe mechanics of the interface between the LCAS system\nand the Petri net implementation of the Move X-net is\ndepicted in Figure 6. This serves as an example of the general\ninteraction between an X-net and any external system.\n3\nFig. 6.\nMove X-net interface to an external system\nFrom the perspective of the X-net, the external system here\nis the Problem Solver component of the LCAS system, which\ncontrols execution of the motion by populating some subset\nof the standard external input places: Enabled, Suspend,\nResume and Restart. The Problem Solver monitors progress\nof the motion by listening for updates to standard external\noutput places: Ready, Ongoing, Done, and Suspended. The\ninteraction with the task API, in this case the Morse simu-\nlator, happens through bi-directional updates to an instance\nof the task-speciﬁc MorseChannel Java class. These updates\nhappen during the external transitions: Move, SuspendT,\nResumeT, and RestartT. Each transition communicates an\nappropriate target operation, as well as the target position of\nthe simulated robot, from the perspective of the X-net. When\nany transition ﬁres, control passes from the X-net back to\nthe Problem Solver, which performs any appropriate pending\naction and updates the current position of the robot from the\nperspective of the Morse simulator, and then returns control\nback to the X-net. Finally, when the Morse simulator detects\nthat the simulated robot has arrived at the destination, it\nupdates the Arrived external output place to trigger transition\nof the Move X-net to the Done state.\nThe mechanics of the integration between the Python\nimplementation of LCAS and the Java implementation of\nthe Petri net is handled through the JPype Python package.\nJPype enables a Python script to start and attach a new JVM\nto the current Python thread, and then to create instances\nof Java classes. The methods and public ﬁelds of the Java\ninstances are then available for inspection and update by the\nscript through syntax that is consistent with Python. The ﬁrst\nProblem Solver script creates the JVM, and any subsequent\nProblem Solver instances use the same JVM. Each Problem\nSolver then creates an X-net as needed for its current task,\nusing the Runner API, and interacts with that X-net until its\ntask is completed.\nThe interaction between the Problem Solver and the X-\nnet can be conﬁgured to be effectively synchronous, such\nthat every state change in the X-net enables the Problem\nSolver to regain control. Depending on the task, however,\nthe Problem Solver may not need such granular control, and\nmay only register for asynchronous notiﬁcations. Regardless\nof the degree of coupling between the Problem Solver\nand the X-net, this does not alter the overall asynchronous\nrelationship between the language side and the action side\nin the LCAS architecture. The processing of requests from\nthe end user proceeds asynchronously from the combined\nactivity of the Problem Solver, X-net, and supporting task\nAPI. The standard action semantics provide natural support\nfor the interruption of ongoing action, the preemption of\npending action, or no operation when the action is already\ncomplete.\nIV. ROBOT MOTION EXAMPLE\nA. Normal Motion\nThe integration of the Problem Solver, Move X-net, and\nthe Morse simulator to accomplish motion of the simulated\nrobot, has been demonstrated in the context of various\nlanguage commands3. In response to the command “Robot1,\nmove to the blue box!”, the language side generates an\nActSpec to the action side, adding it to the queue of requests\nto be processed by the X-net Morse Problem Solver. The\nProblem Solver listens for each ﬁring event in an executing\nX-net, which gives it an opportunity to check the queue\nfor any new incoming requests. This ensures that latency\ninvolved in processing a new request is short. In this case, the\nincoming request causes a new instance of a PetriNetRunner\nto be created, which implements the Runner API. Next,\nan instance of the Move X-net is instantiated through the\nRunner API, and the Problem Solver subscribes for updates\nto the various external output places of interest in the X-net,\nprimarily those deﬁned in the standard action semantics. A\nnew instance of a MorseChannel is created, to act as a shared\ncontext for all of the External Transitions in the Move X-\nnet, and as the communication channel between the X-net\nand Morse. The Problem Solver updates the MorseChannel\nwith the location of the blue box, and the default speed. The\nProblem Solver requests that the Enabled place in the X-\nnet be updated with a single token, and then requests that\nthe X-net be run. The PetriNetRunner starts the execution\nof the Petri net, and notiﬁes the listening Problem Solver of\nevery event to which it has subscribed. As noted earlier, these\nnotiﬁcations include the ﬁring of every transition, so that any\nnew incoming language requests can be processed promptly.\nFlow of control passes through the Ready place and then\nthrough the Start transition, causing both the Ongoing and\nMoving places to be populated, as depicted in Figure 7.\nWhen the Move External Transition ﬁres, the Morse\nChannel is updated with the target operation of “move”.\nThe target location having been previously populated by the\nProblem Solver, control passes back to the Problem Solver,\nwhich passes the MorseChannel information to the Morse\nsimulator, which begins the simulated robot motion. Control\nthen returns to the X-net, which loops through the Moved\nplace and the Wait transition, before returning to Moving.\nThe Wait transition populates the Moving place. The\ntransition is designated as a timed transition, to wait a con-\n3Demonstration video: https://youtu.be/8PwHpng3Nj8\n4\nﬁgurable amount of time before ﬁring. Currently, however,\nthe transition ﬁres immediately, pending addition of the\nnecessary support to the underlying PIPE implementation.\nImplementation as a timed transition is intended as a per-\nformance optimization, to prevent the Moving / Moved loop\nfrom consuming system resources unproductively, and as a\nbetter model of the delays involved in physical motion.\nEach time the MorseChannel information is passed to\nMorse, Morse updates the current location of the robot; this\ninformation is currently unused by the X-net, but would be\navailable if more advanced functions were required. Finally,\nwhen the simulated robot reaches the target location, the\nMorseChannel is updated, and the Arrived place is marked,\ndriving the X-net through the Finish transition to the Done\nplace. The Problem Solver is notiﬁed that the X-net is Done,\nindicating normal completion of the motion.\nFig. 7.\nMotion in progress\nB. Processing Other Requests\nThe power of the standard action semantics is seen when\nthe system processes other incoming requests. Requests\nof very different syntactic form and meaning are handled\nwith little additional complexity. “Robot1, stop moving!”\ncauses the Problem Solver to populate the Suspend place.\nIf the X-net action is currently Ongoing, this causes the\nSuspendT External Transition to ﬁre. This transition updates\nthe MorseChannel target operation to be “suspend”, which in\nturn causes Morse to stop the motion of the robot simulator.\nThe transition’s ﬁring also updates the state of the X-net to\nSuspended, causing the Problem Solver to be notiﬁed that\nmotion has stopped.\nIn response to the request “Robot1, continue moving!”, the\nProblem Solver populates the Resume place. If the current\nstate of the X-net is Suspended, this drives the ResumeT\nExternal Transition, which updates the MorseChannel target\noperation to “resume”. This causes Morse to start the simu-\nlated robot moving again, resuming its trajectory toward the\ncurrent goal. Note that race conditions are handled simply;\nif the X-net is not in a Suspended state, the update of the\nResume place has no impact on processing; it is effectively\nignored.\nFinally, the more complicated case of interruption and re-\ndirection is also handled simply. The user might wish to\noverride a request that is in progress, e.g., “Robot1, move\nto the blue box!” The new request might be “Robot1, dash\nto the green box!” This new request causes the Problem\nSolver to calculate a trajectory towards the green box, and\nto update the MorseChannel both with the location of the\ngreen box, and with a higher speed value. As well, both the\nSuspend and Restart places are marked as in Figure 8. X-net\nexecution ﬁrst transitions to the Suspended state, as in the\n“stop moving!” example, causing Morse to stop motion of\nthe simulated robot. The population of both the Restart and\nthe Suspended places then drives the ﬁring of the RestartT\nExternal Transition, which updates the MorseChannel target\noperation to “restart”. This causes Morse to start the motion\nof the simulated robot again, following the new trajectory and\nspeed. The X-net ﬂow of control then passes back through\nthe Ready place and the Start transition, re-entering the\nOngoing state.\nFig. 8.\nMotion to be interrupted and re-directed\nC. Non-Linguistic Events\nIn addition to linguistic requests, a robot frequently en-\ncounters other events as it solves various tasks. Many of\nthese events involve changes to the environment, such as\na moving object suddenly crossing paths with the robot’s\ntrajectory, or encountering a previously unknown obstacle.\nEnvironmental interrupts are challenging because the robot\nmust dynamically adjust its world model to reﬂect these\nchanges, and then develop a new plan to continue solving\nthe original task.\nWe implemented a general protocol for how the Problem\nSolver should behave when experiencing world-based inter-\nrupts, and extended this to the Morse domain. In the Morse\ndemo [17], we addressed the problem of encountering objects\nthat were not previously in the Problem Solver’s world\nmodel. Novel objects could potentially disrupt the Problem\nSolver’s original plan for solving a task; for example, if the\nrobot is asked to a push a box north, it might ﬁnd that a\npreviously unknown box is in the way of its original path.\nOn the Morse side, our solution involved attaching a\nsimulated proximity sensor4 to the instance of the robot\nmodel. Whenever the robot passes within a certain threshold\nof distance from an object, the proximity sensor relays\n4http://www.openrobots.org/morse/doc/1.2/user/sensors/proximity.html\n5\ninformation back to the Problem Solver about the object’s\nlocation, color, and size. If the Problem Solver already knows\nabout the object, the world model is simply veriﬁed to make\nsure the object location is correct. If the object is unknown,\nhowever, the Problem Solver performs three functions, in\norder:\n1) The Problem Solver updates its world model with the\nnew information.\n2) The Problem Solver sends an ActSpec back to the UI-\nAgent, to notify the human user that a new object has\nbeen discovered.\n3) The Problem Solver develops a new plan for the\noriginal task, now taking into account the updated\nworld model.\nPrevious work also addressed the problem of disparate\nworld models among multiple agents [17]; in that case,\n(2) also involves sending notiﬁcation ActSpecs to the other\nrobots, so that they can also update their world models.\nV. CONCLUSION\nWe have demonstrated the ability to handle language\nrequests regarding the current state of actions in a graceful\nfashion, enabling actions to be interrupted, resumed and\noverridden. This is a useful advance in the natural lan-\nguage control of autonomous systems. The separation of\nlanguage inputs from the control of actions enables both\nto proceed asynchronously. This enables the overall system\nto be both responsive to new requests, while maintaining\ncontrol of actions at an appropriate level of granularity.\nAlthough demonstrated in the limited domain of movement\nof a simulated robot, the approach can be extended to other\ndomains in a straightforward manner.\nA. Limitations\nThere are several limitations of the system. Support in\nPIPE for external interfaces is limited to the API described\nearlier; interaction through a graphical interface is not yet\nsupported, but should be available in the near future. The\nstandard semantics of X-nets invites some programmatic\nsupport; this has been discussed5 but work has not yet begun.\nFinally, no effort has been made to optimize the system for\nperformance and scale.\nB. Future Work\nThe system supports current action. A next step is to have\nthe system support simulated action, where the execution of\nX-nets can be used to reason about the consequences of pos-\nsible future actions [15]. This would enable the evaluation of\ncounterfactual or hypothetical statements, such as “Robot1, if\nyou moved north of the green box, could you push it south?”\nFuture work could also examine the problem of integrating\nour work on non-linguistic events (see Section IV-C) with the\nmechanism for X-net control.\n5https://github.com/sjdayday/xschema/wiki\nACKNOWLEDGEMENTS\nWe thank Luca Gilardi for his help in designing the\nsystem framework, and for the creation of the GUI for the\nECG Workbench Editor. Professor William Knottenbelt and\nhis students at Imperial College, London, created and have\nmaintained PIPE through many releases. Sarah Tattersall\nperformed a thorough refactoring of the PIPE code base,\nwithout which the external system extensions would not have\nbeen possible.\nREFERENCES\n[1] Benjamin Bergen, Nancy Chang, and Shweta Narayan.\nSimulated\naction in an embodied construction grammar. In Proceedings of the\nTwenty-Sixth Annual Conference of the Cognitive Science Society,\npages 108–113, 2004.\n[2] Benjamin K Bergen. Louder than words: The new science of how the\nmind makes meaning. Basic Books, 2012.\n[3] Pere Bonet, Catalina M Llad´o, Ramon Puijaner, and William J\nKnottenbelt. PIPE v2. 5: A Petri net tool for performance modelling.\nIn Proc. 23rd Latin American Conference on Informatics (CLEI 2007),\n2007.\n[4] John Edward Bryant. Best-Fit Constructional Analysis. PhD thesis,\nUniversity of California at Berkeley, 2008.\n[5] Nicholas J Dingle, William J Knottenbelt, and Tamas Suto. PIPE2:\na tool for the performance evaluation of generalised stochastic Petri\nNets. ACM SIGMETRICS Performance Evaluation Review, 36(4):34–\n39, 2009.\n[6] Steve Doubleday.\nA Computational Model of Spatial Navigation\nDuring Simulated Motion in Rats. PhD thesis, 2017, forthcoming.\n[7] Gilberto Echeverria, Nicolas Lassabe, Arnaud Degroote, and Severin\nLemaignan. Modular Open Robots Simulation Engine: MORSE. 2011.\n[8] Manfred Eppe, Sean Trott, and Jerome Feldman.\nExploiting Deep\nSemantics and Compositionality of Natural Language for Human-\nRobot-Interaction.\nIn 2016 IEEE/RSJ International Conference on\nIntelligent Robots and Systems in Daejeon, Korea, 2016.\n[9] Manfred Eppe, Sean Trott, Vivek Raghuram, Jerome Feldman, and\nAdam Janin. Application-Independent and Integration-Friendly Natu-\nral Language Understanding. Submitted (under review).\n[10] Jerome Feldman, John Edward Bryant, and Ellen Dodge. A Neural\nTheory of Language and Embodied Construction Grammar. In The\nOxford Handbook of Computational Linguistics, pages 38 – 111.\nOxford University Press, 2009.\n[11] Huda Khayrallah, Sean Trott, and Jerome Feldman. Natural Language\nFor Human Robot Interaction. In International Conference on Human-\nRobot Interaction (HRI), 2015.\n[12] Tadao Murata.\nPetri nets: Properties, analysis and applications.\nProceedings of the IEEE, 77(4):541–580, 1989.\n[13] Srini Narayanan.\nKnowledge-based Action representations for\nmetaphor and aspect (KARMA). PhD thesis, University of California\nat Berkeley, 1997.\n[14] Srini Narayanan. Mind changes: A simulation semantics account of\ncounterfactuals. In Cognitive Science. 2010.\n[15] Steve Sinha. Answering Questions About Complex Events. PhD thesis,\n2008.\n[16] Sarah Tattersall and William Knottenbelt.\nPIPE–The Great Re-\nPlumbing. 2014.\n[17] Sean Trott, Aur´elien Appriou, Jerome Feldman, and Adam Janin.\nNatural Language Understanding and Communication for Multi-Agent\nSystems. In AAAI Fall Symposium, pages 137–141, 2015.\n6\n",
  "categories": [
    "cs.AI",
    "cs.CL",
    "cs.HC",
    "cs.RO"
  ],
  "published": "2016-07-23",
  "updated": "2016-07-30"
}