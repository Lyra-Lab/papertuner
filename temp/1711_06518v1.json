{
  "id": "http://arxiv.org/abs/1711.06518v1",
  "title": "Towards operational natural language",
  "authors": [
    "Alexandr Naumchev"
  ],
  "abstract": "The multiplicity of software projects' stakeholders and activities leads to\nthe multiplicity of software specification views and thus creates the need to\nestablish mutual consistency between them. The process of establishing such\nconsistency is error-prone and requires adequate tool support. The present\narticle introduces specogramming - an approach that treats a modern\nobject-oriented integrated development environment as a word processor. The\napproach turns the process of documenting initial specifications into a\nsimplified form of programming and turns structured-natural-language\nspecifications into runnable programs that yield multiple\nconsistent-by-construction views, one of which is structured natural language.",
  "text": "Towards operational natural language.\nAlexandr Naumcheva,b\naInnopolis University, Innopolis, Russian Federation\nbPaul Sabatier University, Toulouse, France\nAbstract\nThe multiplicity of software projects’ stakeholders and activities leads to the multi-\nplicity of software speciﬁcation views and thus creates the need to establish mutual\nconsistency between them. The process of establishing such consistency is error-prone\nand requires adequate tool support. The present article introduces specogramming – an\napproach that treats a modern object-oriented integrated development environment as\na word processor. The approach turns the process of documenting initial speciﬁcations\ninto a simpliﬁed form of programming and turns structured-natural-language speciﬁca-\ntions into runnable programs that yield multiple consistent-by-construction views, one\nof which is structured natural language.\nKeywords: continuous software engineering, specogramming, object-oriented\nprogramming, parameterized unit tests, speciﬁcation drivers, seamless requirements,\nseamless development\n1. Introduction\nThe multiplicity of speciﬁcation views leads to the following problems:\n1. The problem of producing the views and keeping them in sync.\n2. The precedence problem, when two views run out of sync.\n3. Reliance on potentially ambiguous structured natural language, when the views’\nprecedence is not clear.\nEmail address: a.naumchev@innopolis.ru (Alexandr Naumchev)\nPreprint submitted to Elsevier\nJune 1, 2021\narXiv:1711.06518v1  [cs.SE]  17 Nov 2017\nThe following development situation illustrates these problems. It also illustrates\nthe specogramming approach itself in the upcoming sections. Consider a quality as-\nsurance (QA) engineer who relies on a unit test view and a developer that relies on a\nstructured-natural-language view, such as user stories. When the QA engineer ﬁnds a\nbug, the QA vs. development conversation begins. The developer does not agree with\nthe unit test used to uncover the bug, which leads to discussing the original user story.\nExamination of the user story reveals that either the development or the QA engineer\nhas misunderstood the original requirement. The situation results in a waste of time,\nintellectual, and emotional energy.\nThe present article introduces specogramming – the process of speciﬁcations pro-\ngramming. A specogram is an object-oriented (OO) program that looks like structured\nnatural language. Specogramming treats integrated development environments (IDE’s)\nas word processors and natural-language texts as programs. Running a specogram re-\nsults in the generation of the necessary, consistent-by-construction, speciﬁcation views.\nSpecogramming solves the three problems above:\n1. The problem of keeping the views in sync.\nChanges happen only in specograms, which consistently propagate the changes\nto all the necessary views.\n2. The precedence problem, when two views run out of sync.\nSpecograms always have the highest precedence. Running the associated specogram\nwill remove the inconsistency.\n3. Reliance on potentially ambiguous structured natural language, when the views’\nprecedence is not clear.\nIn specogramming, a structured-natural-language view is a program. A stake-\nholder can run this program at any time and see what it means as applied to the\nviews concerning the stakeholder.\nSpecogramming reconsiders the features of OOP and the supporting IDE’s in the\nfollowing way:\n2\n• In a qualiﬁed call “target.call”, the “target” and the “call” represent two word\ncombinations that can follow, in this order, in a natural-language statement.\n• When a period symbol is entered, the IDE lists the features available on the target\nobject in accordance with its static type. This is a standard feature of the modern\nOO IDE’s. Specogramming treats the offered features as possible continuations\nof the speciﬁed phrase.\n• Specogramming treats classes as vocabularies. A vocabulary, when instantiated\nand queried, yields another vocabulary object. The new vocabulary object con-\ntains queries with names that are grammatically consistent with the name of the\nquery that yielded the object. The static typing of vocabularies guarantees the\ngrammatical consistency. Properly typed vocabularies guarantee that the com-\npiler will accept only grammatically correct, human-readable specograms.\nSpecogramming assumes continuous development of new operational vocabularies\nto keep up with the rapidly growing natural-language vocabularies used for specifying\nsoftware. A GitHub repository [1] contains several vocabularies and examples of their\nuse that should be sufﬁcient for developing the intuition behind the method. The project\nis currently being developed in Eiffel. Specogramming does not conceptually rely,\nhowever, on unique Eiffel’s traits, and applies to any statically typed OO language.\nThe article illustrates specogramming (Section 3) on a speciﬁc example (Section 2),\ndescribes the existing specogramming environment (Section 4), and concludes with an\noutline of the future work and recapitulates the method (Section 5).\n2. The gap between structured-natural-language and formal speciﬁcations.\nThe present section formulates questions that motivate the invention of the specogram-\nming approach. Consider the following natural-language requirement, further referred\nto as “requirement_1”: “a clock tick does not change the clock’s hour if, in the be-\nginning, the minute was smaller than 59”. A little bit more technical variant of this\nrequirement expects basic knowledge of the OO notation from readers: “a clock.tick\ndoes not change the clock.hour if, in the beginning, clock.minute <59”.\n3\nThe following parameterized unit test (PUT) [2] exercises a candidate implemen-\ntation of “requirement_1”:\ncheck_requirement_1 (c: CLOCK)\nrequire\nc.minute <59\ndo\nc.tick\nensure\nc.hour ~ old c.hour\nend\nCalling routine “check_requirement_1” with a speciﬁc CLOCK instance will test the im-\nplementation of the requirement if it meets the routine’s precondition. The inability\nof the call to meet the precondition denotes irrelevance of the test with respect to the\nrequirement, while the inability to pass the postcondition denotes a bug in the CLOCK\nimplementation. This approach to testing through calling OO representation of ADT\naxioms is known as parameterized unit testing [2].\nAdding a frame condition, such as “modify (clock)”, to the routine’s speciﬁcation\nmakes it usable as a driver for specifying the “tick” feature with a contract in the pres-\nence of a modular contract-based program prover [3]. The following contract provably\nmeets the “check_requirement_1” speciﬁcation driver, which may be certiﬁed with Auto-\nProof [4], the prover of Eiffel programs:\nclass CLOCK\ntick\ndo\nensure\nold minute <59 implies hour ~ old hour\nend\nend\nThe next task is to provide an implementation of “tick” that provably meets the\nspeciﬁed contract. Program proving also makes it possible to use veriﬁcation drivers for\nchecking contracts’ well-deﬁnedness [3]. Because of the PUT’s’/speciﬁcation drivers’\nveriﬁability, both dynamic and static, the article uses it as the formal speciﬁcation\nnotation to illustrate specogramming.\n4\nThe “check_requirement_1” PUT does not map to the original requirement, although\nit formally speciﬁes its meaning. Namely, grasping the PUT requires the following,\nadditional, knowledge of:\n• The Eiffel syntax.\n• The notion of contract.\n• The semantics of “does not change” as applied to contracts.\nWhile Eiffel treats contracts as ﬁrst-class citizens, other languages may not: .NET\ncontracts, for example, look like ordinary instructions inside the routine’s body, which\nfurther complicates grasping contracted .NET code.\nThese complications open the following questions. How to translate a structured-\nnatural-language requirement to a veriﬁable form, such as PUT’s, so that the translation\nprocess:\nQ1 Hides details of a speciﬁc programming language (PL)?\nQ2 Hides the underlying contracts?\nQ3 Hides the detailed semantics of intuitively clear natural-language phrases, such as\n“does not change”, “increment”, “decrement”, and many others?\nSpecogramming proposes a speciﬁc answer to these questions.\n3. Specogramming\nThe last modiﬁcation of “requirement_1” was: “a clock.tick does not change the\nclock.hour if, in the beginning, clock.minute <59”. Let us continue structuring it: “execu-\ntion_of \"clock.tick\" does_not_change \"clock.hour\" if_in_the_beginning \"clock.minute <59\"”.\nThis modiﬁcation uses the underscore symbol to connect the words related to the re-\nquirement’s structure, and quotes the domain-related terminology (the clock terminol-\nogy in the “requirement_1” example). The next iteration parenthesizes the problem\ndomain-related terminology, and puts the period symbol after each closing parenthesis:\n5\nrequirement (\"requirement_1\").states_that_execution_of (\"clock.tick\").\ndoes_not_change (\"clock.hour\").for (\"clock\").of_type ({CLOCK}).\nif_in_the_beginning (\"clock.minute <59\").period\nFigure 1: Application of specogramming to “requirement_1”\nexecution_of (\"clock.tick\").does_not_change (\"clock.hour\").\nif_in_the_beginning (\"clock.minute <59\")\nThis form reﬂects the main idea behind specogramming: it treats structured natural\nlanguage as object-oriented executable instructions.\nThe ﬁnal form of the requirement adds something else (Figure 1):\n• The “requirement (\"requirement_1\")” call that labels the requirement for traceability.\n• The “.for (\"clock\").of_type ({CLOCK})” call adds the typing information about the\n“clock” variable. The “{CLOCK}” expression just yields string \"CLOCK\" in Eiffel.\nThe advantage of this way of saying “CLOCK” is that the compiler checks if the\nclass exists or not.\n• The “.period” command call ﬁnalizes the whole instruction by yielding no object\non which otherwise it would be possible to do more calls.\nEach of the calls, except the “.period” call, yields an object. The static typing of these\ncalls is such that the compiler does not accept structurally invalid requirements. If\none forgets to add “.period” in the end, the compiler will remind that it is wrong to\nhave a function call as the last call: one must ﬁnalize the instruction with a command\ncall that yields nothing. The compiler cannot, however, rule out malformed inputs to\nthe calls. The calls rule out malformed inputs at runtime, through preconditions: an\nattempt to run the same instruction as in Figure 1 but with “\"requirement 1\"” instead of\n“\"requirement_1\"” will fail: the precondition of the “requirement ()” function requires its\ninput to be a well-formed identiﬁer.\n6\nCompiling and running the specogram that contains the instruction in Figure 1\nproduces the following output:\n• A LaTeX document with an entry that turns into the following text when com-\npiled to PDF:\nrequirement_1: Execution of clock.tick does not change clock.hour if, in the\nbeginning, clock.minute < 59.\nThe LaTeX entry resembles the original natural-language requirement with three\nparts (in italic) formalized.\n• A class with the following PUT:\ncheck_requirement_1\n-- execution of clock.tick does not change clock.hour\n-- if in the beginning clock.minute <59 :\n-- for any\n(clock: CLOCK)\n-- which\nrequire\n-- that\nclock.minute <59\ndo\n-- executing\nclock.tick\n-- will\nensure\n-- that\nclock.hour ~ old clock.hour\nend\nThe specogram instruction in Figure 1 produces a PUT that not only contains the\nrequired code but also enriches it with human-readable information.\nThe natural-\nlanguage comments, that start with “--”, make it possible to read the whole\n“check_requirement_1” routine from the beginning to the end, as a holistic phrase. This is\nseamless approach [5, 6, 7, 8, 9] that proposes to interweave the notations, not to switch\n7\nbetween them. Hereafter the article uses term seamless requirement [9] to denote such\nreadable-through routines, suitable for both software construction and veriﬁcation, both\ndynamic and static.\nThe following procedure describes the process software development with specogram-\nming as the software development methodology:\n1. Write a specogram in IDE.\n2. Compile the specogram and ﬁx compilation errors, if any.\na If a compilation error is caused by the inability of the compiler to recognize\nT in a “{T}” expression, declare the type.\n3. Run the resulting specogram.\n4. Compile seamless requirements resulting from the specogram at step 3.\n5. Repeatedly ﬁx compilation errors detected at step 4., if any.\na If an error talks about non-existing features or classes, create them.\nb Go to step 1. and ﬁx the specogram otherwise.\n6. Deploy a veriﬁcation infrastructure for checking the resulting seamless require-\nments.\na Call each of them with arguments that pass their preconditions, if you prac-\ntice testing [2].\nb Equip implementation classes with contracts that make the seamless re-\nquirements pass static veriﬁcation if you use a static program prover [3].\n7. Provide an implementation that passes the checks from the veriﬁcation infras-\ntructure deployed at step 6.\na Makes the calls from step 6.a. pass their respective seamless requirements’\npostconditions.\nb Is provably correct against the contracts speciﬁed at step 6.b.\n8\nThe implementation phase consists mainly of step 7., but it starts already at 2.a.: a\nsuccessful compilation of a specogram assumes the existence of all types it talks about.\nThen, the implementation phase continues at step 5.a.: execution of the specogram\n200\nturns a string expression of the form “target.call” into the actual call, and if the cor-\nresponding feature does not exist, the process requires to at least declare it. Step 5.b.\nassumes compilation errors caused by the initial specogram; non-declaration of a vari-\nable used in a specogram instruction is an example of such an error.\n4. Specogramming environment\nWhile the previous sections’ purpose was bringing the intuition behind specogram-\nming, the present section describes the specogramming environment.\nThe following example represents a complete specogram:\n1\nspecify_software\n2\ndo\n3\ncreate specification.further_referred_to_as (\"clock_speciﬁcation\")\n4\nrequirement (\"requirement_1\").states_that_execution_of (\"clock.tick\").\n5\ndoes_not_change (\"clock.hour\").for (\"clock\").of_type ({CLOCK}).\n6\nif_in_the_beginning (\"clock.minute <59\").period\n7\nspecification.writes_seamless requirements\n8\nspecification.writes_latex\n9\nend\n1. The instruction on line 3 instantiates a speciﬁcation object.\n2. The instruction spread across lines 4 to 6 adds a requirement object to the speci-\nﬁcation and speciﬁes the requirement through the chain of qualiﬁed calls.\n3. Line 7 writes the seamless requirements class. In this example, the class will\ncontain only one seamless requirement, “check_requirement_1” (Section 3).\n4. Line 8 writes the latex document. The document will contain only one record in\nthis case:\nrequirement_1: Execution of clock.tick does not change clock.hour if in the\nbeginning clock.minute < 59.\n9\nFigure 2: EiffelStudio as a specogramming environment.\nThe implementation of the “specify_software” routine is readable-through, from the\nbeginning to the end, as a natural-language text.\nA specogramming-based project may contain the following clusters (the rightmost\npane, “Groups”, in Figure 2):\nCore: contains implementations of the most important requirements engineering con-\ncepts - requirement, its hidden meaning, and speciﬁcation that consists of re-\nquirements. This cluster is supposed to be changed when it is necessary to im-\nplement another view or improve existing views’ generation.\nGenerated views: stores speciﬁcation views produced by specograms.\nVocabulary: contains the vocabulary classes used for specogramming. This cluster is\nsupposed to be modiﬁed every time a new meaningful vocabulary is found.\n5. Conclusions and future work\nThe idea of specogramming has a high potential. The current implementation of\nthe natural-language-like vocabulary performs straightforward generation of structured\n10\nspeciﬁcations with elementary input checks. Nothing prevents enriching the implemen-\ntation with advanced analysis of the requirements during specograms’ execution. It is\npossible, in fact, to extend the existing vocabulary for producing and analyzing not\nonly speciﬁcations but also implementations. In general, the vocabularies that look\nlike natural language may hide intelligence of unlimited complexity.\nSpecogramming has the following immediate beneﬁts to software speciﬁcation\npractices:\n• Taking advantage of the OOP features, such as qualiﬁed calls, static typing, and\ncommand-query separation, to guarantee requirements’ structural correctness.\n• Taking advantage of modern IDE’s’ intelligent features, such as listing the ser-\nvices offered by an object, to facilitate the speciﬁcation process.\n• Taking advantage of the compiler for ruling out both malformed specograms and\nseamless requirements that they produce.\n• Fixing a malformed view happens only in the original specogram, and rerunning\nit will propagate the ﬁx to each concerned view.\n• Wide applicability: all OO languages have qualiﬁed calls, the presence of which\nis the only assumption specogramming relies on.\nTo make the value of specogramming more evident, we need to do a considerable\namount of work:\n• Develop methodological recommendations for developing vocabularies; investi-\ngate how much this development may be automated.\n• Evaluate the approach on a meaningful example (such as Tokeneer [10]).\n• Enrich the existing vocabulary with as many meaningful expressions as possible.\n• Reﬁne the current design of the solution which may be suboptimal.\n• Possibly add traditional contracts to the current set of veriﬁable speciﬁcations\nproduced by specograms.\n11\nThe Specogram GitHub repository [1] includes several examples, including the\none used in the present article. Development of this project is happening inside this\nrepository.\nReferences\n[1] A.\nNaumchev,\nSpecogram,\na\ntool\nfor\nspeciﬁcations\nprogramming,\nhttps://github.com/anaumchev/specogram (2017).\n[2] N. Tillmann, W. Schulte, Parameterized unit tests, ACM SIGSOFT Software En-\ngineering Notes 30 (5) (2005) 253. doi:10.1145/1095430.1081749.\nURL http://portal.acm.org/citation.cfm?doid=1095430.1081749\n[3] A. Naumchev, B. Meyer, Complete Contracts through Speciﬁcation Drivers, in:\nProceedings - 10th International Symposium on Theoretical Aspects of Software\nEngineering, TASE 2016, 2016. doi:10.1109/TASE.2016.13.\n[4] J. Tschannen, C. A. Furia, M. Nordio, N. Polikarpova, AutoProof: Auto-active\nfunctional veriﬁcation of object-oriented programs, in: International Conference\non Tools and Algorithms for the Construction and Analysis of Systems, Springer,\n2015, pp. 566–580.\n[5] D. E. Knuth, Literate programming, The Computer Journal 27 (2) (1984) 97–111.\n[6] K. Waldén, J. M. Nerson, Seamless object-oriented software architecture,\nPrentice-Hall, 1995.\n[7] B. Meyer, Object-oriented Software Construction (2Nd Ed.), Prentice-Hall, Inc.,\nUpper Saddle River, NJ, USA, 1997.\n[8] B. Meyer, Multirequirements, in:\nN. Seyff, A. Koziolek (Eds.), Modelling\nand Quality in Requirements Engineering (Martin Glinz Festscrhift), MV Wis-\nsenschaft, 2013.\n[9] A. Naumchev, B. Meyer, Seamless requirements, Computer Languages, Systems\n& Structures 49 (2017) 119–132. doi:10.1016/j.cl.2017.04.001.\nURL http://linkinghub.elsevier.com/retrieve/pii/S1477842416301981\n12\n[10] J. Barnes, R. Chapman, R. Johnson, D. Cooper, B. Everett, Engineering the Toke-\nneer Enclave Protection Software, Proc. of the 1st IEEE International Symposium\non Secure Software Engineering (ISSSE) (March).\n13\n",
  "categories": [
    "cs.SE"
  ],
  "published": "2017-11-17",
  "updated": "2017-11-17"
}