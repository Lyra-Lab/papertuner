{
  "id": "http://arxiv.org/abs/1910.08518v1",
  "title": "Pumping lemmas for classes of languages generated by folding systems",
  "authors": [
    "Jorge C. Lucero"
  ],
  "abstract": "Geometric folding processes are ubiquitous in natural systems ranging from\nprotein biochemistry to patterns of insect wings and leaves. In a previous\nstudy, a folding operation between strings of formal languages was introduced\nas a model of such processes. The operation was then used to define a folding\nsystem (F-system) as a construct consisting of a core language, containing the\nstrings to be folded, and a folding procedure language, which defines how the\nfolding is done. This paper reviews main definitions associated with F-systems\nand next it determines necessary conditions for a language to belong to classes\ngenerated by such systems. The conditions are stated in the form of pumping\nlemmas and four classes are considered, in which the core and folding procedure\nlanguages are both regular, one of them is regular and the other context-free,\nor both are context-free. Full demonstrations of the lemmas are provided, and\nthe analysis is illustrated with examples.",
  "text": "arXiv:1910.08518v1  [cs.FL]  18 Oct 2019\nPumping lemmas for classes of languages generated by\nfolding systems\nJorge C. Lucero∗\nDecember 14, 2018\nAbstract\nGeometric folding processes are ubiquitous in natural systems ranging from pro-\ntein biochemistry to patterns of insect wings and leaves. In a previous study, a\nfolding operation between strings of formal languages was introduced as a model of\nsuch processes. The operation was then used to deﬁne a folding system (F-system)\nas a construct consisting of a core language, containing the strings to be folded,\nand a folding procedure language, which deﬁnes how the folding is done. This paper\nreviews main deﬁnitions associated with F-systems and next it determines necessary\nconditions for a language to belong to classes generated by such systems. The con-\nditions are stated in the form of pumping lemmas and four classes are considered,\nin which the core and folding procedure languages are both regular, one of them is\nregular and the other context-free, or both are context-free. Full demonstrations of\nthe lemmas are provided, and the analysis is illustrated with examples.\n1\nIntroduction\nIn a recent paper, Sburlan (2011) introduced a folding operation for strings of sym-\nbols of a given formal language. The operation was inspired in actual geometric folding\nprocesses that occur in, e.g., protein biochemistry (Dobson, 2003), in-vitro DNA shaping\n(Rothemund,\n2006),\nand\neven\norigami\n(the\nJapanese\nart\nof\npaper\nfolding;\nDemaine and O’Rourke, 2007), and it was proposed as a restricted computational model\nof such processes.\nThe folding operation was applied to deﬁne folding systems (F-systems) of the form\nΦ = (L1, L2), where L1 is the language that contains the strings to be folded (the core\nlanguage), and L2 is the language that contains strings deﬁning how the folding must be\nperformed (the folding procedure language). Then, the computing power of F-systems\nwas investigated by comparison with standard language classes from the Chomsky hier-\narchy; i.e., regular, context-free, context-sensitive, recursive and recursively enumerable\nlanguages.\nThe paper ﬁtted well within a growing body of applications of geometric folding to sci-\nence and technology which have surged in recent years; in, e.g., aerospace and automotive\ntechnology (Cipra, 2001), civil engineering (Filipov, Tachi, and Paulino, 2015), biology\n(Mahadevan and Rica, 2005), and robotics (Felton, Tolley, Demaine, Rus, and Wood,\n∗Dept. Computer Science, University of Brasília, Brazil. E-mail: lucero@unb.br\n1\nJ. C. Lucero: Pumping lemmas for F-systems\n2014). Also, a number of theoretical studies have considered algebraic models, algo-\nrithmic complexity, and other mathematical and computational aspects of folding(e.g.,\nAkitaya, Demaine, and Ku, 2017; Alperin, 2000; Ida, Fleuriot, and Ghourabi, 2016).\nF-systems might ﬁnd relevant applications to DNA computing and related areas\nof natural computing (Kari and Rozenberg, 2008).\nThus, the general purpose of the\npresent paper is to further explore capabilities and limitations of such systems, and it\nwill consider the classes of languages generated when the core and the folding procedure\nlanguages are regular or context-free. Necessary conditions for a language to belong to\nsome of those classes were presented by Sburlan (2011) in the form of pumping lem-\nmas, similar to the well known pumping lemmas for regular and context-free languages\n(Hopcroft, Motwani, and Ullman, 2001). His analysis considered the cases in which both\nthe core and the folding procedure language are regular, and in which the core language\nis context-free and the folding procedure language is regular. Here, the two cases will\nbe revised, in order to solve detected inconsistencies (see footnote 2 to Lemma 1). The\nlemmas will be restated in a weaker form (as consequence of the revision) and full proofs\nwill be provided. Also, it will be shown that the same lemma for the case in which the\ncore language is context-free and the folding procedures language is regular also applies\nto the case in which the class attribution is reversed. Finally, a lemma for the remaining\ncase in which both the core and the folding procedure languages are context-free will be\npresented and proved.\n2\nFolding systems\nFor clarity of the analysis, let us review main deﬁnitions associated to folding operations\nand systems.\nLet Σ be an alphabet, Γ = {u, d}, and f : Σ∗× Σ × Γ →Σ∗a function such that\nf(w, a, b) =\n(\naw,\nif b = u,\nwa,\nif b = d.\n(1)\nThen, the folding function h : Σ∗× Γ∗→Σ∗is a partial function deﬁned by\nh(w, v) =\n\n\n\n\n\nf(f(. . . f(ε, a1, b1) . . . , ak−1, bk−1), ak, bk),\nif |w| = |v| > 0\nε,\nif |w| = |v| = 0,\nundeﬁned,\nif |w| ̸= |v|.\n(2)\nwhere w = a1a2 . . . ak, v = b1b2 . . . bk, ai ∈Σ and bi ∈Γ for i = 1, 2, · · · , k, and ε is the\nempty string.1\nExample 1. Let w = abcde and v = dduud. Then,\nh(w, v) = f(f(f(f(f(ε, a, d), b, d), c, u), d, u), e, d),\n= f(f(f(f(a, b, d), c, u), d, u), e, d),\n= f(f(f(ab, c, u), d, u), e, d),\n= f(f(cab, d, u), e, d),\n= f(dcab, e, d),\n= dcabe.\n1Sburlan’s (2011) original deﬁnition has been modiﬁed in order to include the case in which both w\nand v are empty strings.\n2\nJ. C. Lucero: Pumping lemmas for F-systems\nεabcde\nedcba\nStep 1: fold down\nε\nedcba\nbcde\nStep 2: fold down\nedc\nε\na\nbcde\nStep 3: fold up\nde\nedc\nε\na\nb\nStep 4: fold up\nde\nc\nε\na\nb\ne\nStep 5: fold down\nd\nc\nε\na\nb\ne\nFinal result\nFigure 1: Computation of h(abcde, dduud) = dcabe as a sequence of folding operations.\nd c a b c d e\nd d u u d\nFigure 2: Computation of h(abcde, dduud) = dcabe using Eq. (3).\nThe computation of h(w, v) is represented graphically in Fig. 1. As shown there,\neach application of function f may be regarded as a folding operation that arranges the\nsymbols of w in a stack. Strings over Γ describe how each folding must be performed,\nwhere symbol u represents a “folding up” action and symbol d represents a “folding\ndown” action. The ﬁnal result is the created stack, read from top to bottom.\nAnother way to see the folding operation is illustrated in Fig. 2. The folded string\nmay be written as\nh(w, v) = wR\nu wd,\n(3)\nwhere wu is the sequence of symbols in w that are folded up, R denotes the reverse order\noperator, and wd is the sequence of symbols in w that are folded down. Letting w = xy,\nv = st, with |x| = |s| and |y| = |t|, we obtain the identity\nh(xy, st) = yR\nu h(x, s)yd.\n(4)\nA folding system (F-system) is deﬁned as a pair Φ = (L1, L2), where L1 ⊆Σ∗is the\ncore language, and L2 ⊆Γ∗is the folding procedure language. The language of Φ is\nL(Φ) = {h(w, v)|w ∈L1, v ∈L2, |w| = |v|}.\n(5)\nThe class of all languages generated by F-systems with core languages of a class C\nand folding procedure languages of a class H is deﬁned as\nF(C, H) = {L(Φ)|Φ = (L1, L2), L1 ∈C, L2 ∈H}.\n(6)\n3\nJ. C. Lucero: Pumping lemmas for F-systems\n3\nPumping lemmas\nThe ﬁrst lemma states necessary conditions for a language to belong to class\nF(REG, REG), where REG is the class of regular languages.\nLemma 1. Let L ∈F(REG, REG) be an inﬁnite language over an alphabet Σ. Then,\nthere are strings u, v, x, y, z ∈Σ∗, with |vy| > 0, such that uvixyiz ∈L for all i ≥0.2\nProof. Let L1 ⊆Σ∗, L2 ⊆{u, d}∗and deﬁne the F-system Φ = (L1, L2). If L = L(Φ)\nis inﬁnite, then L1 and L2 are also inﬁnite.\nSet p = max(p1, p2), where p1 and p2\nare pumping lengths for L1 and L2 (from the pumping lemma for regular languages),\nrespectively, and choose any string w ∈L such that |w| ≥p. Then, there are strings\nr ∈L1 and s ∈L2 such that w = h(r, s), with |r| = |s| = |w| ≥p.\nAccording to the pumping lemma for regular languages, r may be written as r =\nxryrzr, with |yr| > 0, such that xryj\nrzr ∈L1 for any j ≥0. Similarly, s may be written\nas s = xsyszs, with |ys| > 0, such that xsyj\nszs ∈L2 for any j ≥0.\nConsider the sequences {rj} and {sj} deﬁned by\nrj = xry|ys|j+1\nr\nzr,\n(7)\nsj = xsy|yr|j+1\ns\nzs,\n(8)\nfor any j ≥0. Clearly, rj ∈L1, sj ∈L2; further, |rj| = |sj| and so each of the strings\nin {rj} may be folded according with the corresponding string in {sj}. For clarity, let\nus arrange rj and sj in the form of a double stranded structure\nh rj\nsj\ni\n, illustrated with an\nexample in Fig. 3. Note that, for j large enough, repetitions of substring yr overlap with\nrepetitions of substring ys. Therefore, we may seek expressions of rj and sj of the form\nrj = ξ1ξj−j0\n2\nξ3,\n(9)\nsj = µ1µj−j0\n2\nµ3,\n(10)\nwith substrings ξk and µk such that |ξk| = |µk| for k = 1, 2, 3, and for j ≥j0, where j0\nis a constant to be determined.\n2Sburlan’s (2011) original version of the lemma states that there exists a positive constant p such\nthat any string w ∈L, with |w| ≥p, can be written as w = uvxyz satisfying uvixyiz ∈L for each i ≥0,\n|vy| ≥1, and |vxy| ≤p. In his proof, he set p = max(p1, p2) where p1 and p2 are the pumping lengths\nfor the core and the folding procedure languages. However, it can be shown that such a value of p does\nnot always work. As a simple example, set Φ = (L1, L2) with L1 = aaaab∗and L2 = (uu)∗ddd. Then,\np = 5. However, L(Φ) = aaaab ∪(bb)∗aaaabbb, and note that string aaaab has length 5 but it can not\nbe pumped as indicated by the lemma. Although the original lemma may still hold for some other value\nof p (p = 9, in case of the example, with u = x = y = ε, v = bb and z = aaaabbb), a full demonstration\nwas not provided.\nOther inconsistencies have been detected in the proof. For example, the proof is based on constructing\na double stranded structure\nh\nrj\nsj\ni\n, and the technique is also used here. However, instead of Eqs. (7) and\n(8), the previous proof sets rj = xry\nlcm(|yr|,|ys|)\n|yr|\nj\nr\nzr and sj = xsy\nlcm(|yr |,|ys|)\n|ys|\nj\ns\nzs, where lcm denotes the\nleast common multiple. Since the stranded construction requires |rj| = |sj|, it follows that |xrzr| = |xszs|\nand hence |yr| = |ys|. However, those conditions do not hold for arbitrary regular languages L1 and L2\n(note that, in the above example, |yr| = |b| = 1 whereas |ys| = |uu| = 2).\nSimilar problems have been found also in the original version of the lemma for the case of L ∈\nF(CF, REG).\n4\nJ. C. Lucero: Pumping lemmas for F-systems\n\"\nrj\nsj\n#\n=\n\"\n#\n|\nxr\n| yr | yr | yr | yr | yr |\n| yr | yr | yr | yr |\nzr\n|\n|\nxs\n|ys|ys |ys |ys|ys |ys |\n· · ·\n· · ·\n· · ·\n· · ·\n|ys|ys|ys |ys|ys |ys | zs |\nξ1\nξ2\nξ2\nξ2\nξ3\nµ1\nµ2\nµ2\nµ2\nµ3\nFigure 3: Double stranded structure built with strings rj ∈L1 and sj ∈L2, in the case in\nwhich both L1 and L2 are regular languages.\nIn Eqs. (7) and (8), the iterated portions may be decomposed as\ny|ys|j+1\nr\n= α1ξj−j0\n2\nα2,\n(11)\ny|yr|j+1\ns\n= β1µj−j0\n2\nβ2,\n(12)\nwith\nα1α2 = yj0|ys|+1\nr\n,\n(13)\nβ1β2 = yj0|yr|+1\ns\n.\n(14)\nConsequently, ξ2 and µ2 will be formed by repetitions of strings yr and ys, respectively,\nwith\n|ξj−j0\n2\n| = |y|ys|j+1\nr\n| −|α1α2|,\n= |yr|(|ys|j + 1) −|yr|(j0|ys| + 1)\n= |yr||ys|(j −j0),\n(15)\nand the same result for |µj−j0\n2\n|. Consequently, |ξ2| = |µ2| = |yr||ys|.\nNext, we set ξ1 = xrα1, ξ3 = α2zr, µ1 = xsβ1, µ3 = β2zs. Substrings α1, α2, β1, β2\nare computed so that |ξ1| = |µ1| and |ξ3| = |µ3|, with\n(\nβ1 = ε, |α1| = |xs| −|xr|, if |xs| ≥|xr|,\nα1 = ε, |β1| = |xr| −|xs|, if |xs| < |xr|.\n(16)\nand using Eqs. (13) and (14). During the calculations, constant j0 is chosen large enough\nso as to produce |α2| ≥0 and |β2| ≥0. result.\nFinally, h(rj, sj) is computed by using Eqs. (9), (10), and the identity in Eq. (4).\nNote that ξ1, ξ2 and ξ3 are folded as determined by µ1, µ2, and µ3, respectively. Then,\nletting i = j −j0,\nh(ξ1ξi\n2ξ3, µ1µi\n2µ3) = (ξ3)R\nu [(ξ2)R\nu ]i(ξ1)R\nu (ξ1)d(ξ2)i\nd(ξ3)d.\n(17)\nThe condition stated by the lemma is obtained from Eq. (17) with u = (ξ3)R\nu , v = (ξ2)R\nu ,\nx = (ξ1)R\nu (ξ1)d, y = (ξ2)d, z = (ξ3)d. Also, |vy| = |ξ2| = |yr||ys| > 0.\nThe next lemma considers the two cases in which the core and the folding procedure\nlanguages belong to diﬀerent classes, regular or context-free. Its demonstration follows\nsimilar steps as in Lemma 1.\n5\nJ. C. Lucero: Pumping lemmas for F-systems\n\"\nrj\nsj\n#\n=\n\"\n#\n| ur | vr | vr | vr |· · ·\n· · ·\n| vr | vr | vr |xr| yr | yr | yr | · · ·\n· · ·\n| yr | yr |\nzr\n|\n|\nxs\n|ys|ys|ys|\n· · ·\n· · ·\n|ys|ys|ys|ys|ys|ys|ys|ys|ys|ys|\n· · ·\n· · · |ys|ys|ys|ys|ys| zs\n|\nξ1\nξ2\nξ2\nξ3\nξ4\nξ4\nξ5\nµ1\nµ2\nµ2\nµ3\nµ4\nµ4\nµ5\nFigure 4: Double stranded structure built with strings rj ∈L1 and sj ∈L2, in the case in\nwhich L1 is a context-free language and L2 is a regular language.\nLemma 2. Let L ∈F(CF, REG) or L ∈F(REG, CF) be an inﬁnite language over an\nalphabet Σ. Then, there are strings w1, w2, . . . , w9 ∈Σ∗, with |w2w4w6w8| > 0, such that\nw1wi\n2w3wi\n4w5wi\n6w7wi\n8w9 ∈L for all i ≥0.\nProof. Consider ﬁrst the case L ∈F(CF, REG) and proceed similarly as in Lemma 1,\nexcept that the pumping lemma for context-free languages is used for string r ∈L1.\nThus, r is written as r = urvrxryrzr, with |vryr| > 0 and urvj\nrxryj\nrzr ∈L1, for any\nj ≥0. Strings rj ∈L1 and sj ∈L2 are now deﬁned as\nrj = urv|ys|j+1\nr\nxry|ys|j+1\nr\nzr,\n(18)\nsj = xsy|vryr|j+1\ns\nzs,\n(19)\nfor any j ≥0, and their double stranded arrangement is illustrated in Fig. 4.\nFor j large enough, repetitions of ys overlap with repetitions of vr (if |vr| > 0) and\nyr (if |yr| > 0). Then, we may seek expressions of rj and sj of the form\nrj = ξ1ξj−j0\n2\nξ3ξj−j0\n4\nξ5,\n(20)\nsj = µ1µj−j0\n2\nµ3µj−j0\n4\nµ5,\n(21)\nwith substrings ξk and µk such that |ξk| = |µk| for k = 1, 2, . . . , 5, and for j ≥j0, where\nj0 is a constant to be determined.\nIn Eqs. (18) and (19), the iterated portions are decomposed as\nv|ys|j+1\nr\n= α1ξj−j0\n2\nα2,\n(22)\ny|ys|j+1\nr\n= β1ξj−j0\n4\nβ2,\n(23)\ny|vryr|j+1\ns\n= γ1µj−j0\n2\nγ2µj−j0\n4\nγ3,\n(24)\nwith\nα1α2 = vj0|ys|+1\nr\n,\n(25)\nβ1β2 = yj0|ys|+1\nr\n,\n(26)\nγ1γ2γ3 = yj0|vryr|+1\ns\n,\n(27)\nConsequently, ξ2 and µ2 will be formed by repetitions of strings vr and ys, respectively,\nwith |ξ2| = |µ2| = |vr||ys|. Also, ξ4 and µ4 will be formed by repetitions of strings yr\nand ys, respectively, with |ξ4| = |µ4| = |yr||ys|.\n6\nJ. C. Lucero: Pumping lemmas for F-systems\nNext, we set ξ1 = urα1, ξ3 = α2xrβ1, ξ5 = α2zr, µ1 = xsγ1, µ3 = γ2, µ5 = γ3zs.\nSubstrings α1, α2, β1, β2, γ1, γ2, and γ3 are selected so that |ξ1 = µ1|, |ξ3 = µ3|, and\n|ξ5 = µ5|, with\n(\nγ1 = ε, |α1| = |xs| −|ur|, if |xs| ≥|ur|,\nα1 = ε, |γ1| = |ur| −|xs|, if |xs| < |ur|,\n(28)\n(\nγ3 = ε, |β2| = |zs| −|zr|, if |zs| ≥|zr|,\nβ2 = ε, |γ3| = |zr| −|zs|, if |zs| < |zr|,\n(29)\nand using Eqs. (25) to (27) for a value of j0 large enough.\nFinally, we compute h(rj, sj) using Eqs. (20), (21), and the identity in Eq. (4). Then,\nletting i = j −j0,\nh(ξ1ξi\n2ξ3ξi\n4ξ5, µ1µi\n2µ3µi\n4µ5) =\n(ξ5)R\nu [(ξ4)R\nu ]i(ξ3)R\nu [(ξ2)R\nu ]i(ξ1)R\nu (ξ1)d(ξ2)i\nd(ξ3)d(ξ4)i\nd(ξ5)d.\n(30)\nThe condition stated by the lemma is obtained from Eq. (30) with w1 = (ξ5)R\nu ,\nw2 = (ξ4)R\nu , w3 = (ξ3)R\nu , w4 = (ξ2)R\nu , w5 = (ξ1)R\nu (ξ1)d, w6 = (ξ2)d, w7 = (ξ3)d,\nw8 = (ξ4)d, w9 = (ξ5)d. Also, |w2w4w6w8| = |ξ2ξ4| = |vryr||ys| > 0.\nConsider next the case L ∈F(REG, CF). This case is treated as the previous one,\nexcept that r and s are decomposed following the pumping lemmas for regular languages\nand context-free languages, respectively. Thus, strings rj and sj are now deﬁned as\nrj = xry|vsys|j+1\nr\nzr,\n(31)\nsj = usv|yr|j+1\ns\nxsy|yr|j+1\ns\nzs,\n(32)\nwith |yr| > 0, |vsys| > 0, and for any j ≥0.\nIn Eqs. (31) and (32), the iterated portions are decomposed as\ny|vsyr|s+1\nr\n= α1ξj−j0\n2\nα2ξj−j0\n4\nα3,\n(33)\nv|yr|j+1\ns\n= β1µj−j0\n2\nβ2,\n(34)\ny|yr|j+1\ns\n= γ1µj−j0\n4\nγ2,\n(35)\nwith\nα1α2α3 = yj0|vsys|+1\nr\n,\n(36)\nβ1β2 = vj0|yr|+1\ns\n,\n(37)\nγ1γ2 = yj0|yr|+1\ns\n.\n(38)\nThe demonstration then follows similar steps as in the previous case: rj and sj are\nexpressed as in Eqs. (20) and (21) with ξ1 = xrα1, ξ3 = α2, ξ5 = α3zr, µ1 = usβ1,\nµ3 = β2xsγ1, µ5 = γ2zs.\nThe last lemma considers the case in which both the core and the folding procedure\nlanguages are context-free. It has a longer demonstration; nevertheless, it follows the\nsame technique as the previous ones.\n7\nJ. C. Lucero: Pumping lemmas for F-systems\n\"\nrj\nsj\n#\n=\n\"\n#\n| ur |\nv|vr||ys||vsys|j+1\nr\n|xr |y|vr||ys||vsys|j+1\nr\n|\nzr\n|\n|\nus\n| v|vr||ys||vryr|j+1\ns\n| xs |\ny|vr||ys||vryr|j+1\ns\n| zs |\nξ1\nξj−j0\n2\nξ3\nξj−j0\n4\nξ5\nξj−j0\n6\nξ7\nµ1\nµj−j0\n2\nµ3\nµj−j0\n4\nµ5\nµj−j0\n6\nµ7\nFigure 5: Double stranded structure built with strings rj ∈L1 and sj ∈L2, in the case in\nwhich both L1 and L2 are context-free languages and |vr||ys| > |vs||yr|.\nLemma 3. Let L ∈F(CF, CF) be an inﬁnite language over an alphabet Σ. Then, there\nare\nstrings\nw1, w2, . . . , w13\n∈\nΣ∗,\nwith\n|w2w4w6 · · · w12|\n>\n0,\nsuch\nthat\nw1wi\n2w3wi\n4w5 · · · w11wi\n12w13 ∈L for all i ≥0.\nProof. We proceed as in the previous lemmas, except that the pumping lemma for\ncontext-free languages is used for both strings r ∈L1 and s ∈L2. Thus, r is written as\nr = urvrxryrzr, with |vryr| > 0 and rj = urvj\nrxryj\nrzr ∈L1 for any j ≥0, and s is written\nas s = usvsxsyszs, with |vsys| > 0 and sj = usvj\nsxsyj\nszs ∈L2 for any j ≥0.\nConsider ﬁrst the case in which |vr||ys| > |vs||yr|. Strings rj and sj are deﬁned as\nrj = urv|vr||ys||vsys|j+1\nr\nxry|vr||ys||vsys|j+1\nr\nzr,\n(39)\nsj = usv|vr||ys||vryr|j+1\ns\nxsy|vr||ys||vryr|j+1\ns\nzs,\n(40)\nfor any j ≥0, and their double stranded arrangement is illustrated in Fig. 5.\nFor j large enough, and since |vr||ys| > |vs||yr|, then repetitions of vr overlap with\nrepetitions of both vs (if |vs| > 0) and ys, and repetitions of ys overlap with repetitions\nof both vr and yr (if |yr| > 0). Then, we may seek expressions of rj and sj of the form\nrj = ξ1ξj−j0\n2\nξ3ξj−j0\n4\nξ5ξj−j0\n6\nξ7,\n(41)\nsj = µ1µj−j0\n2\nµ3µj−j0\n4\nµ5µj−j0\n6\nµ7,\n(42)\nwith substrings ξk and µk such that |ξk| = |µk| for k = 1, 2, . . . , 7, and for j ≥j0, where\nj0 is a constant to be determined.\nIn Eqs. (39) and (40), the iterated portions may be decomposed as\nv|vr||ys||vsys|j+1\nr\n= α1ξ(j−j0)\n2\nα2ξ4(j −j0)α3,\n(43)\ny|vr||ys||vsys|j+1\nr\n= β1ξ(j−j0)\n6\nβ2,\n(44)\nv|vr||ys||vryr|j+1\ns\n= γ1µ(j−j0)\n2\nγ2,\n(45)\ny|vr||ys||vryr|j+1\ns\n= δ1µ(j−j0)\n4\nδ2µ(j−j0)\n6\nδ3,\n(46)\nwith\nα1α2α3 = vj0|vr||ys||vsys|+1\nr\n,\n(47)\nβ1β2 = yj0|vr||ys||vsys|+1\nr\n,\n(48)\nγ1γ2 = vj0|vr||ys||vryr|+1\ns\n(49)\nδ1δ2δ3 = vj0|vr||ys||vryr|+1\ns\n.\n(50)\n8\nJ. C. Lucero: Pumping lemmas for F-systems\n\"\nrj\nsj\n#\n=\n\"\n#\n| us |\nv|vs||yr||vryr|j+1\ns\n| xs |y|vs||yr||vryr|j+1\ns\n|\nzs\n|\n|\nur\n| v|vs||yr||vsys|j+1\nr\n|xr |\ny|vs||yr||vsys|j+1\nr\n| zr |\nξ1\nξj−j0\n2\nξ3\nξj−j0\n4\nξ5\nξj−j0\n6\nξ7\nµ1\nµj−j0\n2\nµ3\nµj−j0\n4\nµ5\nµj−j0\n6\nµ7\nFigure 6: Double stranded structure built with strings rj ∈L1 and sj ∈L2, in the case in\nwhich both L1 and L2 are context-free languages and |vr||ys| < |vs||yr|.\nConsequently, ξ2 and µ2 will be formed by repetitions of strings vr and vs, respectively,\nwith |ξ2| = |µ2| = |vr||vs||ys||vryr|; ξ4 and µ4 will be formed by repetitions of strings\nvr and ys, respectively, with |ξ4| = |µ4| = |vr||ys|(|vr||ys| −|vs||yr|); and ξ6 and µ6\nwill be formed by repetitions of strings yr and ys, respectively, with |ξ6| = |µ6| =\n|vr||yr||ys||vsys|. Next, we set ξ1 = urα1, ξ3 = α2, ξ5 = α3xrβ1, ξ7 = β2zr, µ1 = usγ1,\nµ3 = γ2xsδ1, µ5 = δ2, µ7 = δ3zs.\nSubstrings α1, α2, α3, β1, β2, γ1, γ2, δ1, δ2 and δ3 are selected so that |ξ1 = µ1|,\n|ξ3 = µ3|, |ξ5 = µ5|, |ξ7 = µ7|, with δ1 = ε, |α2| = |γ2| + |xs|,\n(\nγ1 = ε, |α1| = |us| −|ur|, if |us| ≥|ur|,\nα1 = ε, |γ1| = |ur| −|us|, if |us| < |ur|,\n(51)\n(\nδ3 = ε, |β2| = |zs| −|zr|, if |zs| ≥|zr|,\nβ2 = ε, |δ3| = |zr| −|zs|, if |zs| < |zr|,\n(52)\nand using Eqs. (47) to (50) for a value of j0 large enough.\nFinally, we compute h(rj, sj) using Eqs. (41), (42), and the identity in Eq. (4). Then,\nletting i = j −j0,\nh(ξ1ξi\n2ξ3ξi\n4ξ5ξi\n6ξ7, µ1µi\n2µ3µi\n4µ5µi\n6µ7) =\n(ξ7)R\nu [(ξ6)R\nu ]i(ξ5)R\nu [(ξ4)R\nu ]i(ξ3)R\nu [(ξ2)R\nu ]i(ξ1)R\nu (ξ1)d(ξ2)i\nd(ξ3)d(ξ4)i\nd(ξ5)d(ξ6)i\nd(ξ7)d.\n(53)\nThe condition stated by the lemma is obtained from Eq. (53) with w1 = (ξ7)R\nu ,\nw2 = (ξ6)R\nu , w3 = (ξ5)R\nu , w4 = (ξ4)R\nu , w5 = (ξ3)R\nu , w6 = (ξ2)R\nu , w7 = (ξ1)R\nu (ξ1)d,\nw8 = (ξ2)d, w9 = (ξ3)d, w10 = (ξ4)d, w11 = (ξ5)d, w12 = (ξ6)d, w13 = (ξ7)d. Also,\n|w2w4w6w8w10w12| = |ξ2ξ4ξ6| = |vr||ys||vryr||vsys| > 0.\nConsider next the case in which |vr||ys| < |vs||yr|, and deﬁne\nrj = urv|vs||yr||vsys|j+1\nr\nxry|vs||yr||vsys|j+1\nr\nzr,\n(54)\nsj = usv|vs||yr||vryr|j+1\ns\nxsy|vs||yr||vryr|j+1\ns\nzs,\n(55)\nfor any j ≥0, with the double stranded arrangement illustrated in Fig. 6.\nWe seek expressions of rj and sj of the form in Eqs. (41) and (42), and decompose\n9\nJ. C. Lucero: Pumping lemmas for F-systems\nthe iterated portions in Eqs. (54) and (55) as\nv|vs||yr||vsys|j+1\nr\n= α1ξ(j−j0)\n2\nα2,\n(56)\ny|vs||yr||vsys|j+1\nr\n= β1ξ(j−j0)\n4\nβ2ξ(j−j0)\n6\nβ3,\n(57)\nv|vs||yr||vryr|j+1\ns\n= γ1µ(j−j0)\n2\nγ2µ(j−j0)\n4\nγ3,\n(58)\ny|vs||yr||vryr|j+1\ns\n= δ1µ(j−j0)\n6\nδ2,\n(59)\nwith\nα1α2 = vj0|vs||yr||vsys|+1\nr\n,\n(60)\nβ1β2β3 = yj0|vs||yr||vsys|+1\nr\n,\n(61)\nγ1γ2γ3 = vj0|vs||yr||vryr|+1\ns\n,\n(62)\nδ1δ2 = vj0|vs||yr||vryr|+1\ns\n.\n(63)\nConsequently, ξ2 and µ2 will be formed by repetitions of strings vr and vs, re-\nspectively, with |ξ2| = |µ2| = |vr||vs||yr||vsys|; ξ4 and µ4 will be formed by repeti-\ntions of strings yr and vs, respectively, with |ξ4| = |µ4| = |yr||vs|(|vs||yr| −|vr||ys|);\nand ξ6 and µ6 will be formed by repetitions of strings yr and ys, respectively, with\n|ξ6| = |µ6| = |ys||vs||yr||vryr|. Next, we set ξ1 = urα1, ξ3 = α2xrβ1, ξ5 = β2, ξ7 = β3zr,\nµ1 = usγ1, µ3 = γ2, µ5 = γ3xsδ1, µ7 = δ2zs.\nSubstrings α1, α2, α3, β1, β2, γ1, γ2, δ1, δ2 and δ3 are selected so that |ξ1 = µ1|,\n|ξ3 = µ3|, |ξ5 = µ5|, |ξ7 = µ7|, with γ3 = ε, |β2| = |δ1| + |xs|,\n(\nδ2 = ε, |β3| = |zs| −|zr|, if |zs| ≥|zr|,\nβ3 = ε, |δ2| = |zr| −|zs|, if |zs| < |zr|,\n(64)\nand using Eq. (51) and Eqs. (60) to (63), for a value of j0 large enough.\nThe demonstration then follows similar steps as in the previous case.\nFinally, consider the remaining case of |vr||ys| = |vs||yr|. If |vr||ys| ̸= 0 and |vs||yr| ̸=\n0, then the same constructions of the previous cases work, resulting in ξ4 = µ4 = ε and\ntherefore w4 = w10 = ε.\nIf |vr||ys| = |vs||yr| = 0, then either vr = vs = ε or yr = ys = ε (recall that the\npumping lemma for context-free languages demands |vryr| > 0 and |vsys| > 0). Assume\nﬁrst vr = vs = ε, and deﬁne\nrj = urxry|ys|j+1\nr\nzr,\n(65)\nsj = usxsy|yr|j+1\ns\nzs,\n(66)\nfor any j ≥0. Next, follow the same procedure as in Lemma 1 to express rj and sj in\nthe form of Eqs. (9) and (10), with the exception that ξ1 = urxrα1 and µ1 = usxsβ1\n(instead of ξ1 = xrα1 and µ1 = xsβ1, respectively). Then, h(rj, sj) is given by Eq. (17)\nand the condition stated by the present lemma is obtained with w1 = (ξ3)R\nu , w2 = (ξ2)R\nu ,\nw3 = w4 = w5 = w6 = ε, w7 = (ξ1)R\nu (ξ1)d, w8 = w9 = w10 = w11 = ε, w12 = (ξ2)d,\nw13 = (ξ3)d. Also, |w2w4w6w8w10w12| = |ξ2| = |yr||ys| ≥1.\nIf yr = ys = ε, proceed as above with\nrj = urv|vs|j+1\nr\nxrzr,\n(67)\nsj = usv|vr|j+1\ns\nxszs,\n(68)\nfor any j ≥0.\n10\nJ. C. Lucero: Pumping lemmas for F-systems\n4\nFinal remarks and example\nThe lemmas only apply to inﬁnite languages. However, any ﬁnite language is in class\nF(REG, REG). Let L1 be any arbitrary language and deﬁne Φ = (L1, d∗); then, L1 =\nL(Φ). Therefore, if L1 ﬁnite then it is regular and, consequently, L1 ∈F(REG, REG).\nFurther, and since REG ⊂CF, then L1 also is in F(CF, REG), F(REG, CF), and\nF(CF, CF).\nIn spite of the lemmas being weak, they still are useful to prove non membership of\nsome languages in a class, as the following example shows.\nExample 2. Consider L = {an| n is prime } and assume that L satisﬁes the lemma.\nThen, there are strings w1, w2, . . . , w13 ∈a∗, with |w2w4w6 · · · w12| > 0, such that\nw1wi\n2w3wi\n4w5 · · · w11wi\n12w13\n∈\nL for all i ≥\n0.\nLetting i =\n1, we have that\nw1w2w3w4w5 · · · w11w12w13 = ak for some prime k. Then, w2w4w6 · · · w12 = aℓwith\n0 < ℓ≤k. Next, letting i = k + 1, we obtain w1wi\n2w3wi\n4w5 · · · w11wi\n12w13 = ak(1+ℓ).\nHowever, this string is not in L2, because the number of a’s is not a prime. The contra-\ndiction implies that L2 /∈F(CF, CF).\nAcknowledgements\nThis work was supported by Conselho Nacional de Desenvolvimento Cientíﬁco e Tec-\nnológico (CNPq, Brazil).\nReferences\nAkitaya, H. A., Demaine E. D., and Ku J. S. (2017). “Simple folding is really hard,” J.\nInform. Process. 25, 580–589.\nAlperin, R. C. (2000). “A mathematical theory of origami constructions and numbers,”\nNew York J. Math. 6, 119–133.\nCipra, B. (2001). “In the fold: Origami meets mathematics,” SIAM News 34, 1–4.\nDemaine, E. D. and O’Rourke, J. (2007). Geometric Folding Algorithms: Linkages,\nOrigami, Polyhedra. Cambridge (University Press, New York), pp. 167–298.\nDobson, C. M. (2003). “Protein folding and misfolding,” Nature 426, 884–890.\nFelton, S., Tolley, M., Demaine, E., Rus, D., and Wood, R. (2014). “A method for\nbuilding self-folding machines,” Science 345, 644–646.\nFilipov, E. T., Tachi, T., and Paulino, G. H. (2015). “Origami tubes assembled into\nstiﬀ, yet reconﬁgurable structures and metamaterials,” Proc. Natl. Acad. Sci. USA\n112, 12321–12326.\nHopcroft, J. E., Motwani R., and Ullman, J. D. (2001). Introduction to Automata Theory,\nLanguages and Computation, 2nd edn. (Addison-Wesley, New York), pp. 126–127 and\n275–276.\nIda, T., Fleuriot, J., and Ghourabi, F. (2016). “A new formalization of origami in geomet-\nric algebra,” in Proceedings of ADG 2016: 11th International Workshop on Automated\nDeduction in Geometry, edited by J. Narboux, P. Schreck, and I. Streinu (Strasbourg,\nFrance), pp. 117–136.\n11\nJ. C. Lucero: Pumping lemmas for F-systems\nKari, L. and Rozenberg, G. (2008). “The many facets of natural computing,” Commun.\nACM 51, 72–83.\nMahadevan, L. and Rica, S. (2005) . “Self-organized origami,” Science 307, 1740–1740.\nRothemund, P. W. (2006). “Folding DNA to create nanoscale shapes and patterns,”\nNature 440, 297.\nSburlan, D. (2011). “Computing by folding,” Int. J. Comput. Commun. Controls 6,\n739–748.\n12\n",
  "categories": [
    "cs.FL",
    "68Q45",
    "F.4.3"
  ],
  "published": "2019-10-18",
  "updated": "2019-10-18"
}