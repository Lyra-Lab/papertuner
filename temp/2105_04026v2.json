{
  "id": "http://arxiv.org/abs/2105.04026v2",
  "title": "The Modern Mathematics of Deep Learning",
  "authors": [
    "Julius Berner",
    "Philipp Grohs",
    "Gitta Kutyniok",
    "Philipp Petersen"
  ],
  "abstract": "We describe the new field of mathematical analysis of deep learning. This\nfield emerged around a list of research questions that were not answered within\nthe classical framework of learning theory. These questions concern: the\noutstanding generalization power of overparametrized neural networks, the role\nof depth in deep architectures, the apparent absence of the curse of\ndimensionality, the surprisingly successful optimization performance despite\nthe non-convexity of the problem, understanding what features are learned, why\ndeep architectures perform exceptionally well in physical problems, and which\nfine aspects of an architecture affect the behavior of a learning task in which\nway. We present an overview of modern approaches that yield partial answers to\nthese questions. For selected approaches, we describe the main ideas in more\ndetail.",
  "text": "The Modern Mathematics of Deep Learning∗\nJulius Berner†\nPhilipp Grohs‡\nGitta Kutyniok§\nPhilipp Petersen‡\nAbstract\nWe describe the new ﬁeld of mathematical analysis of deep learning. This ﬁeld emerged around a list\nof research questions that were not answered within the classical framework of learning theory. These\nquestions concern: the outstanding generalization power of overparametrized neural networks, the role of\ndepth in deep architectures, the apparent absence of the curse of dimensionality, the surprisingly successful\noptimization performance despite the non-convexity of the problem, understanding what features are\nlearned, why deep architectures perform exceptionally well in physical problems, and which ﬁne aspects\nof an architecture aﬀect the behavior of a learning task in which way. We present an overview of modern\napproaches that yield partial answers to these questions. For selected approaches, we describe the main\nideas in more detail.\nContents\n1\nIntroduction\n2\n1.1\nNotation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n4\n1.2\nFoundations of learning theory\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n4\n1.3\nDo we need a new theory? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n17\n2\nGeneralization of large neural networks\n22\n2.1\nKernel regime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n23\n2.2\nNorm-based bounds and margin theory\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n24\n2.3\nOptimization and implicit regularization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n25\n2.4\nLimits of classical theory and double descent\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n27\n3\nThe role of depth in the expressivity of neural networks\n29\n3.1\nApproximation of radial functions\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n29\n3.2\nDeep ReLU networks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n31\n3.3\nAlternative notions of expressivity\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n32\n4\nDeep neural networks overcome the curse of dimensionality\n34\n4.1\nManifold assumption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n34\n4.2\nRandom sampling\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n35\n4.3\nPDE assumption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n36\n5\nOptimization of deep neural networks\n39\n5.1\nLoss landscape analysis\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n39\n5.2\nLazy training and provable convergence of stochastic gradient descent\n. . . . . . . . . . . . .\n41\n∗A version of this review paper appears as a chapter in the book “Mathematical Aspects of Deep Learning” by Cambridge\nUniversity Press.\n†Faculty of Mathematics, University of Vienna.\n‡Faculty of Mathematics and Research Network DataScience@UniVienna, University of Vienna.\n§Department of Mathematics, Ludwig Maximilian University of Munich, and Department of Physics and Technology,\nUniversity of Tromsø.\n1\narXiv:2105.04026v2  [cs.LG]  8 Feb 2023\n6\nTangible eﬀects of special architectures\n44\n6.1\nConvolutional neural networks\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n45\n6.2\nResidual neural networks\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n46\n6.3\nFramelets and U-Nets\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n47\n6.4\nBatch normalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n49\n6.5\nSparse neural networks and pruning\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n50\n6.6\nRecurrent neural networks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n52\n7\nDescribing the features a deep neural network learns\n52\n7.1\nInvariances and the scattering transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n52\n7.2\nHierarchical sparse representations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n53\n8\nEﬀectiveness in natural sciences\n55\n8.1\nDeep neural networks meet inverse problems . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n55\n8.2\nPDE-based models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n56\n1\nIntroduction\nDeep learning has undoubtedly established itself as the outstanding machine learning technique of recent\ntimes. This dominant position was claimed through a series of overwhelming successes in widely diﬀerent\napplication areas.\nPerhaps the most famous application of deep learning and certainly one of the ﬁrst where these techniques\nbecame state-of-the-art is image classiﬁcation [LBBH98, KSH12, SLJ+15, HZRS16]. In this area, deep\nlearning is nowadays the only method that is seriously considered. The prowess of deep learning classiﬁers\ngoes so far that they often outperform humans in image labelling tasks [HZRS15].\nA second famous application area is the training of deep-learning-based agents to play board games or\ncomputer games, such as Atari games [MKS+13]. In this context, probably the most prominent achievement\nyet is the development of an algorithm that beat the best human player in the game of Go [SHM+16, SSS+17]—\na feat that was previously unthinkable owing to the extreme complexity of this game. Besides, even in\nmultiplayer, team-based games with incomplete information deep-learning-based agents nowadays outperform\nworld-class human teams [BBC+19, VBC+19].\nIn addition to playing games, deep learning has also led to impressive breakthroughs in the natural\nsciences. For example, it is used in the development of drugs [MSL+15], molecular dynamics [FHH+17], or in\nhigh-energy physics [BSW14]. One of the most astounding recent breakthroughs in scientiﬁc applications\nis the development of a deep-learning-based predictor for the folding behavior of proteins [SEJ+20]. This\npredictor is the ﬁrst method to match the accuracy of lab-based methods.\nFinally, in the vast ﬁeld of natural language processing, which includes the subtasks of understanding,\nsummarizing, or generating text, impressive advances were made based on deep learning. Here, we refer\nto [YHPC18] for an overview. One technique that recently stood out is based on a so-called transformer neural\nnetwork [BCB15, VSP+17]. This network structure gave rise to the impressive GPT-3 model [BMR+20]\nwhich not only creates coherent and compelling texts but can also produce code, such as, for the layout of a\nwebpage according to some instructions that a user inputs in plain English. Transformer neural networks\nhave also been successfully employed in the ﬁeld of symbolic mathematics [SGHK18, LC19].\nIn this article, we present and discuss the mathematical foundations of the success story outlined above.\nMore precisely, our goal is to outline the newly emerging ﬁeld of mathematical analysis of deep learning. To\naccurately describe this ﬁeld, a necessary preparatory step is to sharpen our deﬁnition of the term deep\nlearning. For the purposes of this article, we will use the term in the following narrow sense: Deep learning\nrefers to techniques where deep neural networks1 are trained with gradient-based methods. This narrow\n1We will deﬁne the term neural network later but, for this deﬁnition, one can view it as a parametrized family of functions\nwith a diﬀerentiable parametrization.\n2\ndeﬁnition is helpful to make this article more concise. We would like to stress, however, that we do not claim\nin any way that this is the best or the right deﬁnition of deep learning.\nHaving ﬁxed a deﬁnition of deep learning, three questions arise concerning the aforementioned emerging\nﬁeld of mathematical analysis of deep learning: To what extent is a mathematical theory necessary? Is it\ntruly a new ﬁeld? What are the questions studied in this area?\nLet us start by explaining the necessity of a theoretical analysis of the tools described above. From a\nscientiﬁc perspective, the primary reason why deep learning should be studied mathematically is simple\ncuriosity. As we will see throughout this article, many practically observed phenomena in this context are\nnot explained theoretically. Moreover, theoretical insights and the development of a comprehensive theory\nare often the driving force underlying the development of new and improved methods. Prominent examples\nof mathematical theories with such an eﬀect are the theory of ﬂuid mechanics which is an invaluable asset\nto the design of aircraft or cars and the theory of information that aﬀects and shapes all modern digital\ncommunication. In the words of Vladimir Vapnik2: “Nothing is more practical than a good theory”, [Vap13,\nPreface]. In addition to being interesting and practical, theoretical insight may also be necessary. Indeed, in\nmany applications of machine learning, such as medical diagnosis, self-driving cars, and robotics, a signiﬁcant\nlevel of control and predictability of deep learning methods is mandatory. Also, in services, such as banking\nor insurance, the technology should be controllable to guarantee fair and explainable decisions.\nLet us next address the claim that the ﬁeld of mathematical analysis of deep learning is a newly emerging\narea. In fact, under the aforementioned deﬁnition of deep learning, there are two main ingredients of the\ntechnology: deep neural networks and gradient-based optimization. The ﬁrst artiﬁcial neuron was already\nintroduced in 1943 in [MP43]. This neuron was not trained but instead used to explain a biological neuron.\nThe ﬁrst multi-layered network of such artiﬁcial neurons that was also trained can be found in [Ros58].\nSince then, various neural network architectures have been developed. We will discuss these architectures in\ndetail in the following sections. The second ingredient, gradient-based optimization, is made possible by the\nobservation that due to the graph-based structure of neural networks the gradient of an objective function\nwith respect to the parameters of the neural network can be computed eﬃciently. This has been observed in\nvarious ways, see [Kel60, Dre62, Lin70, RHW86]. Again, these techniques will be discussed in the upcoming\nsections. Since then, techniques have been improved and extended. As the rest of the manuscript is spent\nreviewing these methods, we will keep the discussion of literature at this point brief. Instead, we refer to\nsome overviews of the history of deep learning from various perspectives: [LBH15, Sch15, GBC16, HH19].\nGiven the fact that the two main ingredients of deep neural networks have been around for a long\ntime, one would expect that a comprehensive mathematical theory has been developed that describes\nwhy and when deep-learning-based methods will perform well or when they will fail. Statistical learning\ntheory [AB99, Vap99, CS02, BBL03, Vap13] describes multiple aspects of the performance of general learning\nmethods and in particular deep learning. We will review this theory in the context of deep learning in\nSubsection 1.2 below. Hereby, we focus on classical, deep learning-related results that we consider well-known\nin the machine learning community. Nonetheless, the choice of these results is guaranteed to be subjective.\nWe will ﬁnd that the presented, classical theory is too general to explain the performance of deep learning\nadequately. In this context, we will identify the following questions that appear to be diﬃcult to answer\nwithin the classical framework of learning theory: Why do trained deep neural networks not overﬁt on the\ntraining data despite the enormous power of the architecture? What is the advantage of deep compared to\nshallow architectures? Why do these methods seemingly not suﬀer from the curse of dimensionality? Why\ndoes the optimization routine often succeed in ﬁnding good solutions despite the non-convexity, non-linearity,\nand often non-smoothness of the problem? Which aspects of an architecture aﬀect the performance of the\nassociated models and how? Which features of data are learned by deep architectures? Why do these methods\nperform as well as or better than specialized numerical tools in natural sciences?\nThe new ﬁeld of mathematical analysis of deep learning has emerged around questions like the ones listed\nabove. In the remainder of this article, we will collect some of the main recent advances to answer these\nquestions. Because this ﬁeld of mathematical analysis of deep learning is incredibly active and new material\nis added at breathtaking speeds, a brief survey on recent advances in this area is guaranteed to miss not only\n2This claim can be found earlier in a non-mathematical context in the works of Kurt Lewin [Lew43].\n3\na couple of references but also many of the most essential ones. Therefore, we do not strive for a complete\noverview, but instead, showcase several fundamental ideas on a mostly intuitive level. In this way, we hope to\nallow the reader to familiarize themselves with some exciting concepts and provide a convenient entry-point\nfor further studies.\n1.1\nNotation\nWe denote by N the set of natural numbers, by Z the set of integers and by R the ﬁeld of real numbers.\nFor N ∈N, we denote by [N] the set {1, . . . , N}. For two functions f, g: X →[0, ∞), we write f ≲g, if\nthere exists a universal constant c such that f(x) ≤cg(x) for all x ∈X. In a pseudometric space (X, dX ),\nwe deﬁne the ball of radius r ∈(0, ∞) around a point x ∈X by BdX\nr (x) or Br(x) if the pseudometric dX\nis clear from the context. By ∥· ∥p, p ∈[1, ∞], we denote the ℓp-norm, and by ⟨·, ·⟩the Euclidean inner\nproduct of given vectors. By ∥· ∥op we denote the operator norm induced by the Euclidean norm and by\n∥· ∥F the Frobenius norm of given matrices. For p ∈[1, ∞], s ∈[0, ∞), d ∈N, and X ⊂Rd, we denote by\nW s,p(X) the Sobolev-Slobodeckij space, which for s = 0 is just a Lebesgue space, i.e., W 0,p(X) = Lp(X).\nFor measurable spaces X and Y, we deﬁne M(X, Y) to be the set of measurable functions from X to Y.\nWe denote by ˆg the Fourier transform3 of a tempered distribution g. For probabilistic statements, we will\nassume a suitable underlying probability space with probability measure P. For an X-valued random variable\nX, we denote by E[X] and V[X] its expectation and variance and by PX the image measure of X on X,\ni.e., PX(A) = P(X ∈A) for every measurable set A ⊂X. If possible, we use the corresponding lowercase\nletter to denote the realization x ∈X of the random variable X for a given outcome. We write Id for the\nd-dimensional identity matrix and, for a set A, we write 1A for the indicator function of A, i.e., 1A(x) = 1 if\nx ∈A and 1A(x) = 0 else.\n1.2\nFoundations of learning theory\nBefore we continue to describe recent developments in the mathematical analysis of deep learning methods,\nwe start by providing a concise overview of the classical mathematical and statistical theory underlying\nmachine learning tasks and algorithms which, in their most general form, can be formulated as follows.\nDeﬁnition 1.1 (Learning - informal). Let X, Y, and Z be measurable spaces. In a learning task, one is given\ndata in Z and a loss function L: M(X, Y) × Z →R. The goal is to choose a hypothesis set F ⊂M(X, Y)\nand construct a learning algorithm, i.e., a mapping\nA:\n[\nm∈N\nZm →F,\nthat uses training data s = (z(i))m\ni=1 ∈Zm to ﬁnd a model fs = A(s) ∈F that performs well on the training\ndata s and also generalizes to unseen data z ∈Z. Here, performance is measured via the loss function L\nand the corresponding loss L(fs, z) and, informally speaking, generalization means that the out-of-sample\nperformance of fs at z behaves similar to the in-sample performance on s.\nDeﬁnition 1.1 is deliberately vague on how to measure generalization performance. Later, we will often\nstudy the expected out-of-sample performance. To talk about expected performance, a data distribution\nneeds to be speciﬁed. We will revisit this point in Assumption 1.10 and Deﬁnition 1.11.\nFor simplicity, we focus on one-dimensional, supervised prediction tasks with input features in Euclidean\nspace as deﬁned in the following.\nDeﬁnition 1.2 (Prediction task). In a prediction task, we have that Z := X × Y, i.e., we are given training\ndata s = ((x(i), y(i)))m\ni=1 that consist of input features x(i) ∈X and corresponding labels y(i) ∈Y. For\none-dimensional regression tasks with Y ⊂R, we consider the quadratic loss L(f, (x, y)) = (f(x) −y)2 and,\n3Respecting common notation, we will also use the hat symbol to denote the minimizer of the empirical risk bfs in Deﬁnition 1.8\nbut this clash of notation does not cause any ambiguity.\n4\nfor binary classiﬁcation tasks with Y = {−1, 1}, we consider the 0-1 loss L(f, (x, y)) = 1(−∞,0)(yf(x)). We\nassume that our input features are in Euclidean space, i.e., X ⊂Rd with input dimension d ∈N.\nIn a prediction task, we aim for a model fs : X →Y, such that, for unseen pairs (x, y) ∈X × Y, fs(x) is\na good prediction of the true label y. However, note that large parts of the presented theory can be applied\nto more general settings.\nRemark 1.3 (Learning tasks). Apart from straightforward extensions to multi-dimensional prediction tasks\nand other loss functions, we want to mention that unsupervised and semi-supervised learning tasks are\noften treated as prediction tasks. More precisely, one transforms unlabeled training data z(i) into features\nx(i) = T1(z(i)) ∈X and labels y(i) = T2(z(i)) ∈Y using suitable transformations T1 : Z →X, T2 : Z →Y. In\ndoing so, one asks for a model fs approximating the transformation T2 ◦T −1\n1\n: X →Y which is, e.g., done in\norder to learn feature representations or invariances.\nFurthermore, one can consider density estimation tasks, where X = Z, Y := [0, ∞], and F consists of\nprobability densities with respect to some σ-ﬁnite reference measure µ on Z. One then aims for a probability\ndensity fs that approximates the density of the unseen data z with respect to µ. One can perform L2(µ)-\napproximation based on the discretization L(f, z) = −2f(z) + ∥f∥2\nL2(µ) or maximum likelihood estimation\nbased on the surprisal L(f, z) = −log(f(z)).\nIn deep learning the hypothesis set F consists of realizations of neural networks Φa(·, θ), θ ∈P, with\na given architecture a and parameter set P. In practice, one uses the term neural network for a range of\nfunctions that can be represented by directed acyclic graphs, where the vertices correspond to elementary\nalmost everywhere diﬀerentiable functions parametrizable by θ ∈P and the edges symbolize compositions\nof these functions. In Section 6, we will review some frequently used architectures, in the other sections,\nhowever, we will mostly focus on fully connected feedforward (FC) neural networks as deﬁned below.\nDeﬁnition 1.4 (FC neural network). A fully connected feedforward neural network is given by its architecture\na = (N, ϱ), where L ∈N, N ∈NL+1, and ϱ: R →R. We refer to ϱ as the activation function, to L as the\nnumber of layers, and to N0, NL, and Nℓ, ℓ∈[L −1], as the number of neurons in the input, output, and\nℓ-th hidden layer, respectively. We denote the number of parameters by\nP(N) :=\nL\nX\nℓ=1\nNℓNℓ−1 + Nℓ\nand deﬁne the corresponding realization function Φa : RN0 × RP (N) →RNL which satisﬁes for every input\nx ∈RN0 and parameters\nθ = (θ(ℓ))L\nℓ=1 = ((W (ℓ), b(ℓ)))L\nℓ=1 ∈\nL×\nℓ=1\n(RNℓ×Nℓ−1 × RNℓ) ∼= RP (N)\nthat Φa(x, θ) = Φ(L)(x, θ), where\nΦ(1)(x, θ) = W (1)x + b(1),\n¯Φ(ℓ)(x, θ) = ϱ\n\u0000Φ(ℓ)(x, θ)\n\u0001\n,\nℓ∈[L −1],\nand\nΦ(ℓ+1)(x, θ) = W (ℓ+1) ¯Φ(ℓ)(x, θ) + b(ℓ+1),\nℓ∈[L −1],\n(1.1)\nand ϱ is applied componentwise. We refer to W (ℓ) ∈RNℓ×Nℓ−1 and b(ℓ) ∈RNℓas the weight matrices and\nbias vectors, and to ¯Φ(ℓ) and Φ(ℓ) as the activations and pre-activations of the Nℓneurons in the ℓ-th layer.\nThe width and depth of the architecture are given by ∥N∥∞and L and we call the architecture deep if L > 2\nand shallow if L = 2.\nThe underlying directed acyclic graph of FC networks is given by compositions of the aﬃne linear maps\nx 7→W (ℓ)x + b(ℓ), ℓ∈[L], with the activation function ϱ intertwined, see Figure 1.1. Typical activation\n5\nx1\nx2\nx3\nΦ(1)\n1\nΦ(1)\n2\nΦ(1)\n3\nΦ(1)\n4\nx 7→W (1)x + b(1)\n¯Φ(1)\n1\n¯Φ(1)\n2\n¯Φ(1)\n3\n¯Φ(1)\n4\nϱ\nΦ(2)\n1\nΦ(2)\n2\nΦ(2)\n3\nΦ(2)\n4\nΦ(2)\n5\nΦ(2)\n6\nx 7→W (2)x + b(2)\n¯Φ(2)\n1\n¯Φ(2)\n2\n¯Φ(2)\n3\n¯Φ(2)\n4\n¯Φ(2)\n5\n¯Φ(2)\n6\nϱ\nΦa\nx 7→W (3)x + b(3)\nFigure 1.1: Graph (grey) and (pre-)activations of the neurons (white) of a deep fully connected feedforward\nneural network Φa : R3 × R53 7→R with architecture a = ((3, 4, 6, 1), ϱ) and parameters θ = ((W (ℓ), b(ℓ))3\nℓ=1.\nfunctions used in practice are variants of the rectiﬁed linear unit (ReLU) given by ϱR(x) := max{0, x} and\nsigmoidal functions ϱ ∈C(R) satisfying ϱ(x) →1 for x →∞and ϱ(x) →0 for x →−∞, such as the logistic\nfunction ϱσ(x) := 1/(1+e−x) (often referred to as the sigmoid function). See also Table 1 for a comprehensive\nlist of widely used activation functions.\nRemark 1.5 (Neural networks). If not further speciﬁed, we will use the term (neural) network, or the\nabbreviation NN, to refer to FC neural networks. Note that many of the architectures used in practice (see\nSection 6) can be written as special cases of Deﬁnition 1.4 where, e.g., speciﬁc parameters are prescribed by\nconstants or shared with other parameters. Furthermore, note that aﬃne linear functions are NNs with depth\nL = 1. We will also consider biasless NNs given by linear mappings without bias vector, i.e., b(ℓ) = 0, ℓ∈[L].\nIn particular, any NN can always be written without bias vectors by redeﬁning\nx →\n\u0014x\n1\n\u0015\n,\n(W (ℓ), b(ℓ)) →\n\u0014\nW (ℓ)\nb(ℓ)\n0\n1\n\u0015\n,\nℓ∈[L −1],\nand\n(W (L), b(L)) →\n\u0002\nW (L)\nb(L)\u0003\n.\nTo enhance readability we will often not specify the underlying architecture a = (N, ϱ) or the parameters θ ∈\nRP (N) and use the term NN to refer to the architecture as well as the realization functions Φa(·, θ): RN0 →RNL\nor Φa : RN0 ×RP (N) →RNL. However, we want to emphasize that one cannot infer the underlying architecture\nor properties like magnitude of parameters solely from these functions as the mapping (a, θ) 7→Φa(·, θ) is\nhighly non-injective. As an example, we can set W (L) = 0 which implies Φa(·, θ) = b(L) for all architectures\na = (N, ϱ) and all values of (W (ℓ), b(ℓ))L−1\nℓ=1 .\nIn view of our considered prediction tasks in Deﬁnition 1.2, this naturally leads to the following hypothesis\nsets of neural networks.\nDeﬁnition 1.6 (Hypothesis sets of neural networks). Let a = (N, ϱ) be a NN architecture with input\ndimension N0 = d, output dimension NL = 1, and measurable activation function ϱ. For regression tasks the\ncorresponding hypothesis set is given by\nFa =\n\b\nΦa(·, θ): θ ∈RP (N)\t\nand for classiﬁcation tasks by\nFa,sgn =\n\b\nsgn(Φa(·, θ)): θ ∈RP (N)\t\n,\nwhere\nsgn(x) :=\n(\n1,\nif x ≥0,\n−1,\nif x < 0.\n6\nName\nGiven as a function of x ∈R by\nPlot\nlinear\nx\nHeaviside / step function\n1(0,∞)(x)\nlogistic / sigmoid\n1\n1+e−x\nrectiﬁed linear unit (ReLU)\nmax{0, x}\npower rectiﬁed linear unit\nmax{0, x}k for k ∈N\nparametric ReLU (PReLU)\nmax{ax, x} for a ≥0, a ̸= 1\nexponential linear unit (ELU)\nx · 1[0,∞)(x) + (ex −1) · 1(−∞,0)(x)\nsoftsign\nx\n1+|x|\ninverse square root linear unit\nx · 1[0,∞)(x) +\nx\n√\n1+ax2 · 1(−∞,0)(x) for a > 0\ninverse square root unit\nx\n√\n1+ax2\nfor a > 0\ntanh\nex−e−x\nex+e−x\narctan\narctan(x)\nsoftplus\nln(1 + ex)\nGaussian\ne−x2/2\nTable 1: List of commonly used activation functions.\n7\nNote that we compose the output of the NN with the sign function in order to obtain functions mapping\nto Y = {−1, 1}. This can be generalized to multi-dimensional classiﬁcation tasks by replacing the sign by an\nargmax function. Given a hypothesis set, a popular learning algorithm is empirical risk minimization (ERM),\nwhich minimizes the average loss on the given training data, as described in the next deﬁnitions.\nDeﬁnition 1.7 (Empirical risk). For training data s = (z(i))m\ni=1 ∈Zm and a function f ∈M(X, Y), we\ndeﬁne the empirical risk by\nbRs(f) := 1\nm\nm\nX\ni=1\nL(f, z(i)).\nDeﬁnition 1.8 (ERM learning algorithm). Given a hypothesis set F, an empirical risk minimization\nalgorithm Aerm chooses4 for training data s ∈Zm a minimizer bfs ∈F of the empirical risk in F, i.e.,\nAerm(s) ∈arg min\nf∈F\nbRs(f).\n(1.2)\nRemark 1.9 (Surrogate loss and regularization). Note that, for classiﬁcation tasks, one needs to optimize\nover non-diﬀerentiable functions with discrete outputs in (1.2). For NN hypothesis sets Fa,sgn one typically\nuses the corresponding hypothesis set for regression tasks Fa to ﬁnd an approximate minimizer bf surr\ns\n∈Fa of\n1\nm\nm\nX\ni=1\nLsurr(f, z(i)),\nwhere Lsurr : M(X, R) × Z →R is a surrogate loss guaranteeing that sgn( bf surr\ns\n) ∈arg minf∈Fa,sgn bRs(f). A\nfrequently used surrogate loss is the logistic loss5 given by\nLsurr(f, z) = log\n\u0010\n1 + e−yf(x)\u0011\n.\nIn various learning tasks one also adds regularization terms to the minimization problem in (1.2), such as\npenalties on the norm of the parameters of the NN, i.e.,\nmin\nθ∈RP (N) bRs(Φa(·, θ)) + α∥θ∥2\n2,\nwhere α ∈(0, ∞) is a regularization parameter. Note that in this case the minimizer depends on the chosen\nparameters θ and not only on the realization function Φa(·, θ), see also Remark 1.5.\nComing back to our initial, informal description of learning in Deﬁnition 1.1, we have now outlined\npotential learning tasks in Deﬁnition 1.2, NN hypothesis sets in Deﬁnition 1.6, a metric for the in-sample\nperformance in Deﬁnition 1.7, and a corresponding learning algorithm in Deﬁnition 1.8. However, we are still\nlacking a mathematical concept to describe the out-of-sample (generalization) performance of our learning\nalgorithm. This question has been intensively studied in the ﬁeld of statistical learning theory, see Section 1\nfor various references.\nIn this ﬁeld one usually establishes a connection between unseen data z and the training data s = (z(i))m\ni=1\nby imposing that z and z(i), i ∈[m], are realizations of independent samples drawn from the same distribution.\nAssumption 1.10 (Independent and identically distributed data). We assume that z(1), . . . , z(m), z are\nrealizations of i.i.d. random variables Z(1), . . . , Z(m), Z.\n4For simplicity, we assume that the minimum is attained which, for instance, is the case if F is a compact topological space\non which b\nRs is continuous. Hypothesis sets of NNs F(N,ϱ) constitute a compact space if, e.g., one chooses a compact parameter\nset P ⊂RP (N) and a continuous activation function ϱ. One could also work with approximate minimizers, see [AB99].\n5This can be viewed as cross-entropy between the label y and the output of f composed with a logistic function ϱσ. In a\nmulti-dimensional setting one can replace the logistic function with a softmax function.\n8\nIn this formal setting, we can compute the average out-of-sample performance of a model. Recall from\nour notation in Section 1.1 that we denote by PZ the image measure of Z on Z, which is the underlying\ndistribution of our training data S = (Z(i))m\ni=1 ∼Pm\nZ and unknown data Z ∼PZ.\nDeﬁnition 1.11 (Risk). For a function f ∈M(X, Y), we deﬁne6 the risk by\nR(f) := E\n\u0002\nL(f, Z)\n\u0003\n=\nZ\nZ\nL(f, z) dPZ(z).\nDeﬁning S := (Z(i))m\ni=1, the risk of a model fS = A(S) is thus given by R(fS) = E\n\u0002\nL(fS, Z)|S\n\u0003\n.\nFor prediction tasks, we can write Z = (X, Y ), such that the input features and labels are given by an\nX-valued random variable X and a Y-valued random variable Y , respectively. Note that for classiﬁcation\ntasks the risk equals the probability of misclassiﬁcation\nR(f) = E[1(−∞,0)(Y f(X))] = P[f(X) ̸= Y ].\nFor noisy data, there might be a positive, lower bound on the risk, i.e., an irreducible error. If the lower\nbound on the risk is attained, one can also deﬁne the notion of an optimal solution to a learning task.\nDeﬁnition 1.12 (Bayes-optimal function). A function f ∗∈M(X, Y) achieving the smallest risk, the\nso-called Bayes risk\nR∗:=\ninf\nf∈M(X,Y) R(f),\nis called a Bayes-optimal function.\nFor the prediction tasks in Deﬁnition 1.2, we can represent the risk of a function with respect to the\nBayes risk and compute the Bayes-optimal function, see, e.g., [CZ07, Propositions 1.8 and 9.3].\nLemma 1.1 (Regression and classiﬁcation risk). For a regression task with V[Y ] < ∞, the risk can be\ndecomposed into\nR(f) = E\n\u0002\n(f(X) −E[Y |X])2\u0003\n+ R∗,\nf ∈M(X, Y),\n(1.3)\nwhich is minimized by the regression function f ∗(x) = E[Y |X = x]. For a classiﬁcation task, the risk can be\ndecomposed into\nR(f) = E\n\u0002\n|E[Y |X]|1(−∞,0)(E[Y |X]f(X))\n\u0003\n+ R∗,\nf ∈M(X, Y),\nwhich is minimized by the Bayes classiﬁer f ∗(x) = sgn(E[Y |X = x]).\nAs our model fS is depending on the random training data S, the risk R(fS) is a random variable and\nwe might aim7 for R(fS) small with high probability or in expectation over the training data. The challenge\nfor the learning algorithm A is to minimize the risk by only using training data but without knowing the\nunderlying distribution. One can even show that for every learning algorithm there exists a distribution\nwhere convergence of the expected risk of fS to the Bayes risk is arbitrarily slow with respect to the number\nof samples m [DGL96, Theorem 7.2].\nTheorem 1.13 (No free lunch). Let am ∈(0, ∞), m ∈N, be a monotonically decreasing sequence with\na1 ≤1/16. Then for every learning algorithm A of a classiﬁcation task there exists a distribution PZ such\nthat for every m ∈N and training data S ∼Pm\nZ it holds that\nE\n\u0002\nR(A(S))\n\u0003\n≥R∗+ am.\n6Note that this requires z 7→L(f, z) to be measurable for every f ∈M(X, Y), which is the case for our considered prediction\ntasks.\n7In order to make probabilistic statements on R(fS) we assume that R(fS) is a random variable, i.e., measurable. This is,\ne.g., the case if F constitutes a measurable space and s 7→A(s) and f →R|F are measurable.\n9\nFigure 1.2: Illustration of the errors (A)–(C) in the decomposition of (1.4). It shows an exemplary risk bR\n(blue) and empirical risk bRs (red) with respect to the projected space of measurable functions M(X, Y).\nNote that the empirical risk and thus εgen and εopt depend on the realization s = (z(i))m\ni=1 of the training\ndata S ∼Pm\nZ .\nTheorem 1.13 shows the non-existence of a universal learning algorithm for every data distribution PZ and\nshows that useful bounds must necessarily be accompanied by a priori regularity conditions on the underlying\ndistribution PZ. Such prior knowledge can then be incorporated in the choice of the hypothesis set F. To\nillustrate this, let f ∗\nF ∈arg minf∈F R(f) be a best approximation in F, such that we can bound the error\nR(fS) −R∗= R(fS) −bRS(fS) + bRS(fS) −bRS(f ∗\nF) + bRS(f ∗\nF) −R(f ∗\nF) + R(f ∗\nF) −R∗\n≤εopt + 2εgen + εapprox\n(1.4)\nby\n(A) an optimization error εopt := bRS(fS) −bRS( bfS) ≥bRS(fS) −bRS(f ∗\nF), with bfS as in Deﬁnition 1.8,\n(B) a (uniform8) generalization error εgen := supf∈F |R(f) −bRS(f)| ≥max{R(fS) −bRS(fS), bRS(f ∗\nF) −\nR(f ∗\nF)}, and\n(C) an approximation error εapprox := R(f ∗\nF) −R∗,\nsee also Figure 1.2. The approximation error is decreasing when enlarging the hypothesis set, but taking\nF = M(X, Y) prevents controlling the generalization error, see also Theorem 1.13. This suggests a sweet-spot\nfor the complexity of our hypothesis set F and is usually referred to as the bias-variance trade-oﬀ, see\nalso Figure 1.4 below. In the next sections, we will sketch mathematical ideas to tackle each of the errors\nin (A)–(C) in the context of deep learning. Observe that we bound the generalization and optimization\nerror with respect to the empirical risk bRS and its minimizer bfS which is motivated by the fact that in\ndeep-learning-based applications one typically tries to minimize variants of bRS.\n1.2.1\nOptimization\nThe ﬁrst error in the decomposition of (1.4) is the optimization error: εopt. This error is primarily inﬂuenced\nby the numerical algorithm A that is used to ﬁnd the model fs in a hypothesis set of NNs for given training\ndata s ∈Zm. We will focus on the typical setting where such an algorithm tries to approximately minimize\nthe empirical risk bRs. While there are many conceivable methods to solve this minimization problem, by\nfar the most common are gradient-based methods. The main reason for the popularity of gradient-based\n8Although this uniform deviation can be a coarse estimate it is frequently considered to allow for the application of uniform\nlaws of large numbers from the theory of empirical processes.\n10\nmethods is that for FC networks as in Deﬁnition 1.4, the accurate and eﬃcient computation of pointwise\nderivatives ∇θΦa(x, θ) is possible by means of automatic diﬀerentiation, a speciﬁc form of which is often\nreferred to as the backpropagation algorithm [Kel60, Dre62, Lin70, RHW86, GW08]. This numerical scheme\nis also applicable in general settings, such as, when the architecture of the NN is given by a general directed\nacyclic graph. Using these pointwise derivatives, one usually attempts to minimize the empirical risk bRs by\nupdating the parameters θ according to a variant of stochastic gradient descent (SGD), which we shall review\nbelow in a general formulation:\nAlgorithm 1: Stochastic gradient descent\nInput\n: Diﬀerentiable function r: Rp →R, sequence of step-sizes ηk ∈(0, ∞), k ∈[K],\nRp-valued random variable Θ(0).\nOutput : Sequence of Rp-valued random variables (Θ(k))K\nk=1.\nfor k = 1, . . . , K do\nLet D(k) be a random variable such that E[D(k)|Θ(k−1)] = ∇r(Θ(k−1));\nSet Θ(k) := Θ(k−1) −ηkD(k);\nend\nIf D(k) is chosen deterministically in Algorithm 1, i.e., D(k) = ∇r(Θ(k−1)), then the algorithm is known as\ngradient descent. To minimize the empirical loss, we apply SGD with r: RP (N) →R set to r(θ) = bRs(Φa(·, θ)).\nMore concretely, one might choose a batch-size m′ ∈N with m′ ≤m and consider the iteration\nΘ(k) := Θ(k−1) −ηk\nm′\nX\nz∈S′\n∇θL(Φa(·, Θ(k−1)), z),\n(1.5)\nwhere S′ is a so-called mini-batch of size |S′| = m′ chosen uniformly9 at random from the training data\ns. The sequence of step-sizes (ηk)k∈N is often called learning rate in this context. Stopping at step K, the\noutput of a deep learning algorithm A is then given by\nfs = A(s) = Φa(·, ¯θ),\nwhere ¯θ can be chosen to be the realization of the last parameter Θ(K) of (1.5) or a convex combination of\n(Θ(k))K\nk=1 such as the mean.\nAlgorithm 1 was originally introduced in [RM51] in the context of ﬁnding the root of a nondecreasing\nfunction from noisy measurements. Shortly afterwards this idea was applied to ﬁnd a unique minimum of a\nLipschitz-regular function that has no ﬂat regions away from the global minimum [KW52].\nIn some regimes, we can guarantee convergence of SGD at least in expectation, see [NY83, NJLS09,\nSSSSS09], [SDR14, Section 5.9], [SSBD14, Chapter 14]. One prototypical convergence guarantee that is found\nin the aforementioned references in various forms is stated below.\nTheorem 1.14 (Convergence of SGD). Let p, K ∈N and let r: Rp ⊃B1(0) →R be diﬀerentiable and\nconvex. Further let (Θ(k))K\nk=1 be the output of Algorithm 1 with initialization Θ(0) = 0, step-sizes ηk = K−1/2,\nk ∈[K], and random variables (D(k))K\nk=1 satisfying that ∥D(k)∥2 ≤1 almost surely for all k ∈[K]. Then\nE[r(¯Θ)] −r(θ∗) ≤\n1\n√\nK\n,\nwhere ¯Θ := 1\nK\nPK\nk=1 Θ(k) and θ∗∈arg minθ∈B1(0) r(θ).\nTheorem 1.14 can be strengthened to yield a faster convergence rate if the convexity is replaced by strict\nconvexity. If r is not convex, then convergence to a global minimum can in general not be guaranteed. In\nfact, in that case, stochastic gradient descent may converge to a local, non-global minimum, see Figure 1.3\nfor an example.\n9We remark that in practice one typically picks S′ by selecting a subset of training data in a way to cover the full training\ndata after one epoch of ⌈m/m′⌉many steps. This, however, does not necessarily yield an unbiased estimator D(k) of ∇θr(Θ(k−1))\ngiven Θ(k−1).\n11\nFigure 1.3: Examples of the dynamics of gradient descent (left) and stochastic gradient descent (right) for an\nobjective function with one non-global minimum next to the global minimum. We see that depending on the\ninitial condition and also on ﬂuctuations in the stochastic part of SGD the algorithm can fail or succeed in\nﬁnding the global minimum.\nMoreover, gradient descent, i.e., the deterministic version of Algorithm 1, will stop progressing if at any\npoint the gradient of r vanishes. This is the case in every stationary point of r. A stationary point is either a\nlocal minimum, a local maximum, or a saddle point. One would expect that if the direction of the step D(k)\nin Algorithm 1 is not deterministic, then the random ﬂuctuations may allow the iterates to escape saddle\npoints. Indeed, results guaranteeing convergence to local minima exist under various conditions on the type\nof saddle points that r admits, [NJLS09, GL13, GHJY15, LSJR16, JKNvW20].\nIn addition, many methods that improve the convergence by, for example, introducing more elaborate\nstep-size rules or a momentum term have been established. We shall not review these methods here, but\ninstead refer to [GBC16, Chapter 8] for an overview.\n1.2.2\nApproximation\nGenerally speaking, NNs, even FC NNs (see Deﬁnition 1.4) with only L = 2 layers, are universal approximators,\nmeaning that under weak conditions on the activation function ϱ they can approximate any continuous\nfunction on a compact set up to arbitrary precision [Cyb89, Fun89, HSW89, LLPS93].\nTheorem 1.15 (Universal approximation theorem). Let d ∈N, let K ⊂Rd be compact, and let ϱ ∈L∞\nloc(R)\nbe an activation function such that the closure of the points of discontinuity of ϱ is a Lebesgue null set.\nFurther let\neF :=\n[\nn∈N\nF((d,n,1),ϱ)\nbe the corresponding set of two-layer NN realizations. Then it holds that C(K) ⊂cl( eF) (where the closure is\ntaken with respect to the topology induced by the L∞(K)-norm) if and only if there does not exist a polynomial\np: R →R with p = ϱ almost everywhere.\nThe theorem can be proven by the theorem of Hahn–Banach, which implies that eF being dense in some\n12\nreal normed vector space S is equivalent to the following condition: For all non-trivial functionals F ∈S′ \\{0}\nfrom the topological dual space of S there exist parameters w ∈Rd and b ∈R such that\nF(ϱ(⟨w, ·⟩+ b)) ̸= 0.\nIn case of S = C(K) we have by the Riesz–Markov–Kakutani representation theorem that S′ is the space of\nsigned Borel measures on K, see [Rud06]. Therefore, Theorem 1.15 holds, if ϱ is such that, for a signed Borel\nmeasure µ,\nZ\nK\nϱ(⟨w, x⟩+ b) dµ(x) = 0\n(1.6)\nfor all w ∈Rd and b ∈R implies that µ = 0. An activation function ϱ satisfying this condition is called\ndiscriminatory. It is not hard to see that any sigmoidal ϱ is discriminatory. Indeed, assume that ϱ satisﬁes (1.6)\nfor all w ∈Rd and b ∈R. Since for every x ∈Rd it holds that ϱ(ax+b) →1(0,∞)(x)+ϱ(b)1{0}(x) for a →∞,\nwe conclude by superposition and passing to the limit that for all c1, c2 ∈R and w ∈Rd, b ∈R\nZ\nK\n1[c1,c2](⟨w, x⟩+ b) dµ(x) = 0.\nRepresenting the exponential function x 7→e−2πix as the limit of sums of elementary functions yields that\nR\nK e−2πi(⟨w,x⟩+b) dµ(x) = 0 for all w ∈Rd, b ∈R. Hence, the Fourier transform of µ vanishes which implies\nthat µ = 0.\nTheorem 1.15 addresses a uniform approximation problem on a general compact set. If we are given a\nﬁnite number of points and only care about good approximation at these points, then one can ask if this\napproximation problem is potentially simpler. Below we see that, if the number of neurons is larger or equal\nto the number of data points, then one can always interpolate, i.e., exactly ﬁt the data on a given ﬁnite\nnumber of points.\nProposition 1.1 (Interpolation). Let d, m ∈N, let x(i) ∈Rd, i ∈[m], with x(i) ̸= x(j) for i ̸= j, let\nϱ ∈C(R), and assume that ϱ is not a polynomial. Then, there exist parameters θ(1) ∈Rm×d × Rm with the\nfollowing property: For every k ∈N and every sequence of labels y(i) ∈Rk, i ∈[m], there exist parameters\nθ(2) = (W (2), 0) ∈Rk×m × Rk for the second layer of the NN architecture a = ((d, m, k), ϱ) such that\nΦa(x(i), (θ(1), θ(2))) = y(i),\ni ∈[m].\nLet us sketch the proof in the following. First, note that Theorem 1.15 also holds for functions g ∈C(K, Rm)\nwith multi-dimensional output by approximating each one-dimensional component x 7→(g(x))i and stacking\nthe resulting networks. Second, one can add an additional row containing only zeros to the weight matrix\nW (1) of the approximating neural network as well as an additional entry to the vector b(1). The eﬀect of\nthis is that we obtain an additional neuron with constant output. Since ϱ ̸= 0, we can choose b(1) such that\nthe output of this neuron is not zero. Therefore, we can include the bias vector b(2) of the second layer\ninto the weight matrix W (2), see also Remark 1.5. Now choose g ∈C(Rm, Rm) to be a function satisfying\ng(x(i)) = e(i), i ∈[m], where e(i) ∈Rm denotes the i-th standard basis vector. By the discussion before there\nexists a neural network architecture ˜a = ((d, n, m), ϱ) and parameters ˜θ = ((f\nW (1),˜b(1)), (f\nW (2), 0)) such that\n∥Φ˜a(·, ˜θ) −g∥L∞(K) < 1\nm,\n(1.7)\nwhere K is a compact set with x(i) ∈K, i ∈[m]. Let us abbreviate the output of the activations in the ﬁrst\nlayer evaluated at the input features by\neA :=\nh\nϱ(f\nW (1)(x(1)) + ˜b(1))) . . . ϱ(f\nW (1)(x(m)) + ˜b(1)))\ni\n∈Rn×m.\nThe equivalence of the max and operator norm and (1.7) establish that\n∥f\nW (2) eA −Im∥op ≤m max\ni,j∈[m]\n\f\f(f\nW (2) eA −Im)i,j\n\f\f = m max\nj∈[m] ∥Φ˜a(x(j), ˜θ) −g(x(j))∥∞< 1,\n13\nwhere Im denotes the m × m identity matrix. Thus, the matrix f\nW (2) eA ∈Rm×m needs to have full rank and\nwe can extract m linearly independent rows from eA resulting in an invertible matrix A ∈Rm×m. Now, we\ndeﬁne the desired parameters θ(1) for the ﬁrst layer by extracting the corresponding rows from f\nW (1) and ˜b(1)\nand the parameters θ(2) of the second layer by\nW (2) :=\n\u0002\ny(1) . . . y(m)\u0003\nA−1 ∈Rk×m.\nThis proves that with any discriminatory activation function we can interpolate arbitrary training data\n(x(i), y(i)) ∈Rd × Rk, i ∈[m], using a two-layer NN with m hidden neurons, i.e., O(m(d + k)) parameters.\nOne can also ﬁrst project the input features to a one-dimensional line where they are separated and then\napply Proposition 1.1 with d = 1. For nearly all activation functions, this can be represented by a three-layer\nNN using only O(d + mk) parameters10.\nBeyond interpolation results, one can obtain a quantitative version of Theorem 1.15 if one knows additional\nregularity properties of the Bayes optimal function f ∗, such as smoothness, compositionality, and symmetries.\nFor surveys on such results, we refer the reader to [DHP20, GRK20]. For instructive purposes, we review one\nsuch result, which can be found in [Mha96, Theorem 2.1], below:\nTheorem 1.16 (Approximation of smooth functions). Let d, k ∈N and p ∈[1, ∞]. Further let ϱ ∈C∞(R)\nand assume that ϱ is not a polynomial. Then there exists a constant c ∈(0, ∞) with the following property: For\nevery n ∈N there exist parameters θ(1) ∈Rn×d × Rn for the ﬁrst layer of the NN architecture a = ((d, n, 1), ϱ)\nsuch that for every g ∈W k,p((0, 1)d) it holds that\ninf\nθ(2)∈R1×n×R ∥Φa(·, (θ(1), θ(2))) −g∥Lp((0,1)d) ≤cn−d\nk ∥g∥W k,p((0,1)d).\nTheorem 1.16 shows that NNs achieve the same optimal approximation rates that, for example, spline-\nbased approximation yields for smooth functions. The idea behind this theorem is based on a strategy that is\nemployed repeatedly throughout the literature. This is the idea of re-approximating classical approximation\nmethods by NNs and thereby transferring the approximation rates of these methods to NNs. In the example\nof Theorem 1.16, approximation by polynomials is used. The idea is that due to the non-vanishing derivatives\nof the activation function11, one can approximate every univariate polynomial via divided diﬀerences of the\nactivation function. Speciﬁcally, accepting unbounded parameter magnitudes, for any activation function\nϱ: R →R which is p-times diﬀerentiable at some point λ ∈R with ϱ(p)(λ) ̸= 0, one can approximate the\nmonomial x 7→xp on a compact set K ⊂R up to arbitrary precision by a ﬁxed-size NN via rescaled p-th\norder diﬀerence quotients as\nlim\nh→0\nsup\nx∈K\n\f\f\f\np\nX\ni=0\n(−1)i\u0000p\ni\n\u0001\nhpϱ(p)(λ)ϱ\n\u0000(p/2 −i)hx + λ\n\u0001\n−xp\f\f\f = 0.\n(1.8)\nLet us end this subsection by clarifying the connection of the approximation results above to the error\ndecomposition of (1.4). Consider, for simplicity, a regression task with quadratic loss. Then, the approximation\nerror εapprox equals a common L2-error\nεapprox = R(f ∗\nF) −R∗(∗)\n=\nZ\nX\n(f ∗\nF(x) −f ∗(x))2 dPX(x)\n(∗)\n= min\nf∈F ∥f −f ∗∥2\nL2(PX)\n≤min\nf∈F ∥f −f ∗∥2\nL∞(X),\nwhere the identities marked by (∗) follow from Lemma 1.1. Hence, Theorem 1.15 postulates that εapprox →0\nfor increasing NN sizes, whereas Theorem 1.16 additionally explains how fast εapprox converges to 0.\n10To avoid the m × d weight matrix (without using shared parameters as in [ZBH+17]) one interjects an approximate one-\ndimensional identity [PV18, Deﬁnition 2.5], which can be arbitrarily well approximated by a NN with architecture a = ((1, 2, 1), ϱ)\ngiven that ϱ′(λ) ̸= 0 for some λ ∈R, see (1.8) below.\n11The Baire category theorem ensures that for a non-polynomial ϱ ∈C∞(R) there exists λ ∈R with ϱ(p)(λ) ̸= 0 for all p ∈N,\nsee, e.g., [Don69, Chapter 10].\n14\n1.2.3\nGeneralization\nTowards bounding the generalization error εgen = supf∈F |R(f) −bRS(f)|, one observes that, for every f ∈F,\nAssumption 1.10 ensures that L(f, Z(i)), i ∈[m], are i.i.d. random variables. Thus, one can make use of\nconcentration inequalities to bound the deviation of the empirical risk bRS(f) = 1\nm\nPm\ni=1 L(f, Z(i)) from its\nexpectation R(f). For instance, assuming boundedness12 of the loss, Hoeﬀding’s inequality [Hoe63] and a\nunion bound directly imply the following generalization guarantee for countable, weighted hypothesis sets F,\nsee, e.g., [BBL03].\nTheorem 1.17 (Generalization bound for countable, weighted hypothesis sets). Let m ∈N, δ ∈(0, 1) and\nassume that F is countable. Further let p be a probability distribution on F and assume that L(f, Z) ∈[0, 1]\nalmost surely for every f ∈F. Then with probability 1−δ (with respect to repeated sampling of Pm\nZ -distributed\ntraining data S) it holds for every f ∈F that\n|R(f) −bRS(f)| ≤\nr\nln(1/p(f)) + ln(2/δ)\n2m\n.\nWhile the weighting p needs to be chosen before seeing the training data, one could incorporate prior\ninformation on the learning algorithm A. For ﬁnite hypothesis sets without prior information, setting\np(f) = 1/|F| for every f ∈F, Theorem 1.17 implies that, with high probability, it holds that\nεgen ≲\nr\nln(|F|)\nm\n.\n(1.9)\nAgain, one notices that, in line with the bias-variance trade-oﬀ, the generalization bound is increasing with\nthe size of the hypothesis set |F|. Although in practice the parameters θ ∈RP (N) of a NN are discretized\naccording to ﬂoating-point arithmetic, the corresponding quantities |Fa| or |Fa,sgn| would be huge and we\nneed to ﬁnd a replacement for the ﬁniteness condition.\nWe will focus on binary classiﬁcation tasks and present a main result of VC theory which is to a great\nextent derived from the work of Vladimir Vapnik and Alexey Chervonenkis [VC71]. While in (1.9) we counted\nthe number of functions in F, we now reﬁne this analysis to the number of functions restricted to a ﬁnite\nsubset of X, given by the growth function\ngrowth(m, F) :=\nmax\n(x(i))m\ni=1∈X m |{f|(x(i))m\ni=1 : f ∈F}|.\nThe growth function can be interpreted as the maximal number of classiﬁcation patterns in {−1, 1}m which\nfunctions in F can realize on m points and thus growth(m, F) ≤2m. The asymptotic behavior of the growth\nfunction is determined by a single intrinsic dimension of our hypothesis set F, the so-called VC-dimension\nVCdim(F) := sup\n\b\nm ∈N ∪{0}: growth(m, F) = 2m\t\n,\nwhich deﬁnes the largest number of points such that F can realize any classiﬁcation pattern, see, e.g., [AB99,\nBBL03]. There exist various results on VC-dimensions of NNs with diﬀerent activation functions, see,\nfor instance, [BH89, KM97, BMM98, Sak99]. We present the result of [BMM98] for piecewise polynomial\nactivation functions ϱ. It establishes a bound on the VC-dimension of hypothesis sets of NNs for classiﬁcation\ntasks F(N,ϱ),sgn that scales, up to logarithmic factors, linear in the number of parameters P(N) and quadratic\nin the number of layers L.\nTheorem 1.18 (VC-dimension of neural network hypothesis sets). Let ϱ be a piecewise polynomial activation\nfunction. Then there exists a constant c ∈(0, ∞) such that for every L ∈N and N ∈NL+1 it holds that\nVCdim(F(N,ϱ),sgn) ≤c\n\u0000P(N)L log(P(N)) + P(N)L2\u0001\n.\n12Note that for our classiﬁcation tasks in Deﬁnition 1.2 it holds that L(f, Z) ∈{0, 1} for every f ∈F. For the regression\ntasks, one typically assumes boundedness conditions, such as |Y | ≤c and supf∈F |f(X)| ≤c almost surely for some c ∈(0, ∞),\nwhich yields that supf∈F |L(f, Z)| ≤4c2.\n15\nGiven (x(i))m\ni=1 ∈X m, there exists a partition of RP (N) such that Φ(x(i), ·), i ∈[m], are polynomials on\neach region of the partition. The proof of Theorem 1.18 is based on bounding the number of such regions\nand the number of classiﬁcation patterns of a set of polynomials.\nA ﬁnite VC-dimension ensures the following generalization bound [Tal94, AB99]:\nTheorem 1.19 (VC-dimension generalization bound). There exists a constant c ∈(0, ∞) with the following\nproperty: For every classiﬁcation task as in Deﬁnition 1.2, every Z-valued random variable Z, and every\nm ∈N, δ ∈(0, 1) it holds with probability 1 −δ (with respect to repeated sampling of Pm\nZ -distributed training\ndata S) that\nsup\nf∈F\n|R(f) −bRS(f)| ≤c\nr\nVCdim(F) + log(1/δ))\nm\n.\nIn summary, using NN hypothesis sets F(N,ϱ),sgn with a ﬁxed depth and piecewise polynomial activation\nϱ for a classiﬁcation task, with high probability it holds that\nεgen ≲\nr\nP(N) log(P(N))\nm\n.\n(1.10)\nIn the remainder of this section we will sketch a proof of Theorem 1.19 and, in doing so, present\nfurther concepts and complexity measures connected to generalization bounds. We start by observing that\nMcDiarmid’s inequality [McD89] ensures that εgen is sharply concentrated around its expectation, i.e., with\nprobability 1 −δ it holds that13\n\f\fεgen −E\n\u0002\nεgen\u0003\f\f ≲\nr\nlog(1/δ)\nm\n.\n(1.11)\nTo estimate the expectation of the uniform generalization error we employ a symmetrization argu-\nment [GZ84]. Deﬁne G := L ◦F := {L(f, ·): f ∈F}, let eS = ( eZ(i))m\ni=1 ∼Pm\nZ be a test data set independent\nof S, and note that R(f) = E[ bReS(f)]. By properties of the conditional expectation and Jensen’s inequality\nit holds that\nE\n\u0002\nεgen\u0003\n= E\nh\nsup\nf∈F\n|R(f) −bRS(f)|\ni\n= E\nh\nsup\ng∈G\n1\nm\n\f\f\nm\nX\ni=1\nE\n\u0002\ng( eZ(i)) −g(Z(i))|S\n\u0003\f\f\ni\n≤E\nh\nsup\ng∈G\n1\nm\n\f\f\nm\nX\ni=1\ng( eZ(i)) −g(Z(i))\n\f\f\ni\n= E\nh\nsup\ng∈G\n1\nm\n\f\f\nm\nX\ni=1\nτi\n\u0000g( eZ(i)) −g(Z(i))\n\u0001\f\f\ni\n≤2E\nh\nsup\ng∈G\n1\nm\n\f\f\nm\nX\ni=1\nτig(Z(i))\n\f\f\ni\n,\nwhere we used that multiplications with Rademacher variables (τ1, . . . , τm) ∼U({−1, 1}m) only amount\nto interchanging Z(i) with eZ(i) which has no eﬀect on the expectation, since Z(i) and eZ(i) have the same\ndistribution. The quantity\nRm(G) := E\nh\nsup\ng∈G\n\f\f 1\nm\nm\nX\ni=1\nτig(Z(i))\n\f\f\ni\nis called the Rademacher complexity14 of G. One can also prove a corresponding lower bound [vdVW97], i.e.,\nRm(G) −\n1\n√m ≲E\n\u0002\nεgen\u0003\n≲Rm(G).\n(1.12)\n13For precise conditions to ensure that the expectation of εgen is well-deﬁned, we refer the reader to [vdVW97, Dud14].\n14Due to our decomposition in (1.4), we want to uniformly bound the absolute value of the diﬀerence between the risk and\nthe empirical risk. It is also common to just bound supf∈F R(f) −b\nRS(f) leading to a deﬁnition of the Rademacher complexity\nwithout the absolute values which can be easier to deal with.\n16\nNow we use a chaining method to bound the Rademacher complexity of F by covering numbers on diﬀerent\nscales. Speciﬁcally, Dudley’s entropy integral [Dud67, LT91] implies that\nRm(G) ≲E\nh Z ∞\n0\nr\nlog Nα(G, dS)\nm\ndα\ni\n,\n(1.13)\nwhere\nNα(G, dS) := inf\nn\n|G|: G ⊂G, G ⊂\n[\ng∈G\nBdS\nα (g)\no\ndenotes the covering number with respect to the (random) pseudometric given by\ndS(f, g) = d(Z(i))m\ni=1(f, g) :=\nv\nu\nu\nt 1\nm\nm\nX\ni=1\n\u0000f(Z(i)) −g(Z(i))\n\u00012.\nFor the 0-1 loss L(f, z) = 1(−∞,0)(yf(x)) = (1 −f(x)y)/2, we can get rid of the loss function by the fact that\nNα(G, dS) = N2α(F, d(X(i))m\ni=1).\n(1.14)\nThe proof is completed by combining the inequalities in (1.11), (1.12), (1.13) and (1.14) with a result of\nDavid Haussler [Hau95] which shows that for α ∈(0, 1) we have\nlog(Nα(F, d(X(i))m\ni=1)) ≲VCdim(F) log(1/α).\n(1.15)\nWe remark that this resembles a typical behavior of covering numbers. For instance, the logarithm of the\ncovering number log(Nα(M)) of a compact d-dimensional Riemannian manifold M essentially scales like\nd log(1/α). Finally, note that there exists a similar bound to the one in (1.15) for bounded regression tasks\nmaking use of the so-called fat-shattering dimension [MV03, Theorem 1].\n1.3\nDo we need a new theory?\nDespite the already substantial insight that the classical theories provide, a lot of open questions remain. We\nwill outline these questions below. The remainder of this article then collects modern approaches to explain\nthe following issues:\nWhy do large neural networks not overﬁt?\nIn Subsection 1.2.2, we have observed that three-layer\nNNs with commonly used activation functions and only O(d + m) parameters can interpolate any training\ndata (x(i), y(i)) ∈Rd ×R, i ∈[m]. While this speciﬁc representation might not be found in practice, [ZBH+17]\nindeed trained convolutional15 NNs with ReLU activation function and about 1.6 million parameters to\nachieve zero empirical risk on m = 50000 training images of the CIFAR10 dataset [KH09] with 32 × 32 pixels\nper image, i.e., d = 1024. For such large NNs, generalization bounds scaling with the number of parameters\nP(N) as the VC-dimension bound in (1.10) are vacuous. However, they observed close to state-of-the-art\ngeneralization performance16.\nGenerally speaking, NNs in practice are observed to generalize well despite having more parameters than\ntraining samples (usually referred to as overparametrization) and approximately interpolating the training data\n(usually referred to as overﬁtting). As we cannot perform any better on the training data, there is no trade-oﬀ\nbetween ﬁt to training data and complexity of the hypothesis set F happening, seemingly contradicting\nthe classical bias-variance trade-oﬀof statistical learning theory. This is quite surprising, especially given\nthe following additional empirical observations in this regime, see [NTS14, ZBH+17, NBMS17, BHMM19,\nNKB+20]:\n15The basic deﬁnition of a convolutional NN will be given in Section 6. In [ZBH+17] more elaborate versions such as an\nInception architecture [SLJ+15] are employed.\n16In practice one usually cannot measure the risk R(fs) and instead evaluates the performance of a trained model fs by\nb\nR˜s(fs) using test data ˜s, i.e., realizations of i.i.d. random variables distributed according to PZ and drawn independently of the\ntraining data. In this context one often calls Rs(fs) the training error and R˜s(fs) the test error.\n17\n0\n6\n12\n18\nd\n0.00\n0.05\n0.10\nlinear regression (\n= 0)\ntest\ntrain\n0\n20\n40\nd\n10\n10\n10\n1\n108\n0\n6\n12\n18\nd\n0.00\n0.05\n0.10\nridge regression (\n= 0.001)\ntest\ntrain\n0\n20\n40\nd\n10\n2\n10\n1\n0.5\n0.0\n0.5\nx\n0\n1\n2\nd = 40\n= 0\n= 0.001\nf *\ntraining data\nFigure 1.4: The ﬁrst plot (and its semi-log inset) shows median and interquartile range of the test and training\nerrors of ten independent linear regressions with m = 20 samples, polynomial input features X = (1, Z, . . . , Zd)\nof degree d ∈[40], and labels Y = f ∗(Z) + ν, where Z ∼U([−0.5, 0.5]), f ∗is a polynomial of degree three,\nand ν ∼N(0, 0.01). This clearly reﬂects the classical u-shaped bias-variance curve with a sweet-spot at d = 3\nand drastic overﬁtting beyond the interpolation threshold at d = 20. However, the second plot shows that\nwe can control the complexity of our hypothesis set of linear models by restricting the Euclidean norm of\ntheir parameters using ridge regression with a small regularization parameter α = 10−3, i.e., minimizing\nthe regularized empirical risk\n1\nm\nPm\ni=1(Φ(X(i), θ) −Y (i))2 + α∥θ∥2\n2, where Φ(·, θ) = ⟨θ, ·⟩. Corresponding\nexamples of bfs are depicted in the last plot.\n1. Zero training error on random labels: Zero empirical risk can also be achieved for random labels using\nthe same architecture and training scheme with only slightly increased training time: This suggests\nthat the considered hypothesis set of NNs F can ﬁt arbitrary binary labels, which would imply that\nVCdim(F) ≈m or Rm(F) ≈1 rendering our uniform generalization bounds in Theorem 1.19 and\nin (1.12) vacuous.\n2. Lack of explicit regularization: The test error depends only mildly on explicit regularization like norm-\nbased penalty terms or dropout (see [G´er17] for an explanation of diﬀerent regularization methods): As\nsuch regularization methods are typically used to decrease the complexity of F, one might ask if there\nis any implicit regularization (see Figure 1.4), constraining the range of our learning algorithm A to\nsome smaller, potentially data-dependent subset, i.e., A(s) ∈eFs ⊊F.\n3. Dependence on the optimization: The same NN trained to zero empirical risk using diﬀerent variants of\nSGD or starting from diﬀerent initializations can exhibit diﬀerent test errors: This indicates that the\ndynamics of gradient descent and properties of the local neighborhood around the model fs = A(s)\nmight be correlated with generalization performance.\n4. Interpolation of noisy training data: One still observes low test error when training up to approximately\nzero empirical risk using a regression (or surrogate) loss on noisy training data. This is particularly\ninteresting, as the noise is captured by the model but seems not to hurt generalization performance.\n5. Further overparametrization improves generalization performance: Further increasing the NN size can\nlead to even lower test error: Together with the previous item, this might ask for a diﬀerent treatment\nof models complex enough to ﬁt the training data. According to the traditional lore “The training error\ntends to decrease whenever we increase the model complexity, that is, whenever we ﬁt the data harder.\nHowever with too much ﬁtting, the model adapts itself too closely to the training data, and will not\ngeneralize well (i.e., have large test error)”, [HTF01]. While this ﬂawlessly describes the situation for\ncertain machine learning tasks (see Figure 1.4), it seems not to be directly applicable here.\nIn summary, this suggests that the generalization performance of NNs depends on an interplay of the data\ndistribution PZ combined with properties of the learning algorithm A, such as the optimization procedure\nand its range. In particular, classical uniform bounds as in Item (B) of our error decomposition might only\n18\ndeliver insuﬃcient explanation, see also [NK19]. The mismatch between predictions of classical theory and\nthe practical generalization performance of deep NNs is often referred to as generalization puzzle. In Section 2\nwe will present possible explanations for this phenomenon.\nWhat is the role of depth?\nWe have seen in Subsection 1.2.2 that NNs can closely approximate every\nfunction if they are suﬃciently wide [Cyb89, Fun89, HSW89]. There are additional classical results that even\nprovide a trade-oﬀbetween the width and the approximation accuracy [CLM94, Mha96, MP99]. In these\nresults, the central concept is the width of a NN. In modern applications, however at least as much focus if\nnot more lies on the depth of the underlying architectures, which can have more than 1000 layers [HZRS16].\nAfter all, the depth of NNs is responsible for the name of deep learning.\nThis consideration begs the question of whether there is a concrete mathematically quantiﬁable beneﬁt of\ndeep architectures over shallow NNs. Indeed, we will see eﬀects of depth at many places throughout this\nmanuscript. However, one of the aspects of deep learning that is most clearly aﬀected by deep architectures\nis the approximation theoretical aspect. In this framework, we will discuss in Section 3 multiple approaches\nthat describe the eﬀect of depth.\nWhy do neural networks perform well in very high-dimensional environments?\nWe have seen\nin Subsection 1.2.2 and will see in Section 3 that from the perspective of approximation theory deep NNs\nmatch the performance of the best classical approximation tool in virtually every task. In practice, we\nobserve something that is even more astounding. In fact, NNs seem to perform incredibly well on tasks that\nno classical, non-specialized approximation method can even remotely handle. The approximation problem\nthat we are talking about here is that of approximation of high-dimensional functions. Indeed, the classical\ncurse of dimensionality [Bel52, NW09] postulates that essentially every approximation method deteriorates\nexponentially fast with increasing dimension.\nFor example, for the uniform approximation error of 1-Lipschitz continuous functions on a d-dimensional\nunit cube in the uniform norm, we have a lower bound of Ω(p−1/d), for p →∞, when approximating with a\ncontinuous scheme17 of p free parameters [DeV98].\nOn the other hand, in most applications, the input dimensions are massive. For example, the following\ndatasets are typically used as benchmarks in image classiﬁcation problems: MNIST [LBBH98] with 28 × 28\npixels per image, CIFAR-10/CIFAR-100 [KH09] with 32×32 pixels per image and ImageNet [DDS+09, KSH12]\nwhich contains high-resolution images that are typically down-sampled to 256 × 256 pixels. Naturally, in\nreal-world applications, the input dimensions may well exceed those of these test problems. However, already\nfor the simplest of the test cases above, the input dimension is d = 784. If we use d = 784 in the aforementioned\nlower bound for the approximation of 1-Lipschitz functions, then we require O(ε−784) parameters to achieve\na uniform error of ε ∈(0, 1). Already for moderate ε this value will quickly exceed the storage capacity\nof any conceivable machine in this universe. Considering the aforementioned curse of dimensionality, it is\npuzzling to see that NNs perform adequately in this regime. In Section 4, we describe three approaches that\noﬀer explanations as to why deep NN-based approximation is not rendered meaningless in the context of\nhigh-dimensional input dimensions.\nWhy does stochastic gradient descent converge to good local minima despite the non-convexity\nof the problem?\nAs mentioned in Subsection 1.2.1, a convergence guarantee of stochastic gradient descent\nto a global minimum is typically only given if the underlying objective function admits some form of convexity.\nHowever, the empirical risk of a NN, i.e., bRs(Φ(·, θ)), is typically not a convex function with respect to the\nparameters θ. For a simple intuitive reason why this function fails to be convex, it is instructive to consider\nthe following example.\n17One can achieve better rates at the cost of discontinuous (with respect to the function to be approximated) parameter\nassignment. This can be motivated by the use of space-ﬁlling curves. In the context of NNs with piecewise polynomial activation\nfunctions, a rate of p−2/d can be achieved by very deep architectures [Yar18a, YZ20].\n19\nFigure 1.5: Two-dimensional projection of the loss landscape of a neural network with four layers and ReLU\nactivation function on four diﬀerent scales. From top-left to bottom-right, we zoom into the global minimum\nof the landscape.\nExample 1.20. Consider the NN\nΦ(x, θ) = θ1ϱR(θ3x + θ5) + θ2ϱR(θ4x + θ6),\nθ ∈R6,\nx ∈R,\nwith the ReLU activation function ϱR(x) = max{0, x}. It is not hard to see that the two parameter values\nθ = (1, −1, 1, 1, 1, 0) and ¯θ = (−1, 1, 1, 1, 0, 1) produce the same realization function18, i.e., Φ(·, θ) = Φ(·, ¯θ).\nHowever, since (θ + ¯θ)/2 = (0, 0, 1, 1, 1/2, 1/2), we conclude that Φ(·, (θ + ¯θ)/2) = 0. Clearly, for the data\ns = ((−1, 0), (1, 1)), we now have that\nbRs(Φ(·, θ)) = bRs(Φ(·, ¯θ)) = 0\nand\nbRs\n\u0000Φ(·, (θ + ¯θ)/2)\n\u0001\n= 1\n2,\nshowing the non-convexity of bRs.\n18This corresponds to interchanging the two neurons in the hidden layer. In general it holds that the realization function of a\nFC NN is invariant under permutations of the neurons in a given hidden layer.\n20\nGiven this non-convexity, Algorithm 1 faces serious challenges. Firstly, there may exist multiple suboptimal\nlocal minima. Secondly, the objective may exhibit saddle points, some of which may be of higher order, i.e.,\nthe Hessian vanishes. Finally, even if no suboptimal local minima exist, there may be extensive areas of the\nparameter space where the gradient is very small, so that escaping these regions can take a very long time.\nThese issues are not mere theoretical possibilities, but will almost certainly arise. For example, [AHW96,\nSS18] show the existence of many suboptimal local minima in typical learning tasks. Moreover, for ﬁxed-sized\nNNs, it has been shown in [BEG19, PRV20], that with respect to Lp-norms the set of NNs is generally a\nvery non-convex and non-closed set. Also, the map θ 7→Φa(·, θ) is not a quotient map, i.e., not continuously\ninvertible when accounting for its non-injectivity. In addition, in various situations ﬁnding the global optimum\nof the minimization problem is shown to be NP-hard in general [BR89, Jud90, ˇS´ım02]. In Figure 1.5 we\nshow the two-dimensional projection of a loss landscape, i.e., the projection of the graph of the function\nθ 7→bRs(Φ(·, θ)). It is apparent from the visualization that the problem exhibits more than one minimum.\nWe also want to add that in practice one neglects that the loss is only almost everywhere diﬀerentiable in\ncase of piecewise smooth activation functions, such as the ReLU, although one could resort to subgradient\nmethods [KL18].\nIn view of these considerations, the classical framework presented in Subsection 1.2.1 oﬀers no explanation\nas to why deep learning works in practice. Indeed, in the survey [OM98, Section 1.4] the state of the art in\n1998 was summarized by the following assessment: “There is no formula to guarantee that (1) the NN will\nconverge to a good solution, (2) convergence is swift, or (3) convergence even occurs at all.”\nNonetheless, in applications, not only would an explanation of when and why SGD converges be extremely\ndesirable, convergence is also quite often observed even though there is little theoretical explanation for it in\nthe classical set-up. In Section 5, we collect modern approaches explaining why and when convergence occurs\nand can be guaranteed.\nWhich aspects of a neural network architecture aﬀect the performance of deep learning?\nIn\nthe introduction to classical approaches to deep learning above, we have seen that in classical results, such as\nin Theorem 1.16, only the eﬀect of few aspects of the NN architectures are considered. In Theorem 1.16 only\nthe impact of the width of the NN was studied. In further approximation theorems below, e.g., in Theorems 2.1\nand 3.2, we will additionally have a variable depth of NNs. However, for deeper architectures, there are\nmany additional aspects of the architecture that could potentially aﬀect the performance of the model for\nthe associated learning task. For example, even for a standard FC NN with L layers as in Deﬁnition 1.4,\nthere is a lot of ﬂexibility in choosing the number of neurons (N1, . . . , NL−1) ∈NL−1 in the hidden layers.\nOne would expect that certain choices aﬀect the capabilities of the NNs considerably and some choices are\npreferable over others. Note that, one aspect of the neural network architecture that can have a profound\neﬀect on the performance, especially regarding approximation theoretical aspects of the performance, is the\nchoice of the activation function. For example, in [MP99, Yar21] activation functions were found that allow\nuniform approximation of continuous functions to arbitrary accuracy with ﬁxed-size neural networks. In the\nsequel we will, however, focus on architectural aspects other than the activation function.\nIn addition, practitioners have invented an immense variety of NN architectures for speciﬁc problems. These\ninclude NNs with convolutional blocks [LBBH98], with skip connections [HZRS16], sparse connections [ZAP16,\nBBC17], batch normalization blocks [IS15], and many more. In addition, for sequential data, recurrent\nconnections are used [RHW86] and these often have forget mechanisms [HS97] or other gates [CvMG+14]\nincluded in their architectures.\nThe choice of an appropriate NN architecture is essential to the success of many deep learning tasks. This\ngoes so far, that frequently an architecture search is applied to ﬁnd the most suitable one [ZL17, PGZ+18].\nIn most cases, though, the design and choice of the architecture is based on the intuition of the practitioner.\nNaturally, from a theoretical point of view, this situation is not satisfactory. Instead, it would be highly\ndesirable to have a mathematical theory guiding the choice of NN architectures. More concretely, one\nwould wish for mathematical theorems that identify those architectures that work for a speciﬁc problem and\nthose that will yield suboptimal results. In Section 6, we discuss various results that explain theoretically\nquantiﬁable eﬀects of certain aspects or building blocks of NN architectures.\n21\nWhich features of data are learned by deep architectures?\nIt is commonly believed that the neurons\nof NNs constitute feature extractors in diﬀerent levels of abstraction that correspond to the layers. This\nbelief is partially grounded in experimental evidence as well as in drawing connections to the human visual\ncortex, see [GBC16, Chapter 9.10].\nUnderstanding the features that are learned can, in a way, be linked to understanding the reasoning\nwith which a NN-based model ended up with its result. Therefore, analyzing the features that a NN learns\nconstitutes a data-aware approach to understanding deep learning. Naturally, this falls outside of the scope of\nthe classical theory, which is formulated in terms of optimization, generalization, and approximation errors.\nOne central obstacle towards understanding these features theoretically is that, at least for practical\nproblems, the data distribution is unknown. However, one often has partial knowledge. One example is that\nin image classiﬁcation it appears reasonable to assume that any classiﬁer is translation and rotation invariant\nas well as invariant under small deformations. In this context, it is interesting to understand under which\nconditions trained NNs admit the same invariances.\nBiological NNs such as the visual cortex are believed to be evolved in a way that is based on sparse\nmultiscale representations of visual information [OF96]. Again, a fascinating question is whether NNs trained\nin practice can be shown to favor such multiscale representations based on sparsity or if the architecture\nis theoretically linked to sparse representations. We will discuss various approaches studying the features\nlearned by neural networks in Section 7.\nAre neural networks capable of replacing highly specialized numerical algorithms in natural\nsciences?\nShortly after their successes in various data-driven tasks in data science and AI applications,\nNNs have been used also as a numerical ansatz for solving highly complex models from the natural sciences\nwhich may be combined with data driven methods. This per se is not very surprising as many such models\ncan be formulated as optimization problems where the common deep learning paradigm can be directly\napplied. What might be considered surprising is that this approach seems to be applicable to a wide range of\nproblems which have previously been tackled by highly specialized numerical methods.\nParticular successes include the data-driven solution of ill-posed inverse problems [AM¨OS19] which have,\nfor example, led to a fourfold speedup in MRI scantimes [ZKS+18] igniting the research project fastmri.org.\nDeep-learning-based approaches have also been very successful in solving a vast array of diﬀerent partial\ndiﬀerential equation (PDE) models, especially in the high-dimensional regime [EY18, RPK19, HSN20,\nPSMF20] where most other methods would suﬀer from the curse of dimensionality.\nDespite these encouraging applications, the foundational mechanisms governing their workings and\nlimitations are still not well understood. In Subsection 4.3 and Section 8 we discuss some theoretical and\npractical aspects of deep learning methods applied to the solution of inverse problems and PDEs.\n2\nGeneralization of large neural networks\nIn the following, we will shed light on the generalization puzzle of NNs as described in Subsection 1.3. We\nfocus on four diﬀerent lines of research which, of course, do not cover the wide range of available results.\nIn fact, we had to omit a discussion of a multitude of important works, some of which we reference in the\nfollowing paragraph.\nFirst, let us mention extensions of the generalization bounds presented in Subsection 1.2.3 making use\nof local Rademacher complexities [BBM05] or dropping assumptions on boundedness or rapidly decaying\ntails [Men14]. Furthermore, there are approaches to generalization which do not focus on the hypothesis set F,\ni.e., the range of the learning algorithm A, but the way A chooses its model fs. For instance, one can assume\nthat fs does not depend too strongly on each individual sample (algorithmic stability [BE02, PRMN04]),\nonly on a subset of the samples (compression bounds [AGNZ18]), or satisﬁes local properties (algorithmic\nrobustness [XM12]). Finally, we refer the reader to [JNM+20] and the references mentioned therein for an\nempirical study of various measures related to generalization.\nNote that many results on generalization capabilities of NNs can still only be proven in simpliﬁed settings,\ne.g., for deep linear NNs, i.e., ϱ(x) = x, or basic linear models, i.e., one-layer NNs. Thus, we start by\n22\nemphasizing the connection of deep, nonlinear NNs to linear models (operating on features given by a suitable\nkernel) in the inﬁnite width limit.\n2.1\nKernel regime\nWe consider a one-dimensional prediction setting where the loss L(f, (x, y)) depends on x ∈X only through\nf(x) ∈Y, i.e., there exists a function ℓ: Y × Y →R such that\nL(f, (x, y)) = ℓ(f(x), y).\nFor instance, in case of the quadratic loss we have that ℓ(ˆy, y) = (ˆy −y)2. Further, let Φ be a NN with\narchitecture (N, ϱ) = ((d, N1, . . . , NL−1, 1), ϱ) and let Θ0 be a RP (N)-valued random variable. For simplicity,\nwe evolve the parameters of Φ according to the continuous version of gradient descent, so-called gradient ﬂow,\ngiven by\ndΘ(t)\ndt\n= −∇θ bRs(Φ(·, Θ(t))) = −1\nm\nm\nX\ni=1\n∇θΦ(x(i), Θ(t))Di(t),\nΘ(0) = Θ0,\n(2.1)\nwhere Di(t) := ∂ℓ(ˆy,y(i))\n∂ˆy\n|ˆy=Φ(x(i),Θ(t)) is the derivative of the loss with respect to the prediction at input\nfeature x(i) at time t ∈[0, ∞). The chain rule implies the following dynamics of the NN realization\ndΦ(·, Θ(t))\ndt\n= −1\nm\nm\nX\ni=1\nKΘ(t)(·, x(i))Di(t)\n(2.2)\nand its empirical risk\nd bRs(Φ(·, Θ(t))\ndt\n= −1\nm2\nm\nX\ni=1\nm\nX\nj=1\nDi(t)KΘ(t)(x(i), x(j))Dj(t),\n(2.3)\nwhere Kθ, θ ∈RP (N), is the so-called neural tangent kernel (NTK)\nKθ : Rd × Rd →R,\nKθ(x1, x2) =\n\u0000∇θΦ(x1, θ)\n\u0001T ∇θΦ(x2, θ).\n(2.4)\nNow let σw, σb ∈(0, ∞) and assume that the initialization Θ0 consists of independent entries, where entries\ncorresponding to the weight matrix and bias vector in the ℓ-th layer follow a normal distribution with\nzero mean and variances σ2\nw/Nℓand σ2\nb, respectively. Under weak assumptions on the activation function,\nthe central limit theorem implies that the pre-activations converge to i.i.d. centered Gaussian processes in\nthe inﬁnite width limit N1, . . . , NL−1 →∞, see [LBN+18, MHR+18]. Similarly, also KΘ0 converges to a\ndeterministic kernel K∞which stays constant in time and only depends on the activation function ϱ, the\ndepth L, and the initialization parameters σw and σb [JGH18, ADH+19, Yan19, LXS+20]. Thus, within the\ninﬁnite width limit, gradient ﬂow on the NN parameters as in (2.1) is equivalent to functional gradient ﬂow\nin the reproducing kernel Hilbert space (HK∞, ∥· ∥K∞) corresponding to K∞, see (2.2).\nBy (2.3), the empirical risk converges to a global minimum as long as the kernel evaluated at the input\nfeatures, ¯K∞:= (K∞(x(i), x(j)))m\ni,j=1 ∈Rm×m, is positive deﬁnite (see, e.g., [JGH18, DLL+19] for suitable\nconditions) and the ℓ(·, y(i)) are convex and lower bounded. For instance, in case of the quadratic loss the\nsolution of (2.2) is then given by\nΦ(·, Θ(t)) = C(t)(y(i))m\ni=1 +\n\u0000Φ(·, Θ0) −C(t)(Φ(x(i), Θ0))m\ni=1\n\u0001\n,\n(2.5)\nwhere C(t) :=\n\u0000(K∞(·, x(i)))m\ni=1\n\u0001T ( ¯K∞)−1(Im −e−2 ¯\nK∞t\nm\n). As the initial realization Φ(·, Θ0) constitutes a\ncentered Gaussian process, the second term in (2.5) follows a normal distribution with zero mean at each\ninput. In the limit t →∞, its variance vanishes on the input features x(i), i ∈[m], and the ﬁrst term\nconvergences to the minimum kernel-norm interpolator, i.e., to the solution of\nmin\nf∈HK∞∥f∥K∞\ns.t.\nf(x(i)) = y(i).\n23\nTherefore, within the inﬁnite width limit, the generalization properties of the NN could be described by the\ngeneralization properties of the minimizer in the reproducing kernel Hilbert space corresponding to the kernel\nK∞[BMM18, LR20, LRZ20, GMMM21, Li21].\nThis so-called lazy training, where a NN essentially behaves like a linear model with respect to the nonlinear\nfeatures x 7→∇θΦ(x, θ), can already be observed in the non-asymptotic regime, see also Subsection 5.2. For\nsuﬃciently overparametrized (P(N) ≫m) and suitably initialized models, one can show that Kθ(0) is close\nto K∞at initialization and Kθ(t) stays close to Kθ(0) throughout training, see [DZPS18, ADH+19, COB19,\nDLL+19]. The dynamics of the NN under gradient ﬂow in (2.2) and (2.3) can thus be approximated by the\ndynamics of the linearization of Φ at initialization Θ0, given by\nΦlin(·, θ) := Φ(·, Θ0) + ⟨∇θΦ(·, Θ0), θ −Θ0⟩,\nwhich motivates to study the behavior of linear models in the overparametrized regime.\n2.2\nNorm-based bounds and margin theory\nFor piecewise linear activation functions, one can improve upon the VC-dimension bounds in Theorem 1.18\nand show that, up to logarithmic factors, the VC-dimension is asymptotically bounded both above and below\nby P(N)L, see [BHLM19]. The lower bound shows that the generalization bound in Theorem 1.19 can only\nbe non-vacuous if the number of samples m scales at least linearly with the number of NN parameters P(N).\nHowever, heavily overparametrized NNs used in practice seem to generalize well outside of this regime.\nOne solution is to bound other complexity measures of NNs taking into account various norms on the\nparameters and avoid the direct dependence on the number of parameters [Bar98]. For instance, we can\ncompute bounds on the Rademacher complexity of NNs with positively homogeneous activation function,\nwhere the Frobenius norm of the weight matrices is bounded, see also [NTS15]. Note that, for instance,\nthe ReLU activation is positively homogeneous, i.e., it satisﬁes that ϱR(λx) = λϱR(x) for all x ∈R and\nλ ∈(0, ∞).\nTheorem 2.1 (Rademacher complexity of neural networks). Let d ∈N, assume that X = B1(0) ⊂Rd, and\nlet ϱ be a positively homogeneous activation function with Lipschitz constant 1. We deﬁne the set of all\nbiasless NN realizations with depth L ∈N, output dimension 1, and Frobenius norm of the weight matrices\nbounded by C ∈(0, ∞) as\neFL,C :=\n\b\nΦ(N,ϱ)(·, θ): N ∈NL+1, N0 = d, NL = 1, θ = ((W (ℓ), 0))L\nℓ=1 ∈RP (N), ∥W (ℓ)∥F ≤C\n\t\n.\nThen for every m ∈N it holds that\nRm( eFL,C) ≤C(2C)L−1\n√m\n.\nThe term 2L−1 depending exponentially on the depth can be reduced to\n√\nL or completely omitted\nby invoking also the spectral norm of the weight matrices [GRS18].\nFurther, observe that for L = 1,\ni.e., linear classiﬁers with bounded Euclidean norm, this bound is independent of the input dimension d.\nTogether with (1.12), this motivates why the regularized linear model in Figure 1.4 did perform well in the\noverparametrized regime.\nThe proof of Theorem 2.1 is based on the contraction property of the Rademacher complexity [LT91]\nwhich establishes that\nRm(ϱ ◦eFℓ,C) ≤2Rm( eFℓ,C),\nℓ∈N.\nWe can iterate this together with the fact that for every τ ∈{−1, 1}m, and x ∈RNℓ−1 it holds that\nsup\n∥W (ℓ)∥F ≤C\n\r\r\nm\nX\ni=1\nτiϱ(W (ℓ)x)\n\r\r\n2 = C\nsup\n∥w∥2≤1\n\f\f\nm\nX\ni=1\nτiϱ(⟨w, x⟩)\n\f\f.\n24\nIn summary, one establishes that\nRm( eFL,C) = C\nmE\n\u0002\nsup\nf∈e\nFL−1,C\n\r\r\nm\nX\ni=1\nτiϱ(f(X(i)))\n\r\r\n2\n\u0003\n≤C(2C)L−1\nm\nE\n\u0002\r\r\nm\nX\ni=1\nτiX(i)\r\r\n2\n\u0003\n,\nwhich by Jensen’s inequality yields the claim.\nRecall that for classiﬁcation problems one typically minimizes a surrogate loss Lsurr, see Remark 1.9.\nThis suggests that there could be a trade-oﬀhappening between complexity of the hypothesis class Fa and\nthe corresponding regression ﬁt underneath, i.e., the margin M(f, z) := yf(x) by which a training example\nz = (x, y) has been classiﬁed correctly by f ∈Fa, see [BFT17, NBS18, JKMB19]. For simplicity, let us focus\non the ramp surrogate loss with conﬁdence γ > 0, i.e., Lsurr\nγ\n(f, z) := ℓγ(M(f, z)), where\nℓγ(t) := 1(−∞,γ](t) −t\nγ 1[0,γ](t),\nt ∈R.\nNote that the ramp function ℓγ is 1/γ-Lipschitz continuous. Using McDiarmid’s inequality and a sym-\nmetrization argument similar to the proof of Theorem 1.19, combined with the contraction property of the\nRademacher complexity, yields the following bound on the probability of misclassiﬁcation: With probability\n1 −δ for every f ∈Fa it holds that\nP[sgn(f(X)) ̸= Y ] ≤E\n\u0002\nLsurr\nγ\n(f, Z)\n\u0003\n≲1\nm\nm\nX\ni=1\nLsurr\nγ\n(f, Z(i)) + Rm(Lsurr\nγ\n◦Fa) +\nr\nln(1/δ)\nm\n≲1\nm\nm\nX\ni=1\n1(−∞,γ)(Y (i)f(X(i))) + Rm(M ◦Fa)\nγ\n+\nr\nln(1/δ)\nm\n= 1\nm\nm\nX\ni=1\n1(−∞,γ)(Y (i)f(X(i))) + Rm(Fa)\nγ\n+\nr\nln(1/δ)\nm\n.\nThis shows the trade-oﬀbetween the complexity of Fa measured by Rm(Fa) and the fraction of training\ndata that has been classiﬁed correctly with a margin of at least γ. In particular this suggests, that (even if\nwe classify the training data correctly with respect to the 0-1 loss) it might be beneﬁcial to further increase\nthe complexity of Fa to simultaneously increase the margins by which the training data has been classiﬁed\ncorrectly and thus obtain a better generalization bound.\n2.3\nOptimization and implicit regularization\nThe optimization algorithm, which is usually a variant of SGD, seems to play an important role for the\ngeneralization performance. Potential indicators for good generalization performance are high speed of\nconvergence [HRS16] or ﬂatness of the local minimum to which SGD converged, which can be characterized\nby the magnitude of the eigenvalues of the Hessian (or approximately as the robustness of the minimizer\nto adversarial perturbations on the parameter space), see [KMN+17]. In [DR17, NBMS17] generalization\nbounds depending on a concept of ﬂatness are established by employing a PAC-Bayesian framework, which\ncan be viewed as a generalization of Theorem 1.17, see [McA99]. Further, one can also unite ﬂatness and\nnorm-based bounds by the Fisher–Rao metric of information geometry [LPRS19].\nLet us motivate the link between generalization and ﬂatness in the case of simple linear models: We\nassume that our model takes the form ⟨θ, ·⟩, θ ∈Rd, and we will use the abbreviations\nr(θ) := bRs(⟨θ, ·⟩)\nand\nγ(θ) := min\ni∈[m] M(⟨θ, ·⟩, z(i)) = min\ni∈[m] y(i)⟨θ, x(i)⟩\nthroughout this subsection to denote the empirical risk and the margin for given training data s =\n((x(i), y(i)))m\ni=1. We assume that we are solving a classiﬁcation task with the 0-1 loss and that our training\n25\ndata is linearly separable. This means that there exists a minimizer ˆθ ∈Rd such that r(ˆθ) = 0. We observe\nthat δ-robustness in the sense that\nmax\nθ∈Bδ(0) r(ˆθ + θ) = r(ˆθ) = 0\nimplies that\n0 < min\ni∈[m] y(i)⟨ˆθ −δy(i)\nx(i)\n∥x(i)∥2 , x(i)⟩≤γ(ˆθ) −δ min\ni∈[m] ∥x(i)∥2,\nsee also [PKL+17]. This lower bound on the margin γ(ˆθ) then ensures generalization guarantees as described\nin Subsection 2.2.\nEven without explicit19 control on the complexity of Fa, there do exist results showing that SGD acts as\nimplicit regularization [NTS14]. This is motivated by linear models where SGD converges to the minimal\nEuclidean norm solution for the quadratic loss and in the direction of the hard margin support vector machine\nsolution for the logistic loss on linearly separable data [SHN+18]. Note that convergence to minimum norm\nor maximum margin solutions in particular decreases the complexity of our hypothesis set and thus improves\ngeneralization bounds, see Subsection 2.2.\nWhile we have seen this behavior of gradient descent for linear regression already in the more general\ncontext of kernel regression in Subsection 2.1, we want to motivate the corresponding result for classiﬁcation\ntasks in the following. We focus on the exponential surrogate loss Lsurr(f, z) = ℓ(M(f, z)) = e−yf(x) with\nℓ(z) = e−z, but similar observations can be made for the logistic loss deﬁned in Remark 1.9. We assume that\nthe training data is linearly separable, which guarantees the existence of ˆθ ̸= 0 with γ(ˆθ) > 0. Then for every\nlinear model ⟨θ, ·⟩, θ ∈Rd, it holds that\n\nˆθ, ∇θr(θ)⟩= 1\nm\nm\nX\ni=1\nℓ′(y(i)⟨θ, x(i)⟩)\n|\n{z\n}\n<0\ny(i)⟨ˆθ, x(i)⟩\n|\n{z\n}\n>0\n.\nA critical point ∇θr(θ) = 0 can therefore be approached if and only if for every i ∈[m] we have\nℓ′(y(i)⟨θ, x(i)⟩) = −e−y(i)⟨θ,x(i)⟩→0,\nwhich is equivalent to ∥θ∥2 →∞and γ(θ) > 0. Let us now deﬁne\nrβ(θ) := ℓ−1(r(βθ))\nβ\n,\nθ ∈Rd, β ∈(0, ∞),\nand observe that\nrβ(θ) = −log(r(βθ))\nβ\n→γ(θ),\nβ →∞.\n(2.6)\nDue to this property, rβ is often referred to as the smoothed margin [LL19, JT19b]. We evolve θ according to\ngradient ﬂow with respect to the smoothed margin r1, i.e.,\ndθ(t)\ndt\n= ∇θr1(θ(t)) = −\n1\nr(θ(t))∇θr(θ(t)),\nwhich produces the same trajectory as gradient ﬂow with respect to the empirical risk r under a rescaling\nof the time t. Looking at the evolution of the normalized parameters ˜θ(t) = θ(t)/∥θ(t)∥2, the chain rule\nestablishes that\nd˜θ(t)\ndt\n= P˜θ(t)\n∇θrβ(t)(˜θ(t))\nβ(t)\nwith\nβ(t) := ∥θ(t)∥2\nand\nPθ := Id −θθT ,\nθ ∈Rd.\n19Note that also diﬀerent architectures can exhibit vastly diﬀerent inductive biases [ZBH+20] and also within the architecture\ndiﬀerent parameters have diﬀerent importance, see [FC18, ZBS19] and Proposition 6.2.\n26\nThis shows that the normalized parameters perform projected gradient ascent with respect to the function\nrβ(t), which converges to the margin due to (2.6) and the fact that β(t) = ∥θ(t)∥2 →∞when approaching a\ncritical point. This motivates that during gradient ﬂow the normalized parameters implicitly maximize the\nmargin. See [GLSS18a, GLSS18b, LL19, NLG+19, CB20, JT20] for a precise analysis and various extensions,\ne.g., to homogeneous or two-layer NNs and other optimization geometries.\nTo illustrate one research direction, we present an exemplary result in the following. Let Φ = Φ(N,ϱ) be\na biasless NN with parameters θ = ((W (ℓ), 0))L\nℓ=0 and output dimension NL = 1. For given input features\nx ∈RN0, the gradient ∇W (ℓ)Φ = ∇W (ℓ)Φ(x, θ) ∈RNℓ−1×Nℓwith respect to the weight matrix in the ℓ-th\nlayer satisﬁes that\n∇W (ℓ)Φ = ϱ(Φ(ℓ−1))\n∂Φ\n∂Φ(ℓ+1)\n∂Φ(ℓ+1)\n∂Φ(ℓ)\n= ϱ(Φ(ℓ−1))\n∂Φ\n∂Φ(ℓ+1) W (ℓ+1) diag\n\u0000ϱ′(Φ(ℓ))\n\u0001\n,\nwhere the pre-activations (Φ(ℓ))L\nℓ=1 are given as in (1.1). Evolving the parameters according to gradient ﬂow\nas in (2.1) and using an activation function ϱ with ϱ(x) = ϱ′(x)x, such as the ReLU, this implies that\ndiag\n\u0000ϱ′(Φ(ℓ))\n\u0001\nW (ℓ)(t)\n\u0010dW (ℓ)(t)\ndt\n\u0011T\n=\n\u0010dW (ℓ+1)(t)\ndt\n\u0011T\nW (ℓ+1)(t) diag\n\u0000ϱ′(Φ(ℓ))\n\u0001\n.\n(2.7)\nNote that this ensures the conservation of balancedness between weight matrices of adjacent layers, i.e.,\nd\ndt\n\u0000∥W (ℓ+1)(t)∥2\nF −∥W (ℓ)(t)∥2\nF\n\u0001\n= 0,\nsee [DHL18]. Furthermore, for deep linear NNs, i.e., ϱ(x) = x, the property in (2.7) implies conservation of\nalignment of left and right singular spaces of W (ℓ) and W (ℓ+1). This can then be used to show implicit pre-\nconditioning and convergence of gradient descent [ACH18, ACGH19] and that, under additional assumptions,\ngradient descent converges to a linear predictor that is aligned with the maximum margin solution [JT19a].\n2.4\nLimits of classical theory and double descent\nThere is ample evidence that classical tools from statistical learning theory alone, such as Rademacher\naverages, uniform convergence, or algorithmic stability may be unable to explain the full generalization\ncapabilities of NNs [ZBH+17, NK19]. It is especially hard to reconcile the classical bias-variance trade-oﬀwith\nthe observation of good generalization performance when achieving zero empirical risk on noisy data using a\nregression loss. On top of that, this behavior of overparametrized models in the interpolation regime turns out\nnot to be unique to NNs. Empirically, one observes for various methods (decision trees, random features, linear\nmodels) that the test error decreases even below the sweet-spot in the u-shaped bias-variance curve when\nfurther increasing the number of parameters [BHMM19, GJS+20, NKB+20]. This is often referred to as the\ndouble descent curve or benign overﬁtting, see Figure 2.1. For special cases, e.g., linear regression or random\nfeature regression, such behavior can even be proven, see [HMRT19, MM19, BLLT20, BHX20, MVSS20].\nIn the following we analyze this phenomenon in the context of linear regression. Speciﬁcally, we focus\non a prediction task with quadratic loss, input features given by a centered Rd-valued random variable\nX, and labels given by Y = ⟨θ∗, X⟩+ ν, where θ∗∈Rd and ν is a centered random variable independent\nof X. For training data S = ((X(i), Y (i)))m\ni=1, we consider the empirical risk minimizer bfS = ⟨ˆθ, ·⟩with\nminimum Euclidean norm of its parameters ˆθ or, equivalently, the limit of gradient ﬂow with zero initialization.\nUsing (1.3) and a bias-variance decomposition we can write\nE[R( bfS)|(X(i))m\ni=1] −R∗= E[∥bfS −f ∗∥L2(PX)|(X(i))m\ni=1]\n= (θ∗)T PE[XXT ]Pθ∗+ E[ν2]Tr\n\u0000Σ+E[XXT ]\n\u0001\n,\nwhere Σ := Pm\ni=1 X(i)(X(i))T , Σ+ denotes the Moore–Penrose inverse of Σ, and P := Id −Σ+Σ is the\northogonal projector onto the kernel of Σ. For simplicity, we focus on the variance Tr\n\u0000Σ+E[XXT ]\n\u0001\n, which can\n27\nFigure 2.1: This illustration shows the classical, underparametrized regime in green, where the u-shaped curve\ndepicts the bias-variance trade-oﬀas explained in Section 1.2. Starting with complexity of our algorithm\nA larger than the interpolation threshold we can achieve zero empirical risk bRs(fs) (training error), where\nfs = A(s). Within this modern interpolation regime, the risk R(fs) (test error) might be even lower than\nat the classical sweet spot. Whereas complexity(A) traditionally refers to the complexity of the hypothesis\nset F, there is evidence that also the optimization scheme and the data is inﬂuencing the complexity\nleading to deﬁnitions like complexity(A) := max\n\b\nm ∈N: E\n\u0002 bRS(A(S))\n\u0003\n≤ε with S ∼Pm\nZ\n\t\n, for suitable\nε > 0 [NKB+20]. This illustration is based on [BHMM19].\nbe viewed as setting θ∗= 0 and E[ν2] = 1. Assuming that X has i.i.d. entries with unit variance and bounded\nﬁfth moment, the distribution of the eigenvalues of\n1\nmΣ+ in the limit d, m →∞with\nd\nm →κ ∈(0, ∞) can be\ndescribed via the Marchenko–Pastur law. Therefore, the asymptotic variance can be computed explicitly as\nTr\n\u0000Σ+E[XXT ]\n\u0001\n→1 −max{1 −κ, 0}\n|1 −κ|\nfor\nd, m →∞\nwith\nd\nm →κ,\nalmost surely, see [HMRT19]. This shows that despite interpolating the data we can decrease the risk in\nthe overparametrized regime κ > 1. In the limit d, m →∞, such benign overﬁtting can also be shown for\nmore general settings (including lazy training of NNs), some of which even achieve their optimal risk in the\noverparametrized regime [MM19, MZ20, LD21].\nFor normally distributed input features X such that E[XXT ] has rank larger than m, one can also\ncompute the behavior of the variance in the non-asymptomatic regime [BLLT20]. Deﬁne\nk∗:= min{k ≥0:\nP\ni>k λi\nλk+1\n≥cm},\nwhere λ1 ≥λ2 ≥· · · ≥λd ≥0 are the eigenvalues of E[XXT ] in decreasing order and c ∈(0, ∞) is a universal\nconstant. Assuming that k∗/m is suﬃciently small, with high probability it holds that\nTr\n\u0000Σ+E[XXT ]\n\u0001\n≈k∗\nm + m P\ni>k∗λ2\ni\n(P\ni>k∗λi)2 .\n28\n0\n50\n100\n150\nd\n0.0\n0.5\n1.0\nvariance\nFigure 2.2: The expected variance\nof linear regression in (2.8) with d ∈\n[150] and Xi ∼U({−1, 1}), i ∈[150],\nwhere Xi = X1 for i ∈{10, . . . , 20} ∪\n{30, . . . , 50} and all other coordinates\nare independent.\nThis precisely characterizes the regimes for benign overﬁtting in terms\nof the eigenvalues of the covariance matrix E[XXT ]. Furthermore, it\nshows that adding new input feature coordinates and thus increasing\nthe number of parameters d can lead to either an increase or decrease\nof the risk.\nTo motivate this phenomenon, which is considered in much more\ndepth in [CMBK20], let us focus on a single sample m = 1 and\nfeatures X that take values in X = {−1, 1}d. Then it holds that\nΣ+ = X(1)(X(1))T\n∥X(1)∥4\n= X(1)(X(1))T\nd2\nand thus\nE\n\u0002\nTr\n\u0000Σ+E[XXT ]\n\u0001\u0003\n= 1\nd2\n\r\rE\n\u0002\nXXT \u0003\r\r2\nF .\n(2.8)\nIn particular, this shows that incrementing the input feature dimen-\nsions d 7→d + 1 one can increase or decrease the risk depending on\nthe correlation of the coordinate Xd+1 with respect to the previous\ncoordinates (Xi)d\ni=1, see also Figure 2.2.\nGenerally speaking, overparametrization and perfectly ﬁtting\nnoisy data does not exclude good generalization performance, see\nalso [BRT19].\nHowever, the risk crucially depends on the data\ndistribution and the chosen algorithm.\n3\nThe role of depth in the expressivity of neural networks\nThe approximation theoretical aspect of a NN architecture, responsible for the approximation component\nεapprox := R(f ∗\nF) −R∗of the error R(fS) −R∗in (1.4), is probably one of the most well-studied parts of the\ndeep learning pipe-line. The achievable approximation error of an architecture most directly describes the\npower of the architecture.\nAs mentioned in Subsection 1.3, many classical approaches only study the approximation theory of NNs\nwith few layers, whereas modern architectures are typically very deep. A ﬁrst observation into the eﬀect of\ndepth is that it can often compensate for insuﬃcient width. For example, in the context of the universal\napproximation theorem, it was shown that very narrow NNs are still universal if instead of increasing the\nwidth, the number of layers can be chosen arbitrarily [HS17, Han19, KL20]. However, if the width of a NN\nfalls below a critical number, then the universality will not hold any longer.\nBelow, we discuss three additional observations that shed light on the eﬀect of depth on the approximation\ncapacities or alternative notions of expressivity of NNs.\n3.1\nApproximation of radial functions\nOne technique to study the impact of depth relies on the construction of speciﬁc functions which can be\nwell approximated by NNs of a certain depth, but require signiﬁcantly more parameters when approximated\nto the same accuracy by NNs of smaller depth. In the following we present one example for this type of\napproach, which can be found in [ES16].\nTheorem 3.1 (Power of depth). Let ϱ ∈{ϱR, ϱσ, 1(0,∞)} be the ReLU, the logistic, or the Heaviside function.\nThen there exist constants c, C ∈(0, ∞) with the following property: For every d ∈N with d ≥C there exist a\nprobability measure µ on Rd, a three-layer NN architecture a = (N, ϱ) = ((d, N1, N2, 1), ϱ) with ∥N∥∞≤Cd5,\nand corresponding parameters θ∗∈RP (N) with ∥θ∗∥∞≤CdC and ∥Φa(·, θ∗)∥L∞(Rd) ≤2 such that for every\nn ≤cecd it holds that\ninf\nθ∈RP ((d,n,1)) ∥Φ((d,n,1),ϱ)(·, θ) −Φa(·, θ∗)∥L2(µ) ≥c.\n29\nIn fact, the activation function in Theorem 3.1 is only required to satisfy mild conditions and the result\nholds, for instance, also for more general sigmoidal functions. The proof of Theorem 3.1 is based on the\nconstruction of a suitable radial function g: Rd →R, i.e., g(x) = ˜g(∥x∥2\n2) for some ˜g: [0, ∞) →R, which\ncan be eﬃciently approximated by three-layer NNs but approximation by only a two-layer NN requires\nexponentially large complexity, i.e., the width being exponential in d.\nThe ﬁrst observation of [ES16] is that g can typically be well approximated on a bounded domain by\na three-layer NN, if ˜g is Lipschitz continuous. Indeed, for the ReLU activation function it is not diﬃcult\nto show that, emulating a linear interpolation, one can approximate a univariate C-Lipschitz function\nuniformly on [0, 1] up to precision ε by a two-layer architecture of width O(C/ε). The same holds for smooth,\nnon-polynomial activation functions due to Theorem 1.16. This implies that the squared Euclidean norm,\nas a sum of d univariate functions, i.e., [0, 1]d ∋x 7→Pd\ni=1 x2\ni , can be approximated up to precision ε by a\ntwo-layer architecture of width O(d2/ε). Moreover, this shows that the third layer can eﬃciently approximate\n˜g, establishing approximation of g on a bounded domain up to precision ε using a three-layer architecture\nwith number of parameters polynomial in d/ε.\nThe second step in [ES16] is to choose g in such a way that the realization of any two-layer neural network\nΦ = Φ((d,n,1),ϱ)(·, θ) with width n not being exponential in d is on average (with respect to the probability\nmeasure µ) a constant distance away from g. Their argument is heavily based on ideas from Fourier analysis\nand will be outlined below. In this context, let us recall that we denote by ˆf the Fourier transform of a\nsuitable function or, more generally, tempered distribution f.\nAssuming that the square-root ϕ of the density function associated with the probability measure µ as\nwell as Φ and g are well-behaved, the Plancherel theorem yields that\n∥Φ −g∥2\nL2(µ) = ∥Φϕ −gϕ∥2\nL2(Rd) =\n\r\r c\nΦϕ −c\ngϕ\n\r\r2\nL2(Rd).\n(3.1)\nNext, the speciﬁc structure of two-layer NNs is used, which implies that for every j ∈[n] there exists\nwj ∈Rd with ∥wj∥2 = 1 and ϱj : R →R (subsuming the activation function ϱ, the norm of wj, and the\nremaining parameters corresponding to the j-th neuron in the hidden layer) such that Φ is of the form\nFigure 3.1: This illustration shows\nthe largest possible support (blue) of\nc\nΦϕ, where ˆϕ = 1Br(0) and Φ is a\nshallow neural network with architec-\nture N = (2, 4, 1) and weight matrix\nW (1) = [w1 . . . w4]T in the ﬁrst layer.\nAny radial function with enough of its\nL2-mass located at high frequencies\n(indicated by the red area) cannot be\nwell approximated by Φϕ.\nΦ =\nn\nX\nj=1\nϱj(⟨wj, ·⟩) =\nn\nX\nj=1\n(ϱj ⊗1Rd−1) ◦Rwj.\nThe second equality follows by viewing the action of the j-th neuron\nas a tensor product of ϱj and the indicator function 1Rd−1(x) = 1,\nx ∈Rd−1, composed with a d-dimensional rotation Rwj ∈SO(d)\nwhich maps wj to the ﬁrst standard basis vector e(1) ∈Rd. Noting\nthat the Fourier transform respects linearity, rotations, and tensor\nproducts, we can compute\nˆΦ =\nn\nX\nj=1\n(ˆϱj ⊗δRd−1) ◦Rwj,\nwhere δRd−1 denotes the Dirac distribution on Rd−1. In particular, the\nsupport of ˆΦ has a particular star-like shape, namely Sn\nj=1 span{wj},\nwhich are in fact lines passing through the origin.\nNow we choose ϕ to be the inverse Fourier transform of the\nindicator function of a ball Br(0) ⊂Rd with vol(Br(0)) = 1, ensuring\nthat ϕ2 is a valid probability density for µ as\nµ(Rd) = ∥ϕ2∥L1(Rd) = ∥ϕ∥2\nL2(Rd) = ∥ˆϕ∥2\nL2(Rd) = ∥1Br(0)∥2\nL2(Rd) = 1.\nUsing the convolution theorem, this choice of ϕ yields that\nsupp( c\nΦϕ) = supp(ˆΦ ∗ˆϕ) ⊂\nn\n[\nj=1\n(span{wj} + Br(0)) .\n30\nThus the lines passing through the origin are enlarged to tubes. It is this particular shape which allows the\nconstruction of some g so that ∥c\nΦϕ−c\ngϕ∥2\nL2(Rd) can be suitably lower bounded, see also Figure 3.1. Intriguingly,\nthe peculiar behavior of high-dimensional sets now comes into play. Due to the well known concentration of\nmeasure principle, the variable n needs to be exponentially large for the set Sn\nj=1 (span{wj} + Br(0)) to be\nnot sparse. If it is smaller, one can construct a function g so that the main energy content of c\ngϕ has a certain\ndistance from the origin, yielding a lower bound for ∥c\nΦϕ −c\ngϕ∥2 and hence ∥Φ −g∥2\nL2(µ), see (3.1). One key\ntechnical problem is the fact that such a behavior for ˆg does not immediately imply a similar behavior of c\ngϕ,\nrequiring a quite delicate construction of g.\n3.2\nDeep ReLU networks\n0\n1\n8\n2\n8\n3\n8\n4\n8\n5\n8\n6\n8\n7\n8\n1\n0\n1\n32\n2\n32\n3\n32\n4\n32\n5\n32\n6\n32\n7\n32\n8\n32\ng\nI1\ng\nI1\nI2\nI1\ng\nI2\nI3\nI2\nFigure 3.2: Interpolation In of [0, 1] ∋\nx 7→g(x) := x −x2 on 2n + 1 equidis-\ntant points, which can be represented\nas a sum In = Pn\nk=1 Ik −Ik−1 =\nPn\nk=1\nhk\n22k of n sawtooth functions.\nEach sawtooth function hk = hk−1◦h\nin turn can be written as a k-fold\ncomposition of a hat function h. This\nillustration is based on [EPGB19].\nMaybe for no activation function is the eﬀect of depth clearer than\nfor the ReLU activation function ϱR(x) = max{0, x}. We refer to\ncorresponding NN architectures (N, ϱR) as ReLU (neural) networks\n(ReLU NNs). A two-layer ReLU NN with one-dimensional input and\noutput is a function of the form\nΦ(x) =\nn\nX\ni=1\nw(2)\ni\nϱR(w(1)\ni\nx + b(1)\ni ) + b(2),\nx ∈R,\nwhere w(1)\ni\n, w(2)\ni\n, b(1)\ni , b(2) ∈R for i ∈[n]. It is not hard to see that Φ\nis a continuous piecewise aﬃne linear function. Moreover, Φ has at\nmost n + 1 aﬃne linear pieces. On the other hand, notice that the\nhat function\nh: [0, 1] →[0, 1],\nx 7→2ϱR(x) −4ϱR(x −1\n2) =\n(\n2x,\nif 0 ≤x < 1\n2,\n2(1 −x),\nif 1\n2 ≤x ≤1,\nis a NN with two layers and two neurons. Telgarsky observed that the\nn-fold convolution hn(x) := h ◦· · · ◦h produces a sawtooth function\nwith 2n spikes [Tel15]. In particular, hn admits 2n aﬃne linear pieces\nwith only 2n many neurons. In this case, we see that deep ReLU NNs\nare in some sense exponentially more eﬃcient in generating aﬃne\nlinear pieces.\nMoreover, it was noted in [Yar17] that the diﬀerence of interpolations of [0, 1] ∋x 7→x −x2 at 2n + 1\nand 2n−1 + 1 equidistant points equals the scaled sawtooth function\nhn\n22n , see Figure 3.2. This allows to\neﬃciently implement approximative squaring and, by polarization, also approximative multiplication using\nReLU NNs. Composing these simple functions one can approximate localized Taylor polynomials and thus\nsmooth functions, see [Yar17]. We state below a generalization [GKP20] of the result of [Yar17] which includes\nmore general norms, but for p = ∞and s = 0 coincides with the original result of Dmitry Yarotsky.\nTheorem 3.2 (Approximation of Sobolev-regular functions). Let d, k ∈N with k ≥2, let p ∈[1, ∞], s ∈[0, 1],\nB ∈(0, ∞), and let ϱ be a piecewise linear activation function with at least one break-point. Then there\nexists a constant c ∈(0, ∞) with the following property: For every ε ∈(0, 1/2) there exists a NN architecture\na = (N, ϱ) with\nP(N) ≤cε−d/(k−s) log(1/ε)\nsuch that for every function g ∈W k,p((0, 1)d) with ∥g∥W k,p((0,1)d) ≤B it holds that\ninf\nθ∈RP (N) ∥Φa(θ, ·) −g∥W s,p((0,1)d) ≤ε.\n31\nThe ability of deep ReLU neural networks to emulate multiplication has also been employed to reap-\nproximate wide ranges of high-order ﬁnite element spaces. In [OPS20] and [MOPS20] it was shown that\ndeep ReLU neural networks are capable of achieving the approximation rates of hp-ﬁnite element methods.\nConcretely, this means that for piecewise analytic functions, which appear, for example, as solutions of elliptic\nboundary and eigenvalue problems with analytic data, exponential approximation rates can be achieved. In\nother words, the number of parameters of neural networks to approximate such a function in the W 1,2-norm\nup to an error of ε is logarithmic in ε.\nTheorem 3.2 requires the depth of the NN to grow. In fact, it can be shown that the same approximation\nrate cannot be achieved with shallow NNs. Indeed, there exists a certain optimal number of layers and, if\nthe architecture has fewer layers than optimal, then the NNs need to have signiﬁcantly more parameters, to\nachieve the same approximation ﬁdelity. This has been observed in many diﬀerent settings in [LS17, SS17,\nYar17, PV18, EPGB19]. We state here the result of [Yar17]:\nTheorem 3.3 (Depth-width approximation trade-oﬀ). Let d, L ∈N with L ≥2 and let g ∈C2([0, 1]d) be a\nfunction which is not aﬃne linear. Then there exists a constant c ∈(0, ∞) with the following property: For\nevery ε ∈(0, 1) and every ReLU NN architecture a = (N, ϱR) = ((d, N1, . . . , NL−1, 1), ϱR) with L layers and\n∥N∥1 ≤cε−1/(2(L−1)) neurons it holds that\ninf\nθ∈RP (N) ∥Φa(·, θ) −g∥L∞([0,1]d) ≥ε.\ndepth\nwidth\nFigure 3.3: Standard feed-forward neural network. For\ncertain approximation results, depth and width need\nto be in a ﬁxed relationship to achieve optimal results.\nThis results is based on the observation that\nReLU NNs are piecewise aﬃne linear. The number\nof pieces they admit is linked to their capacity of\napproximating functions that have non-vanishing\ncurvature. Using a construction similar to the ex-\nample at the beginning of this subsection, it can be\nshown that the number of pieces that can be gener-\nated using an architecture ((1, N1, . . . , NL−1, 1), ϱR)\nscales roughly like QL−1\nℓ=1 Nℓ.\nIn the framework of the aforementioned results,\nwe can speak of a depth-width trade-oﬀ, see also Fig-\nure 3.3. A ﬁne-grained estimate of achievable rates\nfor freely varying depths has also been established\nin [She20].\n3.3\nAlternative notions of expressivity\nConceptual approaches to study the approximation power of deep NNs besides the classical approximation\nframework usually aim to relate structural properties of the NN to the “richness” of the set of possibly\nexpressed functions. One early result in this direction is [MPCB14] which describes bounds on the number of\naﬃne linear regions of a ReLU NN Φ(N,ϱR)(·, θ). In a simpliﬁed setting, we have seen estimates on the number\nof aﬃne linear pieces already at the beginning of Subsection 3.2. Aﬃne linear regions can be deﬁned as the\nconnected components of RN0 \\ H, where H is the set of non-diﬀerentiability of the realization20 Φ(N,ϱR)(·, θ).\nA reﬁned analysis on the number of such regions was, for example, conducted by [HvdG19]. It is found that\ndeep ReLU neural networks can exhibit signiﬁcantly more regions than their shallow counterparts.\n20One can also study the potentially larger set of activation regions given by the connected components of RN0 \\\n\u0000∪L−1\nℓ=1\n∪Nℓ\ni=1Hi,ℓ\n\u0001\n, where\nHi,ℓ:= {x ∈RN0 : Φ(ℓ)\ni\n(x, θ) = 0},\nwith Φ(ℓ)\ni\nas in (1.1), is the set of non-diﬀerentiability of the activation of the i-th neuron in the ℓ-th layer. In contrast to the\nlinear regions, the activation regions are necessarily convex [RPK+17, HR19].\n32\nFigure 3.4: Shape of the trajectory t 7→Φ((2,n,...,n,2),ϱR)(γ(t), θ) of the output of a randomly initialized\nnetwork with 0, 3, 10 hidden layers. The input curve γ is the circle given in the leftmost image. The hidden\nlayers have n = 20 neurons and the variance of the initialization is taken as 4/n.\nThe reason for this eﬀectiveness of depth is described by the following analogy: Through the ReLU each\nneuron Rd ∋x 7→ϱR(⟨x, w⟩+ b), w ∈Rd, b ∈R, splits the space into two aﬃne linear regions separated by\nthe hyperplane\n{x ∈Rd : ⟨x, w⟩+ b = 0}.\nA shallow ReLU NN Φ((d,n,1),ϱR)(·, θ) with n neurons in the hidden layer therefore produces a number of\nregions deﬁned through n hyperplanes. Using classical bounds on the number of regions deﬁned through\nhyperplane arrangements [Zas75], one can bound the number of aﬃne linear regions by Pd\nj=0\n\u0000n\nj\n\u0001\n. Deepening\nneural networks then corresponds to a certain folding of the input space. Through this interpretation it can\nbe seen that composing NNs can lead to a multiplication of the number of regions of the individual NNs\nresulting in an exponential eﬃciency of deep neural networks in generating aﬃne linear regions21.\nThis approach was further developed in [RPK+17] to a framework to study expressivity that to some extent\nallows to include the training phase. One central object studied in [RPK+17] are so-called trajectory lengths.\nIn this context, one analyzes how the length of a non-constant curve in the input space changes in expectation\nthrough the layers of a NN. The authors ﬁnd an exponential dependence of the expected curve length on the\ndepth. Let us motivate this in the special case of a ReLU NN with architecture a = ((N0, n, . . . , n, NL), ϱR)\nand depth L ∈N.\nGiven a non-constant continuous curve γ : [0, 1] →RN0 in the input space, the length of the trajectory in\nthe ℓ-th layer of the NN Φa(·, θ) is then given by\nLength(¯Φ(ℓ)(γ(·), θ)),\nℓ∈[L −1],\nwhere ¯Φ(ℓ)(·, θ) is the activation in the ℓ-th layer, see (1.1). Here the length of the curve is well-deﬁned since\n¯Φ(ℓ)(·, θ)) is continuous and therefore ¯Φ(ℓ)(γ(·), θ) is continuous. Now, let the parameters Θ1 of the NN Φa\nbe initialized independently so that the entries corresponding to the weight matrices and bias vectors follow\na normal distribution with zero mean and variances 1/n and 1, respectively. It is not hard to see, e.g., by\nProposition 1.1, that the probability that ¯Φ(ℓ)(·, Θ1) will map γ to a non-constant curve is positive and hence,\nfor ﬁxed ℓ∈[L −1],\nE\n\u0002\nLength(¯Φ(ℓ)(γ(·), Θ1))\n\u0003\n= c > 0.\nLet σ ∈(0, ∞) and consider a second initialization Θσ, where we change the variances of the entries\ncorresponding to the weight matrices and bias vectors to σ2/n and σ2, respectively. Recall that the ReLU is\npositively homogeneous, i.e., we have that ϱR(λx) = λϱR(x) for all λ ∈(0, ∞). Then it is clear that\n¯Φ(ℓ)(·, Θσ) ∼σℓ¯Φ(ℓ)(·, Θ1),\n21However, to exploit this eﬃciency with respect to the depth, one requires highly oscillating pre-activations which in turn can\nonly be achieved with a delicate selection of parameters. In fact, it can be shown that through random initialization the expected\nnumber of activation regions per unit cube depends mainly on the number of neurons in the NN, rather than its depth [HR19].\n33\ni.e., the activations corresponding to the two initialization strategies are identically distributed up to the\nfactor σℓ. Therefore, we immediately conclude that\nE\n\u0002\nLength(¯Φ(ℓ)(γ(·), Θσ))\n\u0003\n= σℓc.\nThis shows that the expected trajectory length depends exponentially on the depth of the NN, which is in\nline with the behavior of other notions of expressivity [PLR+16]. In [RPK+17] this result is also extended to\nthe tanh activation function and the constant c is more carefully resolved. Empirically one also ﬁnds that the\nshapes of the trajectories become more complex in addition to becoming longer on average, see Figure 3.4.\n4\nDeep neural networks overcome the curse of dimensionality\nM\nFigure 4.1:\nIllustration of a one-\ndimensional manifold M embedded\nin R3. For every point x ∈M there\nexists a neighborhood in which the\nmanifold can be linearly projected\nonto its tangent space at x such that\nthe corresponding inverse function is\ndiﬀerentiable.\nIn Subsection 1.3, one of the main puzzles of deep learning that we\nidentiﬁed was the surprising performance of deep architectures on\nproblems where the input dimensions are very high. This perfor-\nmance cannot be explained in the framework of classical approx-\nimation theory, since such results always suﬀer from the curse of\ndimensionality [Bel52, DeV98, NW09].\nIn this section, we present three approaches that oﬀer explana-\ntions of this phenomenon. As before, we had to omit certain ideas\nwhich have been very inﬂuential in the literature to keep the length\nof this section under control. In particular, an important line of\nreasoning is that functions to be approximated often have composi-\ntional structures which NNs may approximate very well as reviewed\nin [PMR+17]. Note that also a suitable feature descriptor, factor-\ning out invariances, might lead to a signiﬁcantly reduced eﬀective\ndimension, see Subsection 7.1.\n4.1\nManifold assumption\nA ﬁrst remedy to the high-dimensional curse of dimensionality is\nwhat we call the manifold assumption. Here it is assumed that we\nare trying to approximate a function\ng: Rd ⊃X →R,\nwhere d is very large. However, we are not seeking to optimize with respect to the uniform norm or a regular\nLp space, but instead consider a measure µ which is supported on a d′-dimensional manifold M ⊂X. Then\nthe error is measured in the Lp(µ)-norm. Here we consider the case where d′ ≪d. This setting is appropriate\nif the data z = (x, y) of a prediction task is generated from a measure supported on M × R.\nThis set-up or generalizations thereof have been fundamental in [CM18, SCC18, CJLZ19, SH19, CK20,\nNI20]. Let us describe an exemplary approach, where we consider locally Ck-regular functions and NNs with\nReLU activation functions below:\n1. Describe the regularity of g on the manifold: Naturally, we need to quantify the regularity of the\nfunction g restricted to M in an adequate way. The typical approach would be to make a deﬁnition\nvia local coordinate charts. If we assume that M is an embedded submanifold of X, then locally,\ni.e., in a neighborhood of a point x ∈M, the orthogonal projection of M onto the d′-dimensional\ntangent space TxM is a diﬀeomorphism. The situation is depicted in Figure 4.1. Assuming M to\nbe compact, we can choose a ﬁnite set of open balls (Ui)p\ni=1 that cover M and on which the local\nprojections γi onto the respective tangent spaces as described above exists and are diﬀeomorphisms.\nNow we can deﬁne the regularity of g via classical regularity. In this example, we say that g ∈Ck(M)\nif g ◦γ−1\ni\n∈Ck(γi(M ∩Ui)) for all i ∈[p].\n34\n2. Construct localization and charts via neural networks: According to the construction of local coordinate\ncharts in Step 1, we can write g as follows:\ng(x) =\np\nX\ni=1\nφi(x)\n\u0000g ◦γ−1\ni\n(γi(x))\n\u0001\n=:\np\nX\ni=1\n˜gi(γi(x), φi(x)),\nx ∈M,\n(4.1)\nwhere φi is a partition of unity such that supp(φi) ⊂Ui.\nNote that γi is a linear map, hence\nrepresentable by a one-layer NN. Since multiplication is a smooth operation, we have that if g ∈Ck(M)\nthen ˜gi ∈Ck(γi(M ∩Ui) × [0, 1]).\nThe partition of unity φi needs to be emulated by NNs. For example, if the activation function is the\nReLU, then such a partition can be eﬃciently constructed. Indeed, in [HLXZ20] it was shown that\nsuch NNs can represent linear ﬁnite elements exactly with ﬁxed-size NNs and hence a partition of unity\nsubordinate to any given covering of M can be constructed.\n3. Use a classical approximation result on the localized functions: By some form of Whitney’s extension\ntheorem [Whi34], we can extend each ˜gi to a function ¯gi ∈Ck(X ×[0, 1]) which by classical results can be\napproximated up to an error of ε > 0 by NNs of size O(ε−(d′+1)/k) for ε →0, see [Mha96, Yar17, SCC18].\n4. Use the compositionality of neural networks to build the ﬁnal network: We have seen that every\ncomponent in the representation (4.1), i.e., ˜gi, γi, and φi can be eﬃciently represented by NNs. In\naddition, composition and summation are operations which can directly be implemented by NNs through\nincreasing their depth and widening their layers. Hence (4.1) is eﬃciently—i.e., with a rate depending\nonly on d′ instead of the potentially much larger d—approximated by a NN.\nOverall, we see that NNs are capable of learning local coordinate transformations and therefore reduce\nthe complexity of a high-dimensional problem to the underlying low-dimensional problem given by the data\ndistribution.\n4.2\nRandom sampling\nAlready in 1992, Andrew Barron showed that under certain seemingly very natural assumptions on the\nfunction to approximate, a dimension-independent approximation rate by NNs can be achieved [Bar92, Bar93].\nSpeciﬁcally, the assumption is formulated as a condition on the Fourier transform of a function and the result\nis as follows.\nTheorem 4.1 (Approximation of Barron-regular functions). Let ϱ: R →R be the ReLU or a sigmoidal\nfunction. Then there exists a constant c ∈(0, ∞) with the following property: For every d, n ∈N, every\nprobability measure µ supported on B1(0) ⊂Rd, and every g ∈L1(Rd) with Cg :=\nR\nRd ∥ξ∥2|ˆg(ξ)| dξ < ∞it\nholds that\ninf\nθ∈RP ((d,n,1)) ∥Φ((d,n,1),ϱ)(·, θ) −g∥L2(µ) ≤\nc\n√nCg,\nNote that the L2-approximation error can be replaced by an L∞-estimate over the unit ball at the expense\nof a factor of the order of\n√\nd on the right-hand side.\nThe key idea behind Theorem 4.1 is the following application of the law of large numbers: First, we\nobserve that, per assumption, g can be represented via the inverse Fourier transform, as\ng −g(0) =\nZ\nRd ˆg(ξ)(e2πi⟨·,ξ⟩−1) dξ\n= Cg\nZ\nRd\n1\n∥ξ∥2\n(e2πi⟨·,ξ⟩−1) 1\nCg\n∥ξ∥2ˆg(ξ) dξ\n= Cg\nZ\nRd\n1\n∥ξ∥2\n(e2πi⟨·,ξ⟩−1) dµg(ξ),\n(4.2)\n35\nwhere µg is a probability measure. Then it is further shown in [Bar92] that there exist (Rd × R)-valued\nrandom variables (Ξ, eΞ) such that (4.2) can be written as\ng(x) −g(0) = Cg\nZ\nRd\n1\n∥ξ∥2\n(e2πi⟨x,ξ⟩−1) dµg(ξ) = CgE\n\u0002\nΓ(Ξ, eΞ)(x)\n\u0003\n,\nx ∈Rd,\n(4.3)\nwhere for every ξ ∈Rd, ˜ξ ∈R the function Γ(ξ, ˜ξ): Rd →R is given by\nΓ(ξ, ˜ξ) := s(ξ, ˜ξ)(1(0,∞)(−⟨ξ/∥ξ∥2, ·⟩−˜ξ) −1(0,∞)(⟨ξ/∥ξ∥2, ·⟩−˜ξ))\nwith\ns(ξ, ˜ξ) ∈{−1, 1}.\nNow, let ((Ξ(i), eΞ(i)))i∈N be i.i.d. random variables with (Ξ(1), eΞ(1)) ∼(Ξ, eΞ). Then, Bienaym´e’s identity and\nFubini’s theorem establish that\nE\n\"\r\r\rg −g(0) −Cg\nn\nn\nX\ni=1\nΓ(Ξ(i), eΞ(i))\n\r\r\r\n2\nL2(µ)\n#\n=\nZ\nB1(0)\nV\n\"\nCg\nn\nn\nX\ni=1\nΓ(Ξ(i), eΞ(i))(x)\n#\ndµ(x)\n=\nC2\ng\nR\nB1(0) V\n\u0002\nΓ(Ξ, eΞ)(x)\n\u0003\ndµ(x)\nn\n≤(2πCg)2\nn\n,\n(4.4)\nwhere the last inequality follows from combining (4.3) with the fact that |e2πi⟨x,ξ⟩−1|/∥ξ∥2 ≤2π, x ∈B1(0).\nThis implies that there exists a realization ((ξ(i), ˜ξ(i)))i∈N of the random variables ((Ξ(i), eΞ(i)))i∈N that\nachieves L2-approximation error of n−1/2. Therefore, it remains to show that NNs can well approximate\nthe functions ((Γ(ξ(i), ˜ξ(i)))i∈N. Now it is not hard to see that the function 1(0,∞) and hence functions of\nthe form Γ(ξ, ˜ξ), ξ ∈Rd, ˜ξ ∈R, can be arbitrarily well approximated with a ﬁxed-size, two-layer NN with a\nsigmoidal or ReLU activation function. Thus, we obtain an approximation rate of n−1/2 when approximating\nfunctions with one ﬁnite Fourier moment by two-layer NNs with n hidden neurons.\nIt was pointed out already in the dissertation of Emmanuel Cand`es [Can98] that the approximation rate\nof NNs for Barron-regular functions is also achievable by n-term approximation with complex exponentials, as\nis apparent by considering (4.2). However, for deeper NNs, the results also extend to high-dimensional non-\nsmooth functions, where Fourier-based methods are certain to suﬀer from the curse of dimensionality [CPV20].\nIn addition, the random sampling idea above was extended in [EMW19b, EMWW20, EW20b, EW20c]\nto facilitate dimension-independent approximation of vastly more general function spaces. Basically, the\nidea is to use (4.3) as an inspiration and deﬁne the generalized Barron space as all functions that may be\nrepresented as\nE\n\u0002\n1(0,∞)(⟨Ξ, ·⟩−eΞ)\n\u0003\nfor any random variable (Ξ, eΞ). In this context, deep and compositional versions of Barron spaces were\nintroduced and studied in [BK18, EMW19a, EW20a], which considerably extend the original theory.\n4.3\nPDE assumption\nAnother structural assumption that leads to the absence of the curse of dimensionality in some cases is that\nthe function we are trying to approximate is given as the solution to a partial diﬀerential equation. It is by\nno means clear that this assumption leads to approximation without the curse of dimensionality, since most\nstandard methods, such as ﬁnite elements, sparse grids, or spectral methods typically suﬀer from the curse of\ndimensionality.\nThis is not merely an abstract theoretical problem: Very recently, in [AHNB+20] it was shown that two\ndiﬀerent gold standard methods for solving the multi-electron Schr¨odinger equation produce completely\ndiﬀerent interaction energy predictions when applied to large delocalized molecules. Classical numerical\nrepresentations are simply not expressive enough to accurately represent complicated high-dimensional\nstructures such as wave functions with long-range interactions.\nInterestingly, there exists an emerging body of work that shows that NNs do not suﬀer from these\nshortcomings and enjoy superior expressivity properties as compared to standard numerical representations.\n36\nSuch results include, for example, [GHJVW20, GS20, HJKN20] for (linear and semilinear) parabolic evolution\nequations, [GH22] for stationary elliptic PDEs, [GH21] for nonlinear Hamilton–Jacobi–Bellman equations,\nor [KPRS19] for parametric PDEs. In all these cases, the absence of the curse of dimensionality in terms of\nthe theoretical approximation power of NNs could be rigorously established.\nOne way to prove such results is via stochastic representations of the PDE solutions, as well as associated\nsampling methods. We illustrate the idea for the simple case of linear Kolmogorov PDEs, that is the problem\nof representing the function g: Rd × [0, ∞) →R satisfying22\n∂g\n∂t (x, t) = 1\n2Tr\n\u0000σ(x, t)[σ(x, t)]∗∇2\nxg(x, t)\n\u0001\n+ ⟨µ(x, t), ∇xg(x, t)⟩,\ng(x, 0) = ϕ(x),\n(4.5)\nwhere the functions\nϕ: Rd →R\n(initial condition)\nand\nσ: Rd →Rd×d,\nµ: Rd →Rd\n(coeﬃcient functions)\nare continuous and satisfy suitable growth conditions. A stochastic representation of g is given via the Ito\nprocesses (Sx,t)t≥0 satisfying\ndSx,t = µ(Sx,t)dt + σ(Sx,t)dBt,\nSx,0 = x,\n(4.6)\nwhere (Bt)t≥0 is a d-dimensional Brownian motion. Then g is described via the Feynman–Kac formula which\nstates that\ng(x, t) = E[ϕ(Sx,t)],\nx ∈Rd, t ∈[0, ∞).\n(4.7)\nRoughly speaking, a NN approximation result can be proven by ﬁrst approximating, via the law of large\nnumbers,\ng(x, t) = E[ϕ(Sx,t)] ≈1\nn\nn\nX\ni=1\nϕ(S(i)\nx,t),\n(4.8)\nwhere (S(i)\nx,t)n\ni=1 are i.i.d. random variables with S(1)\nx,t ∼Sx,t.\nCare has to be taken to establish such\nan approximation uniformly in the computational domain, for example, for every (x, t) in the unit cube\n[0, 1]d × [0, 1], see (4.4) for a similar estimate and [GHJVW20, GS20] for two general approaches to ensure\nthis property. Aside from this issue, (4.8) represents a standard Monte Carlo estimator which can be shown\nto be free of the curse of dimensionality.\nAs a next step, one needs to establish that realizations of the processes (x, t) 7→Sx,t can be eﬃciently\napproximated by NNs. This can be achieved by emulating a suitable time-stepping scheme for the SDE (4.6)\nby NNs which, roughly speaking, can be done without incurring the curse of dimensionality whenever the\ncoeﬃcient functions µ, σ can be approximated by NNs without incurring the curse of dimensionality and some\ngrowth conditions hold true. In a last step one assumes that the initial condition ϕ can be approximated by\nNNs without incurring the curse of dimensionality which, by the compositionality of NNs and the previous\nstep, directly implies that realizations of the processes (x, t) 7→ϕ(Sx,t) can be approximated by NNs without\nincurring the curse of dimensionality. By (4.8) this implies a corresponding approximation result for the\nsolution of the Kolmogorov PDE g in (4.5).\nInformally, we have discovered a regularity result for linear Kolmogorov equations, namely that (modulo\nsome technical conditions on µ, σ), the solution g of (4.5) can be approximated by NNs without incurring the\ncurse of dimensionality whenever the same holds true for the initial condition ϕ, as well as the coeﬃcient\nfunctions µ, σ. In other words, the property of being approximable by NNs without curse of dimensionality is\npreserved under the ﬂow induced by the PDE (4.5). Some comments are in order:\n22The natural solution concept to this type of PDEs is the viscosity solution concept, a thorough study of which can be found\nin [HHJ15].\n37\nAssumption on the initial condition:\nOne may wonder if the assumption that the initial condition\nϕ can be approximated by NNs without incurring the curse of dimensionality is justiﬁed. This is at least\nthe case in many applications in computational ﬁnance where the function ϕ typically represents an option\npricing formula and (4.5) represents the famous Black–Scholes model. It turns out that nearly all common\noption pricing formulas are constructed from iterative applications of linear maps and maximum/minimum\nfunctions—in other words, in many applications in computational ﬁnance, the initial condition ϕ can be\nexactly represented by a small ReLU NN.\n101\n102\ninput dimension\n107\n108\n109\n1010\n1011\nx\ncx2.36\n#parameters  avg. #steps\n± 2 std.\nFigure 4.2: Computational complexity as number of\nneural network parameters times number of SGD steps\nto solve heat equations of varying dimensions up to\na speciﬁed precision. According to the ﬁt above, the\nscaling is polynomial in the dimension [BDG20].\nGeneralization and optimization error:\nThe\nFeynman–Kac representation (4.7) directly implies\nthat g(·, t) can be computed as the Bayes opti-\nmal function of a regression task with input fea-\ntures X ∼U([0, 1]d) and labels Y = ϕ(SX,t), which\nallows for an analysis of the generalization error\nas well as implementations based on ERM algo-\nrithms [BGJ20, BBG+21].\nWhile it is in principle possible to analyze the\napproximation and generalization error, the analysis\nof the computational cost and/or convergence of\ncorresponding SGD algorithms is completely open.\nSome promising numerical results exist, see, for\ninstance, Figure 4.2, but the stable training of NNs\napproximating PDEs to very high accuracy (that\nis needed in several applications such as quantum\nchemistry) remains very challenging. The recent\nwork [GV21] has even proven several impossibility\nresults in that direction.\nExtensions and abstract idea:\nSimilar techniques may be used to prove expressivity results for nonlinear\nPDEs, for example, using nonlinear Feynman–Kac-type representations of [PP92] in place of (4.7) and\nmultilevel Picard sampling algorithms of [EHJK19] in place of (4.8).\nWe can also formulate the underlying idea in an abstract setting (a version of which has also been used in\nSubsection 4.2). Assume that a high-dimensional function g: Rd →R admits a probabilistic representation of\nthe form\ng(x) = E[Yx],\nx ∈Rd,\n(4.9)\nfor some random variable Yx which can be approximated by an iterative scheme\nY(L)\nx\n≈Yx\nand\nY(ℓ)\nx\n= Tℓ(Y(ℓ−1)\nx\n),\nℓ= 1, . . . , L,\nwith dimension-independent convergence rate. If we can approximate realizations of the initial mapping\nx 7→Y0\nx and the maps Tℓ, ℓ∈[L], by NNs and the numerical scheme is stable enough, then we can also\napproximate Y(L)\nx\nusing compositionality. Emulating a uniform Monte-Carlo approximator of (4.9) then\nleads to approximation results for g without curse of dimensionality. In addition, one can choose a Rd-valued\nrandom variable X as input features and deﬁne the corresponding labels by YX to obtain a prediction task,\nwhich can be solved by means of ERM.\nOther methods:\nThere exist a number of additional works related to the approximation capacities of\nNNs for high-dimensional PDEs, for example, [EGJS18, LTY19, SZ19]. In most of these works, the proof\ntechnique consists of emulating an existing method that does not suﬀer from the curse of dimensionality. For\ninstance, in the case of ﬁrst-order transport equations, one can show in some cases that NNs are capable of\nemulating the method of characteristics, which then also yields approximation results that are free of the\ncurse of dimensionality [LP21].\n38\n5\nOptimization of deep neural networks\nWe recall from Subsections 1.3 and 1.2.1 that the standard algorithm to solve the empirical risk minimization\nproblem over the hypothesis set of NNs is stochastic gradient descent. This method would be guaranteed\nto converge to a global minimum of the objective if the empirical risk were convex, viewed as a function of\nthe NN parameters. However, this function is severely nonconvex, may exhibit (higher-order) saddle points,\nseriously suboptimal local minima, and wide ﬂat areas where the gradient is very small.\nOn the other hand, in applications, excellent performance of SGD is observed. This indicates that the\ntrajectory of the optimization routine somehow misses suboptimal critical points and other areas that may\nlead to slow convergence. Clearly, the classical theory does not explain this performance. Below we describe\nsome exemplary novel approaches that give partial explanations of this success.\nIn the ﬂavor of this article, the aim of this section is to present some selected ideas rather than giving an\noverview of the literature. To give at least some detail about the underlying ideas and to keep the length of\nthis section reasonable, a selection of results had to be made and some ground-breaking results had to be\nomitted.\n5.1\nLoss landscape analysis\nGiven a NN Φ(·, θ) and training data s ∈Zm the function θ 7→r(θ) := bRs(Φ(·, θ)) describes, in a natural\nway, through its graph, a high-dimensional surface. This surface may have regions associated with lower\nvalues of bRs which resemble valleys of a landscape if they are surrounded by regions of higher values. The\nanalysis of the topography of this surface is called loss landscape analysis. Below we shall discuss a couple of\napproaches that yield deep insights into the shape of this landscape.\nIndex\nLoss\nNo negative curvature\nat globally minimal\nrisk.\nCritical points\nwith high risk\nare unstable.\n0\n0.25\n0.5\nFigure 5.1: Sketch of the distribution\nof critical points of the Hamiltonian\nof a spin glass model.\nSpin glass interpretation:\nOne of the ﬁrst discoveries about the\nshape of the loss landscape comes from deep results in statistical\nphysics. The Hamiltonian of the spin glass model is a random function\non the (n −1)-dimensional sphere of radius √n. Making certain\nsimplifying assumptions, it was shown in [CHM+15] that the loss of\na NN with random inputs can be considered as the Hamiltonian of a\nspin glass model, where the inputs of the model are the parameters\nof the NN.\nThis connection has far-reaching implications for the loss land-\nscape of NNs because of the following surprising property of the\nHamiltonian of spin glass models: Consider the set of critical points\nof this set, and associate to each point an index that denotes the\npercentage of the eigenvalues of the Hessian at that point which are\nnegative. This index corresponds to the relative number of directions\nin which the loss landscape has negative curvature. Then with high\nprobability, a picture like we see in Figure 5.1 emerges [AAˇC13].\nMore precisely, the further away from the optimal loss we are, the more unstable the critical points become.\nConversely, if one ﬁnds oneself in a local minimum, it is reasonable to assume that the loss is close to the\nglobal minimum.\nWhile some of the assumptions establishing the connection between the spin glass model and NNs are\nunrealistic in practice [CLA15], the theoretical distribution of critical points as in Figure 5.1 is visible in\nmany practical applications [DPG+14].\nPaths and level sets:\nAnother line of research is to understand the loss landscape by analyzing paths\nthrough the parameter space. In particular, the existence of paths in parameter space, such that the associated\nempirical risks are monotone along the path. Surely, should there exist a path of nonincreasing empirical risk\nfrom every point to the global minimum, then we can be certain that no non-global minima exist, since no\n39\nsuch path can escape a minimum. An even stronger result holds. In fact, the existence of such paths shows\nthat the loss landscape has connected level sets [FB17, VBB19].\nA crucial ingredient of the analysis of such paths are linear substructures. Consider a biasless two-layer\nNN Φ of the form\nRd ∋x 7→Φ(x, θ) :=\nn\nX\nj=1\nθ(2)\nj ϱ\n\u0000⟨θ(1)\nj ,\n\u0014x\n1\n\u0015\n⟩\n\u0001\n,\n(5.1)\nwhere θ(1)\nj\n∈Rd+1 for j ∈[n], θ(2) ∈Rn, ϱ is a Lipschitz continuous activation function, and we augment the\nvector x by a constant 1 in the last coordinate as outlined in Remark 1.5. If we consider θ(1) to be ﬁxed,\nthen it is clear that the space\neFθ(1) := {Φ(·, θ): θ = (θ(1), θ(2)), θ(2) ∈Rn}\nis a linear space. If the risk23 is convex, as is the case for the widely used quadratic or logistic loss, then\nthis implies that θ(2) 7→r\n\u0000(θ(1), θ(2))\n\u0001\nis a convex map and hence, for every parameter set P ⊂Rn this map\nassumes its maximum on ∂P. Therefore, within the vast parameter space, there are many paths traveling\nalong which does not increase the risk above the risk of the start and end points.\nThis idea was, for example, used in [FB17] in a way similar to the following simple sketch: Assume\nthat, for two parameters θ and θmin there exists a linear subspace of NNs eFˆθ(1) such that there are paths γ1\nand γ2 connecting Φ(·, θ) and Φ(·, θmin) to eFˆθ(1) respectively. Further assume that the paths are such that\nalong γ1 and γ2 the risk does not signiﬁcantly exceed max{r(θ), r(θmin)}. Figure 5.2 shows a visualization of\nthese paths. In this case, a path from θ to θmin not signiﬁcantly exceeding r(θ) along the way is found by\nconcatenating the paths γ1, a path along eFˆθ(1), and γ2. By the previous discussion, we know that only γ1\nand γ2 determine the extent to which the combined path exceeds r(θ) along its way. Hence, we need to ask\nabout the existence of eFˆθ(1) that facilitates the construction of appropriate γ1 and γ2.\nΦ(·, θmin)\nΦ(·, θ)\ne\nFˆθ(1)\nΦ(·, θ∗)\nγ1\nFigure 5.2: Construction of a path\nfrom an initial point θ to the global\nminimum θmin that does not have sig-\nniﬁcantly higher risk than the initial\npoint along the way. We depict here\nthe landscape as a function of the\nneural network realizations instead\nof their parametrizations so that this\nlandscape is convex.\nTo understand why a good choice of eFˆθ(1), so that the risk along\nγ1 and γ2 will not rise much higher than r(θ), is likely possible, we\nset24\nˆθ(1)\nj\n:=\n(\nθ(1)\nj\nfor j ∈[n/2],\n(θ(1)\nmin)j\nfor j ∈[n] \\ [n/2].\nIn other words, the ﬁrst half of ˆθ(1) is made from θ(1) and the\nsecond from θ(1)\nmin. If θ(1)\nj , j ∈[N], are realizations of random variables\ndistributed uniformly on the d-dimensional unit sphere, then by\ninvoking standard covering bounds of spheres (e.g., [Ver18, Corollary\n4.2.13]), we expect that, for ε > 0 and a suﬃciently large number\nof neurons n, the vectors (θ(1)\nj )n/2\nj=1 already ε-approximate all vectors\n(θ(1)\nj )n\nj=1. Replacing all vectors (θ(1)\nj )n\nj=1 by their nearest neighbor in\n(θ(1)\nj )n/2\nj=1 can be done with a linear path in the parameter space, and,\ngiven that r is locally Lipschitz continuous and ∥θ(2)∥1 is bounded,\nthis operation will not increase the risk by more than O(ε). We\ndenote the vector resulting from this replacement procedure by θ(1)\n∗.\nSince for all j ∈[n] \\ [n/2] we now have that\nϱ\n\u0000⟨(θ(1)\n∗)j,\n\u0014\n·\n1\n\u0015\n⟩\n\u0001\n∈\n\u001a\nϱ\n\u0000⟨(θ(1)\n∗)k,\n\u0014\n·\n1\n\u0015\n⟩\n\u0001\n: k ∈[n/2]\n\u001b\n,\n23As most statements in this subsection are valid for the empirical risk r(θ) = b\nRs(Φ(·, θ)) as well as the risk r(θ) = R(Φ(·, θ)),\ngiven a suitable distribution of Z, we will just call r the risk.\n24We assume w.l.o.g. that n is a multiple of 2.\n40\nthere exists a vector θ(2)\n∗\nwith (θ(2)\n∗)j = 0, j ∈[n] \\ [n/2], so that\nΦ(·, (θ(1)\n∗, θ(2))) = Φ(·, (θ(1)\n∗, λθ(2)\n∗\n+ (1 −λ)θ(2))),\nλ ∈[0, 1].\nIn particular, this path does not change the risk between (θ(1)\n∗, θ(2)) and (θ(1)\n∗, θ(2)\n∗). Now, since (θ(2)\n∗)j = 0\nfor j ∈[n] \\ [n/2], the realization Φ(·, (θ(1)\n∗, θ(2)\n∗)) is computed by a sub-network consisting of the ﬁrst n/2\nhidden neurons and we can replace the parameters corresponding to the other neurons without any eﬀect on\nthe realization function. Speciﬁcally, it holds that\nΦ(·, (θ(1)\n∗, θ(2)\n∗)) = Φ(·, (λˆθ(1) + (1 −λ)θ(1)\n∗, θ(2)\n∗)),\nλ ∈[0, 1],\nyielding a path of constant risk between (θ(1)\n∗, θ(2)\n∗) and (ˆθ(1), θ(2)\n∗). Connecting these paths completes the\nconstruction of γ1 and shows that the risk along γ1 does not exceed that at θ by more than O(ε). Of course,\nγ2 can be constructed in the same way. The entire construction is depicted in Figure 5.2.\nOverall, this derivation shows that for suﬃciently wide NNs (appropriately randomly initialized) it is very\nlikely possible to almost connect a random parameter value to the global minimum with a path which along\nthe way does not need to climb much higher than the initial risk.\nIn [VBB19], a similar approach is taken and the convexity in the last layer is used. However, the authors\ninvoke the concept of intrinsic dimension to elegantly solve the non-linearity of r((θ(1), θ(2))) with respect to\nθ(1). Additionally, [SS16] constructs a path of decreasing risk from random initializations. The idea here is\nthat if one starts at a point of suﬃciently high risk, one can always ﬁnd a path to the global optimum with\nstrictly decreasing risk. The intriguing insight behind this result is that if the initialization is suﬃciently\nbad, i.e., worse than that of a NN outputting only zero, then there exist two operations that inﬂuence the\nrisk directly. Multiplying the last layer with a number smaller than one will decrease the risk, whereas the\nopposite will increase it. Using this tuning mechanism, any given potentially non-monotone path from the\ninitialization to the global minimum can be modiﬁed so that it is strictly monotonically decreasing. In a\nsimilar spirit, [NH17] shows that if a deep NN has a layer with more neurons than training data points, then\nunder certain assumptions the training data will typically be mapped to linearly independent points in that\nlayer. Of course, this layer could then be composed with a linear map that maps the linearly independent\npoints to any desirable output, in particular one that achieves vanishing empirical risk, see also Proposition 1.1.\nAs for two-layer NNs, the previous discussion on linear paths immediately shows that in this situation a\nmonotone path to the global minimum exists.\n5.2\nLazy training and provable convergence of stochastic gradient descent\nWhen training highly overparametrized NNs, one often observes that the parameters of the NNs barely\nchange during training. In Figure 5.3, we show the relative distance that the parameters travel through the\nparameter space during the training of NNs of varying numbers of neurons per layer.\nThe eﬀect described above has been observed repeatedly and theoretically explained, see, e.g., [DZPS18,\nLL18, AZLS19, DLL+19, ZCZG20]. In Subsection 2.1, we have already seen a high-level overview and, in\nparticular, the function space perspective of this phenomenon in the inﬁnite width limit. Below we present a\nshort and highly simpliﬁed derivation of this eﬀect and show how it leads to provable convergence of gradient\ndescent for suﬃciently overparametrized deep NNs.\nA simple learning model:\nWe consider again the simple NN model of (5.1) with a smooth activation\nfunction ϱ which is not aﬃne linear. For the quadratic loss and training data s = ((x(i), y(i)))m\ni=1 ∈(Rd ×R)m,\nwhere xi ̸= xj for all i ̸= j, the empirical risk is given by\nr(θ) = bRs(θ) = 1\nm\nm\nX\ni=1\n(Φ(x(i), θ) −y(i))2.\nLet us further assume that Θ(1)\nj\n∼N(0, 1/n)d+1, j ∈[n], and Θ(2)\nj\n∼N(0, 1/n), j ∈[n], are independent\nrandom variables.\n41\nFigure 5.3: Four networks with architecture ((1, n, n, 1), ϱR) and n ∈{20, 100, 500, 2500} neurons per hidden\nlayer were trained by gradient descent to ﬁt four points that are shown in the middle ﬁgure as black dots.\nWe depict on the left the relative Euclidean distance of the parameters from the initialization through the\ntraining process. In the middle, we show the ﬁnal trained NNs. On the right we show the behavior of the\ntraining error.\nA peculiar kernel:\nNext, we would like to understand how the gradient ∇θr(Θ) looks like with high\nprobability over the initialization Θ = (Θ(1), Θ(2)). Similar to (2.3), we have by restricting the gradient to\nθ(2) and applying the chain rule that\n∥∇θr(Θ)∥2\n2 ≥\n4\nm2\n\r\r\r\nm\nX\ni=1\n∇θ(2)Φ(x(i), Θ)(Φ(x(i), Θ) −y(i))\n\r\r\r\n2\n2\n=\n4\nm2\n\u0000(Φ(x(i), Θ) −y(i))m\ni=1\n\u0001T ¯KΘ(Φ(x(j), Θ) −y(j))m\nj=1,\n(5.2)\nwhere ¯KΘ is a random Rm×m-valued kernel given by\n( ¯KΘ)i,j :=\n\u0000∇θ(2)Φ(x(i), Θ)\n\u0001T ∇θ(2)Φ(x(j), Θ),\ni, j ∈[m].\nThis kernel is closely related to the neural tangent kernel in (2.4) evaluated at the features (x(i))m\ni=1 and the\nrandom initialization Θ. It is a slightly simpliﬁed version thereof, as in (2.4) the gradient is taken with respect\nto the full vector θ. This can also be regarded as the kernel associated with a random features model [RR+07].\nNote that for our two-layer NN we have that\n\u0000∇θ(2)Φ(x, Θ)\n\u0001\nk = ϱ\n\u0012\u001c\nΘ(1)\nk ,\n\u0014x\n1\n\u0015\u001d\u0013\n,\nx ∈Rd, k ∈[n].\nThus, we can write ¯KΘ as the following sum of (random) rank one matrices:\n¯KΘ =\nn\nX\nk=1\nvkvT\nk\nwith\nvk =\n\u0012\nϱ\n\u0012\u001c\nΘ(1)\nk ,\n\u0014\nx(i)\n1\n\u0015\u001d\u0013\u0013m\ni=1\n∈Rm,\nk ∈[n].\n(5.3)\nThe kernel ¯KΘ are symmetric and positive semi-deﬁnite by construction. It is positive deﬁnite if it is\nnon-singular, i.e., if at least m of the n vectors vk, k ∈[n], are linearly independent. Proposition 1.1 shows\nthat for n = m the probability of that event is not zero, say δ, and is therefore at least 1 −(1 −δ)⌊n/m⌋for\narbitrary n. In other words, the probability increases rapidly with n. It is also clear from (5.3) that E[ ¯KΘ]\nscales linearly with n.\nFrom this intuitive derivation, we conclude that for suﬃciently large n, with high probability ¯KΘ is\na positive deﬁnite kernel with smallest eigenvalue λmin( ¯KΘ) scaling linearly with n. The properties of\n¯KΘ, in particular its positive deﬁniteness, have been studied much more rigorously as already described in\nSubsection 2.1.\n42\nControl of the gradient:\nApplying the expected behavior of the smallest eigenvalue λmin( ¯KΘ) of ¯KΘ\nto (5.2), we conclude that with high probability\n∥∇θr(Θ)∥2\n2 ≥\n4\nm2 λmin( ¯KΘ)∥(Φ(x(i), Θ) −y(i))m\ni=1∥2\n2 ≳n\nmr(Θ).\n(5.4)\nTo understand what will happen when applying gradient descent, we ﬁrst need to understand how the\nsituation changes in a neighborhood of Θ. We ﬁx x ∈Rd and observe that by the mean value theorem for all\n¯θ ∈B1(0) we have\n\r\r∇θΦ(x, Θ) −∇θΦ(x, Θ + ¯θ)\n\r\r2\n2 ≲\nsup\nˆθ∈B1(0)\n\r\r∇2\nθΦ(x, Θ + ˆθ)\n\r\r2\nop,\n(5.5)\nwhere ∥∇2\nθΦ(x, Θ + ˆθ)∥op denotes the operator norm of the Hessian of Φ(x, ·) at Θ + ˆθ. From inspection\nof (5.1), it is not hard to see that for all i, j ∈[n] and k, ℓ∈[d + 1]\nE\n\"\u0010∂2Φ(x, Θ)\n∂θ(2)\ni\n∂θ(2)\nj\n\u00112\n#\n= 0,\nE\n\"\u0010 ∂2Φ(x, Θ)\n∂θ(2)\ni\n∂(θ(1)\nj )k\n\u00112\n#\n≲δi,j,\nand\nE\n\"\u0010\n∂2Φ(x, Θ)\n∂(θ(1)\ni\n)k∂(θ(1)\nj )ℓ\n\u00112\n#\n≲δi,j\nn ,\nwhere δi,j = 0 if i ̸= j and δi,i = 1 for all i, j ∈[n]. For suﬃciently large n, we have that ∇2\nθΦ(x, Θ) is\nin expectation approximately a block band matrix with band-width d + 1. Therefore, we conclude that\nE\n\u0002\n∥∇2\nθΦ(x, Θ)∥2\nop\n\u0003\n≲1. Hence, we obtain by concentration of Gaussian random variables that with high\nprobability ∥∇2\nθΦ(x, Θ)∥2\nop ≲1. By the block-banded form of ∇2\nθΦ(x, Θ) we have that, even after perturbation\nof Θ by a vector ˆθ with norm bounded by 1, the term ∥∇2\nθΦ(x, Θ + ˆθ)∥2\nop is bounded, which yields that the\nright-hand side of (5.5) is bounded with high probability.\nUsing (5.5), we can extend (5.4), which holds with high probability, to a neighborhood of Θ by the\nfollowing argument: Let ¯θ ∈B1(0), then\n∥∇θr(Θ + ¯θ)∥2\n2 ≥\n4\nm2\n\r\r\r\nm\nX\ni=1\n∇θ(2)Φ(x(i), Θ + ¯θ)(Φ(x(i), Θ + ¯θ) −y(i))\n\r\r\r\n2\n2\n=\n(5.5)\n4\nm2\n\r\r\r\nm\nX\ni=1\n(∇θ(2)Φ(x(i), Θ) + O(1))(Φ(x(i), Θ + ¯θ) −y(i))\n\r\r\r\n2\n2\n≳\n(∗)\n1\nm2 (λmin( ¯KΘ) + O(1))∥(Φ(x(i), Θ + ¯θ) −y(i))m\ni=1∥2\n2\n≳n\nmr(Θ + ¯θ),\n(5.6)\nwhere the estimate marked by (∗) uses the positive deﬁniteness of ¯KΘ again and only holds for suﬃciently\nlarge n, so that the O(1) term is negligible.\nWe conclude that, with high probability over the initialization Θ, on a ball of ﬁxed radius around Θ the\nsquared Euclidean norm of the gradient of the empirical risk is lower bounded by n\nm times the empirical risk.\nExponential convergence of gradient descent:\nFor suﬃciently small step sizes η, the observation\nin the previous paragraph yields the following convergence rate for gradient descent as in Algorithm 1,\nspeciﬁcally (1.5), with m′ = m and Θ(0) = Θ: If ∥Θ(k) −Θ∥≤1 for all k ∈[K + 1], then25\nr(Θ(K+1)) ≈r(Θ(K)) −η∥∇θr(Θ(K))∥2\n2 ≤\n\u0010\n1 −cηn\nm\n\u0011\nr(Θ(K)) ≲\n\u0010\n1 −cηn\nm\n\u0011K\n,\n(5.7)\nfor c ∈(0, ∞) so that ∥∇θr(Θ(k))∥2\n2 ≥cn\nm r(Θ(k)) for all k ∈[K].\n25Note that the step-size η needs to be small enough to facilitate the approximation step in (5.7). Hence, we cannot simply\nput η = m/(cn) in (5.7) and have convergence after one step.\n43\nLet us assume without proof that the estimate (5.6) could be extended to an equivalence. In other words,\nwe assume that we additionally have that ∥∇θr(Θ + ¯θ)∥2\n2 ≲n\nmr(Θ + ¯θ). This, of course, could be shown with\nsimilar tools as were used for the lower bound. Then we have that ∥Θ(k) −Θ∥2 ≤1 for all k ≲\np\nm/(η2n).\nSetting t =\np\nm/(η2n) and using the limit deﬁnition of the exponential function, i.e., limt→∞(1−x/t)t = e−x,\nyields for suﬃciently small η that (5.7) is bounded by e−c√\nn/m.\nWe conclude that, with high probability over the initialization, gradient descent converges with an\nexponential rate to an arbitrary small empirical risk if the width n is suﬃciently large. In addition, the iterates\nof the descent algorithm even stay in a small ﬁxed neighborhood of the initialization during training. Because\nthe parameters only move very little, this type of training has also been coined lazy training [COB19].\nSimilar ideas as above, have led to groundbreaking convergence results of SGD for overparametrized NNs\nin much more complex and general settings, see, e.g., [DZPS18, LL18, AZLS19].\nIn the inﬁnite width limit, NN training is practically equivalent to kernel regression, see Subsection 2.1. If\nwe look at Figure 5.3 we see that the most overparametrized NN interpolates the data like a kernel-based\ninterpolator would. In a sense, which was also highlighted in [COB19], this shows that, while overparametrized\nNNs in the lazy training regime have very nice properties, they essentially act like linear methods.\n6\nTangible eﬀects of special architectures\nIn this section, we describe results that isolate the eﬀects of certain aspects of NN architectures. As we have\ndiscussed in Subsection 1.3, typically only either the depth or the number of parameters are used to study\ntheoretical aspects of NNs. We have seen instances of this throughout Sections 3 and 4. Moreover, also in\nSection 5, we saw that wider NNs enjoy certain very favorable properties from an optimization point of view.\nBelow, we introduce certain specialized NN architectures. We start with one of the most widely used\ntypes of NNs, the convolutional neural network (CNN). In Subsection 6.2 we introduce skip connections and\nin Subsection 6.3 we discuss a speciﬁc class of CNNs equipped with an encoder-decoder structure that are\nfrequently used in image processing techniques. We introduce the batch normalization block in Subsection 6.4.\nThen, we discuss sparsely connected NNs that typically result as an extraction from fully connected NNs in\nSubsection 6.5. Finally, we brieﬂy comment on recurrent neural networks in Subsection 6.6.\nAs we have noted repeatedly throughout this manuscript, it is impossible to give a full account of the\nliterature in a short introductory article. In this section, this issue is especially severe since the number of\nspecial architectures studied in practice is enormous. Therefore, we had to omit many very inﬂuential and\nwidely used neural network architectures. Among those are graph neural networks, which handle data from non-\nEuclidean input spaces. We refer to the survey articles [BBL+17, WPC+21] for a discussion. Another highly\nsuccessful type of architectures are (variational) autoencoders [AHS85, HZ94]. These are neural networks\nwith a bottleneck that enforce a more eﬃcient representation of the data. Similarly, generative adversarial\nnetworks [GPAM+14] which are composed of two neural networks, one generator and one discriminator,\ncould not be discussed here. Another widely used component of architectures used in practice is the so-called\ndropout layer. This layer functions through removing some neurons randomly during training. This procedure\nempirically prevents overﬁtting. An in-detail discussion of the mathematical analysis behind this eﬀect is\nbeyond the scope of this manuscript. We refer to [WZZ+13, SHK+14, HV17, MAV18] instead. Finally, the\nvery successful attention mechanism [BCB15, VSP+17], that is the basis of transformer neural networks, had\nto be omitted.\nBefore we start describing certain eﬀects of special NN architectures, a word of warning is required. The\nspecial building blocks, which will be presented below, have been developed based on a speciﬁc need in\napplications and are used and combined in a very ﬂexible way. To describe these tools theoretically without\ncompletely inﬂating the notational load, some simplifying assumptions need to be made. It is very likely that\nthe simpliﬁed building blocks do not accurately reﬂect the practical applications of these tools in all use cases.\n44\n6.1\nConvolutional neural networks\nEspecially for very high-dimensional inputs where the input dimensions are spatially related, fully connected\nNNs seem to require unnecessarily many parameters. For example, in image classiﬁcation problems, neigh-\nboring pixels very often share information and the spatial proximity should be reﬂected in the architecture.\nBased on this observation, it appears reasonable to have NNs that have local receptive ﬁelds in the sense\nthat they collect information jointly from spatially close inputs. In addition, in image processing, we are not\nnecessarily interested in a universal hypothesis set. A good classiﬁer is invariant under many operations, such\nas translation or rotation of images. It seems reasonable to hard-code such invariances into the architecture.\nThese two principles suggest that the receptive ﬁeld of a NN should be the same on diﬀerent translated\npatches of the input. In this sense, parameters of the architecture can be reused. Together, these arguments\nmake up the three fundamental principles of convolutional NNs: local receptive ﬁelds, parameter sharing,\nand equivariant representations, as introduced in [LBD+89]. We will provide a mathematical formulation of\nconvolutional NNs below and then revisit these concepts.\nA convolutional NN corresponds to multiple convolutional blocks, which are special types of layers. For\na group G, which typically is either [d] ∼= Z/(dZ) or [d]2 ∼= (Z/(dZ))2 for d ∈N, depending on whether we\nare performing one-dimensional or two-dimensional convolutions, the convolution of two vectors a, b ∈RG is\ndeﬁned as\n(a ∗b)i =\nX\nj∈G\najbj−1i,\ni ∈G.\nNow we can deﬁne a convolutional block as follows: Let eG be a subgroup of G, let p : G →eG be a so-called\npooling-operator, and let C ∈N denote the number of channels. Then, for a series of kernels κi ∈RG, i ∈[C],\nthe output of a convolutional block is given by\nRG ∋x 7→x′ := (p(x ∗κi))C\ni=1 ∈(R\ne\nG)C.\n(6.1)\nA typical example of a pooling operator is for G = (Z/(2dZ))2 and eG = (Z/(dZ))2 the 2 × 2 subsampling\noperator\np : RG →R\ne\nG,\nx 7→(x2i−1,2j−1)d\ni,j=1.\nPopular alternatives are average pooling or max pooling. These operations then either pass the average or the\nmaximum over patches of similar size. The convolutional kernels correspond to the aforementioned receptive\nﬁelds. They can be thought of as local if they have small supports, i.e., few nonzero entries.\nAs explained earlier, a convolutional NN is built by stacking multiple convolutional blocks after another26.\nAt some point, the output can be ﬂattened, i.e., mapped to a vector and is then fed into a FC NN (see\nDeﬁnition 1.4). We depict this setup in Figure 6.1.\nOwing to the fact that convolution is a linear operation, depending on the pooling operation, one may\nwrite a convolutional block (6.1) as a FC NN. For example, if G = (Z/(2dZ))2 and the 2 × 2 subsampling\npooling operator is used, then the convolutional block could be written as x 7→Wx for a block circulant\nmatrix W ∈R(Cd2)×(2d)2. Since we require W to have a special structure, we can interpret a convolutional\nblock as a special, restricted feed-forward architecture.\nAfter these considerations, it is natural to ask how the restriction of a NN to a pure convolutional\nstructure, i.e., consisting only of convolutional blocks, will aﬀect the resulting hypothesis set. The ﬁrst\nnatural question is whether the set of such NNs is still universal in the sense of Theorem 1.15. The answer to\nthis question depends strongly on the type of pooling and convolution that is allowed. If the convolution is\nperformed with padding, then the answer is yes [OS19, Zho20b]. On the other hand, for circular convolutions\nand without pooling, universality does not hold, but the set of translation equivariant functions can be\nuniversally approximated [Yar18b, PV20]. Furthermore, [Yar18b] illuminates the eﬀect of subsample pooling\nby showing that, if no pooling is applied, then universality cannot be achieved, whereas if pooling is applied\n26We assume that the deﬁnition of a convolutional block is suitably extended to input data in the Cartesian product (RG)C.\nFor instance, one can take an aﬃne linear combination of C mappings as in (6.1) acting on each coordinate. Moreover, one may\nalso interject an activation function between the blocks.\n45\nConvolution\nPooling\nConvolution\nPooling\nFully connected NN\nFigure 6.1: Illustration of a convolutional neural network with two-dimensional convolutional blocks and\n2 × 2 subsampling as pooling operation.\nthen universality is possible. The eﬀect of subsampling in CNNs from the viewpoint of approximation theory\nis further discussed in [Zho20a]. The role of other types of pooling in enhancing invariances of the hypothesis\nset will be discussed in Subsection 7.1 below.\n6.2\nResidual neural networks\nLet us ﬁrst illustrate a potential obstacle when training deep NNs. Consider for L ∈N the product operation\nRL ∋x 7→π(x) =\nL\nY\nℓ=1\nxℓ.\nIt is clear that\n∂\n∂xk\nπ(x) =\nL\nY\nℓ̸=k\nxℓ,\nx ∈RL.\nTherefore, for suﬃciently large L, we expect that\n\f\f ∂π\n∂xk\n\f\f will be exponentially small, if |xℓ| < λ < 1 for all\nℓ∈[L] or exponentially large, if |xℓ| > λ > 1 for all ℓ∈[L]. The output of a general NN, considered as a\ndirected graph, is found by repeatedly multiplying the input with parameters in every layer along the paths\nthat lead from the input to the output neuron. Due to the aforementioned phenomenon, it is often observed\nthat training NNs suﬀers from either the exploding or the vanishing gradient problem, which may prevent\nlower layers from training at all. The presence of an activation function is likely to exacerbate this eﬀect. The\nexploding or vanishing gradient problem seems to be a serious obstacle towards eﬃcient training of deep NNs.\nIn addition to the vanishing and exploding gradient problems, there is an empirically observed degradation\nproblem [HZRS16]. This phrase describes the phenomenon that FC NNs seem to achieve lower accuracy on\nboth the training and test data when increasing their depth.\nFrom an approximation theoretic perspective, deep NNs should always be superior to shallow NNs. The\nreason for this is that NNs with two layers can either exactly represent the identity map or approximate it\narbitrarily well. Concretely, for the ReLU activation function ϱR we have that x = ϱR(x + b) −b for x ∈Rd\nwith xi > −bi, where b ∈Rd. In addition, for any activation function ϱ which is continuously diﬀerentiable on\na neighborhood of some point λ ∈R with ϱ′(λ) ̸= 0 one can approximate the identity arbitrary well, see (1.8).\nBecause of this, extending a NN architecture by one layer can only enlarge the associated hypothesis set.\nTherefore, one may expect that the degradation problem is more associated with the optimization aspect\nof learning. This problem is addressed by a small change to the architecture of a feed-forward NN in [HZRS16].\n46\nidR3\nidR3\nidR3\nidR3\nFigure 6.2: Illustration of a neural network with residual blocks.\nInstead of deﬁning a FC NN Φ as in (1.1), one can insert a residual block in the ℓ-th layer by redeﬁning27\n¯Φ(ℓ)(x, θ) = ϱ(Φ(ℓ)(x, θ)) + ¯Φ(ℓ−1)(x, θ),\n(6.2)\nwhere we assume that Nℓ= Nℓ−1. Such a block can be viewed as the sum of a regular FC NN and the\nidentity which is referred to as skip connection or residual connection. A sketch of a NN with residual blocks\nis shown in Figure 6.2. Inserting a residual block in all layers leads to a so-called residual NN.\nA prominent approach to analyze residual NNs is by establishing a connection with optimal control\nproblems and dynamical systems [E17, TvG18, EHL19, LLS19, RH19, LML+20]. Concretely, if each layer of\na NN Φ is of the form (6.2), then we have that\n¯Φ(ℓ) −¯Φ(ℓ−1) = ϱ(Φ(ℓ)) =: h(ℓ, Φ(ℓ)),\nwhere we abbreviate ¯Φ(ℓ) = ¯Φ(ℓ)(x, θ) and set ¯Φ(0) = x. Hence, (¯Φ(ℓ))L−1\nℓ=0 corresponds to an Euler discretization\nof the ODE\n˙φ(t) = h(t, φ(t)),\nφ(0) = x,\nwhere t ∈[0, L −1] and h is an appropriate function.\nUsing this relationship, deep residual NNs can be studied in the framework of the well-established theory\nof dynamical systems, where strong mathematical guarantees can be derived.\n6.3\nFramelets and U-Nets\nOne of the most prominent application areas of deep NNs are inverse problems, particularly those in the ﬁeld\nof imaging science, see also Subsection 8.1. A speciﬁc architectural design of CNNs, namely so-called U-nets\nintroduced in [RFB15], seems to perform best for this range of problems. We depict a sketch of a U-net in\nFigure 6.3. However, a theoretical understanding of the success of this architecture was lacking.\nRecently, an innovative approach called deep convolutional framelets was suggested in [YHC18], which we\nnow brieﬂy explain. The core idea is to take a frame-theoretic viewpoint, see, e.g., [CKP12], and regard the\nforward pass of a CNN as a decomposition in terms of a frame (in the sense of a generalized basis). A similar\napproach will be taken in Subsection 7.2 for understanding the learned kernels using sparse coding. However,\nbased on the analysis and synthesis operators of the corresponding frame, the usage of deep convolutional\nframelets naturally leads to a theoretical understanding of encoder-decoder architectures, such as U-nets.\nLet us describe this approach for one-dimensional convolutions on the group G := Z/(dZ) with kernels\ndeﬁned on the subgroup H := Z/(nZ), where d, n ∈N with n < d, see also Subsection 6.1. We deﬁne\nthe convolution between u ∈RG and v ∈RH by zero-padding v, i.e., g ∗◦v := g ∗¯v, where ¯v ∈RG is\ndeﬁned by ¯vi = vi for i ∈H and ¯vi = 0 else. As an important tool, we consider the Hankel matrix\nHn(x) = (xi+j)i∈G,j∈H ∈Rd×n associated with x ∈RG. As one key property, matrix-vector multiplications\nwith Hankel matrices are translated to convolutions via28\n⟨e(i), Hn(x)v⟩=\nX\nj∈H\nxi+jvj = ⟨x, e(i) ∗◦v⟩,\ni ∈G,\n(6.3)\n27One can also skip multiple layers, e.g., in [HZRS16] two or three layers skipped, use a simple transformation instead of the\nidentity [SGS15], or randomly drop layers [HSL+16].\n28Here and in the following we naturally identify elements in RG and RH with the corresponding vectors in Rd and Rn.\n47\nFigure 6.3: Illustration of a simpliﬁed U-net neural network. Down-arrows stand for pooling, up arrows for\ndeconvolution or upsampling, right arrows for convolution or fully connected steps. Dashed lines are skip\nconnections.\nwhere e(i) := 1{i} ∈RG and v ∈RH, see [YGLD17]. Further, we can recover the k-th coordinate of x by the\nFrobenius inner product between Hn(x) and the Hankel matrix associated with e(k), i.e.,\n1\nnTr\n\u0000Hn(e(k))T Hn(x)\n\u0001\n= 1\nn\nX\nj∈H\nX\ni∈G\ne(k)\ni+jxi+j = 1\nn|H|xk = xk.\n(6.4)\nThis allows us to construct global and local bases as follows: Let p, q ∈N, let U =\n\u0002u1 · · · up\n\u0003\n∈Rd×p,\nV =\n\u0002v1 · · · vq\n\u0003\n∈Rn×q, eU =\n\u0002˜u1 · · · ˜up\n\u0003\n∈Rd×p, and eV =\n\u0002˜v1 · · · ˜vq\n\u0003\n∈Rn×q, and assume that\nHn(x) = eUU T Hn(x)V eV T .\n(6.5)\nFor p ≥d and q ≥n, this is, for instance, satisﬁed if U and V constitute frames with eU and eV being their\nrespective dual frames, i.e., eUU T = Id and V eV T = In. As a special case, one can consider orthonormal bases\nU = eU and V = eV with p = d and q = n. In the case p = q = r ≤n, where r is the rank of Hn(x), one can\nestablish (6.5) by choosing the left and right singular vectors of Hn(x) as U = eU and V = eV , respectively.\nThe identity in (6.5), in turn, ensures the following decomposition:\nx = 1\nn\np\nX\ni=1\nq\nX\nj=1\n⟨x, ui ∗◦vj⟩˜ui ∗◦˜vj.\n(6.6)\nObserving that the vector vj ∈RH interacts locally with x ∈RG due to the fact that H ⊂G, whereas\nui ∈RG acts on the entire vector x, we refer to (vj)q\nj=1 as local and (ui)p\ni=1 as global bases. In the context of\nCNNs, vi can be interpreted as local convolutional kernel and ui as pooling operation29. The proof of (6.6)\n29Note that ⟨x, ui ∗◦vj⟩can also be interpreted as ⟨ui, vj ⋆x⟩, where ⋆denotes the cross-correlation between the zero-padded\nvj and x. This is in line with software implementations for deep learning applications, e.g., TensorFlow and PyTorch, where\ntypically cross-correlations are used instead of convolutions.\n48\nfollows directly from properties (6.3), (6.4), and (6.5) as\nxk = 1\nnTr\n\u0000Hn(e(k))T Hn(x)\n\u0001\n= 1\nnTr\n\u0000Hn(e(k))T eUU T Hn(x)V eV T \u0001\n= 1\nn\np\nX\ni=1\nq\nX\nj=1\n⟨ui, Hn(x)vj⟩⟨˜ui, Hn(e(k))˜vj⟩.\nThe decomposition in (6.6) can now be interpreted as a composition of an encoder and a decoder,\nx 7→C = (⟨x, ui ∗◦vj⟩)i∈[p],j∈[q]\nand\nC 7→1\nn\np\nX\ni=1\nq\nX\nj=1\nCi,j ˜ui ∗◦˜vj,\n(6.7)\nwhich relates it to CNNs equipped with an encoder-decoder structure such as U-nets, see Figure 6.3.\nGeneralizing this approach to multiple channels, it is possible to stack such encoders and decoders which\nleads to a layered version of (6.6). In [YHC18] it is shown that one can make an informed decision on the\nnumber of layers based on the rank of Hn(x), i.e., the complexity of the input features x. Moreover, also an\nactivation function such as the ReLU or bias vectors can be included. The key question one can then ask is\nhow the kernels can be chosen to obtain sparse coeﬃcients C in (6.7) and a decomposition such as (6.6), i.e.,\nperfect reconstruction. If U and V are chosen as the left and right singular vectors of Hn(x), one obtains a\nvery sparse, however input-dependent, representation in (6.6) due to the fact that\nCi,j = ⟨x, ui ∗◦vj⟩= ⟨ui, Hn(x)vj⟩= 0,\ni ̸= j.\nFinally, using the framework of deep convolutional framelets, theoretical reasons for including skip connections\ncan be derived, since they aid to obtain a perfect reconstruction.\n6.4\nBatch normalization\nBatch normalization is a building block of NNs that was invented in [IS15] with the goal to reduce so-called\ninternal covariance shift. In essence, this phrase describes the (undesirable) situation where during training\neach layer receives inputs with diﬀerent distribution. A batch normalization block is deﬁned as follows: For\npoints b = (y(i))m\ni=1 ∈(Rn)m and β, γ ∈R, we deﬁne\nBN(β,γ)\nb\n(y) := γ y −µb\nσb\n+ β,\ny ∈Rn,\nwith\nµb = 1\nm\nm\nX\ni=1\ny(i)\nand\nσ2\nb = 1\nm\nm\nX\ni=1\n(y(i) −µb)2,\n(6.8)\nwhere all operations are to be understood componentwise, see Figure 6.4.\nSuch a batch normalization block can be added into a NN architecture. Then b is the output of the\nprevious layer over a batch or the whole training data30. Furthermore, the parameters β, γ are variable and\ncan be learned during training. Note that, if one sets β = µb and γ = σb, then BN(β,γ)\nb\n(y) = y for all y ∈Rn.\nTherefore, a batch normalization block does not negatively aﬀect the expressivity of the architecture. On the\nother hand, batch normalization does have a tangible eﬀect on the optimization aspects of deep learning.\nIndeed, in [STIM18, Theorem 4.1], the following observation was made:\n30In practice, one typically uses a moving average to estimate the mean µ and the standard deviation σ of the output of the\nprevious layer over the whole training data by only using batches.\n49\nµb σb\nβ\nγ\nby = y−µb\nσb\nz = γby + β\nFigure 6.4: A batch normalization block after a fully connected neural network. The parameters µb, σb are\nthe mean and the standard deviation of the output of the fully connected network computed over a batch s,\ni.e., a set of inputs. The parameters β, γ are learnable parts of the batch normalization block.\nProposition 6.1 (Smoothening eﬀect of batch normalization). Let m ∈N with m ≥2 and for every β, γ ∈R\ndeﬁne B(β,γ) : Rm →Rm by\nB(β,γ)(b) = (BN(β,γ)\nb\n(y(1)), . . . , BN(β,γ)\nb\n(y(m))),\nb = (y(i))m\ni=1 ∈Rm,\nwhere BN(β,γ)\nb\nis given as in (6.8). Let β, γ ∈R and let r: Rm →R be a diﬀerentiable function. Then it\nholds for every b ∈Rm that\n∥∇(r ◦B(β,γ))(b)∥2\n2 = γ2\nσ2\nb\n\u0000∥∇r(b)∥2 −1\nm⟨1, ∇r(b)⟩2 −1\nm⟨B(0,1)(b), ∇r(b)⟩2\u0001\n,\nwhere 1 = (1, . . . , 1) ∈Rm and σ2\nb is given as in (6.8).\nFor multi-dimensional y(i) ∈Rn, i ∈[m], the same statement holds for all components as, by deﬁnition,\nthe batch normalization block acts componentwise. Proposition 6.1 follows from a convenient representation\nof the Jacobian of the mapping B(β,γ), given by\n∂B(β,γ)(b)\n∂b\n= γ\nσb\n\u0010\nIm −1\nm11T −1\nmB(0,1)(b)(B(0,1)(b))T \u0011\n,\nb ∈Rm,\nand the fact that {\n1\n√m,\n1\n√mB(0,1)(b)} constitutes an orthonormal set.\nChoosing r to mimic the empirical risk of a learning task, Proposition 6.1 shows that, in certain situations—\nfor instance, if γ is smaller than σb or if m is not too large—a batch normalization block can considerably\nreduce the magnitude of the derivative of the empirical risk with respect to the input of the batch normalization\nblock. By the chain rule, this implies that also the derivative of the empirical risk with respect to NN\nparameters inﬂuencing the input of the batch normalization block is reduced.\nInterestingly, a similar result holds for second derivatives [STIM18, Theorem 4.2] if r is twice diﬀerentiable.\nOne can conclude that adding a batch normalization block increases the smoothness of the optimization\nproblem. Since the parameters β and γ were introduced, including a batch normalization block also increases\nthe dimension of the optimization problem by two.\n6.5\nSparse neural networks and pruning\nFor deep FC NNs, the number of trainable parameters usually scales like the square of the number of neurons.\nFor reasons of computational complexity and memory eﬃciency, it appears sensible to seek for techniques to\nreduce the number of parameters or extract sparse subnetworks (see Figure 6.5) without aﬀecting the output\n50\nFigure 6.5: A neural network with\nsparse connections.\nof a NN much. One way to do this is by pruning [LDS89, HMD16].\nHere, certain parameters of a NN are removed after training. This\nis done, for example, by setting these parameters to zero.\nIn this context, the lottery ticket hypothesis was formulated\nin [FC18]. It states: “A randomly-initialized, dense NN contains a\nsubnetwork that is initialized such that—when trained in isolation—it\ncan match the test accuracy of the original NN after training for at\nmost the same number of iterations”. In [RWK+20] a similar hy-\npothesis was made and empirically studied. There, it is claimed that,\nfor a suﬃciently overparametrized NN, there exists a subnetwork\nthat matches the performance of the large NN after training without\nbeing trained itself, i.e., already at initialization.\nUnder certain simplifying assumptions, the existence of favorable subnetworks is quite easy to prove. We\ncan use a technique that was previously indirectly used in Subsection 4.2—the Carath´eodory Lemma. This\nresult states the following: Let n ∈N, C ∈(0, ∞), and let (H, ∥· ∥) be a Hilbert space. Let F ⊂H with\nsupf∈F ∥f∥≤C and let g ∈H be in the convex hull of F. Then there exist fi ∈F, i ∈[n], and c ∈[0, 1]n\nwith ∥c∥1 = 1 such that\n\r\r\r\r\rg −\nn\nX\ni=1\ncifi\n\r\r\r\r\r ≤C\n√n,\nsee, e.g., [Ver18, Theorem 0.0.2].\nProposition 6.2 (Carath´eodory pruning). Let d, n ∈N, with n ≥100 and let µ be a probability measure\non the unit ball B1(0) ⊂Rd. Let a = ((d, n, 1), ϱR) be the architecture of a two-layer ReLU network and let\nθ ∈RP ((d,n,1)) be corresponding parameters such that\nΦa(·, θ) =\nn\nX\ni=1\nw(2)\ni\nϱR(⟨(w(1)\ni\n, ·⟩+ b(1)\ni )),\nwhere (w(1)\ni\n, b(1)\ni ) ∈Rd × R, i ∈[n], and w(2) ∈Rn. Assume that for every i ∈[n] it holds that ∥w(1)\ni\n∥2 ≤1/2\nand b(1)\ni\n≤1/2. Then there exists a parameter ˜θ ∈RP ((d,n,1)) with at least 99% of its entries being zero such\nthat\n∥Φa(·, θ) −Φa(·, ˜θ)∥L2(µ) ≤15∥w(2)∥1\n√n\n.\nSpeciﬁcally, there exists an index set I ⊂[n] with |I| ≤n/100 such that ˜θ satisﬁes that\new(2)\ni\n= 0,\nif i /∈I,\nand\n( ew(1)\ni\n,˜b(1)\ni ) =\n(\n(w(1)\ni\n, b(1)\ni ),\nif i ∈I,\n(0, 0),\nif i /∈I.\nThe result is clear if w(2) = 0. Otherwise, deﬁne\nfi := ∥w(2)∥1ϱR(⟨w(1)\ni\n, ·⟩+ b(1)\ni ),\ni ∈[n],\nand observe that Φa(·, θ) is in the convex hull of {fi}n\ni=1 ∪{−fi}n\ni=1. Moreover, by the Cauchy–Schwarz\ninequality, it holds that\n∥fi∥L2(µ) ≤∥w(2)∥1∥fi∥L∞(B1(0)) ≤∥w(2)∥1.\nWe conclude with the Carath´eodory Lemma that there exists I ⊂[n] with |I| = ⌊n/100⌋≥n/200 and\nci ∈[−1, 1], i ∈I, such that\n\r\r\r\r\rΦa(·, θ) −\nX\ni∈I\ncifi\n\r\r\r\r\r\nL2(µ)\n≤∥w(2)∥1\np\n|I|\n≤\n√\n200∥w(2)∥1\n√n\n,\n51\nwhich yields the result.\nProposition 6.2 shows that certain, very wide NNs can be approximated very well by sparse subnetworks\nwhere only the output weight matrix needs to be changed. The argument of Proposition 6.2 is inspired\nby [BK18], where a much more reﬁned result is shown for deep NNs.\n6.6\nRecurrent neural networks\nFigure 6.6: Sketch of a recurrent neu-\nral network. Cycles in the computa-\ntional graph incorporate the sequen-\ntial structure of the input and output.\nRecurrent NNs are NNs where the underlying graph is allowed to\nexhibit cycles as in Figure 6.6, see [Hop82, RHW86, Elm90, Jor90].\nPreviously, we had excluded cyclic computational graphs. For a feed-\nforward NN, the computation of internal states is naturally performed\nstep by step through the layers. Since the output of a layer does\nnot aﬀect previous layers, the order in which the computations of\nthe NN are performed corresponds to the order of the layers. For\nrecurrent NNs, the concept of layers does not exist, and the order\nof operations is much more delicate. Therefore, one considers time\nsteps. In each time step, all possible computations of the graph are\napplied to the current state of the NN. This yields a new internal\nstate. Given that time steps arise naturally from the deﬁnition of\nrecurrent NNs, this NN type is typically used for sequential data.\nIf the input to a recurrent NN is a sequence, then every input determines the internal state of the recurrent\nNN for the following inputs. Therefore, one can claim that these NNs exhibit a memory. This fact is extremely\ndesirable in natural language processing, which is why recurrent NNs are widely used in this application.\nRecurrent NNs can be trained similarly to regular feed-forward NNs by an algorithm called backpropagation\nthrough time [MP69, Wer88, WZ95]. This procedure essentially unfolds the recurrent structure yielding a\nclassical NN structure. However, the algorithm may lead to very deep structures. Due to the vanishing\nand exploding gradient problem discussed earlier, very deep NNs are often hard to train. Because of this,\nspecial recurrent structures were introduced that include gates which prohibit too many recurrent steps; these\ninclude the widely used LSTMs [HS97].\nThe application area of recurrent NNs is typically quite diﬀerent from that of regular NNs since they\nare specialized on sequential data. Therefore, it is hard to quantify the eﬀect of a recurrent connection on\na fully connected NN. However, it is certainly true that with recurrent connections certain computations\ncan be performed much more eﬃciently than with feed-forward NN structures. A particularly interesting\nconstruction can be found in [BF19, Theorem 4.4], where it is shown that a ﬁxed size, recurrent NN with\nReLU activation function, can approximate the function x 7→x2 to any desired accuracy. The reason for\nthis eﬃcient representation can be seen when considering the self-referential deﬁnition of the approximant to\nx −x2 shown in Figure 3.2.\nOn the other hand, with feed-forward NNs, it transpires from Theorem 3.3 that the approximation error\nof ﬁxed-sized ReLU NNs for any non-aﬃne function is greater than a positive lower bound.\n7\nDescribing the features a deep neural network learns\nThis section presents two viewpoints which help in understanding the nature of features that can be described\nby NNs. Section 7.1 summarizes aspects of the so-called scattering transform which constitutes a speciﬁc NN\narchitecture that can be shown to satisfy desirable properties, such as translation and deformation invariance.\nSection 7.2 relates NN features to the current paradigm of sparse coding.\n7.1\nInvariances and the scattering transform\nOne of the ﬁrst theoretical contributions to the understanding of the mathematical properties of CNNs\nis [Mal12]. The approach taken in that work is to consider speciﬁc CNN architectures with ﬁxed parameters\n52\nthat result in a stand-alone feature descriptor whose output may be fed into a subsequent classiﬁer (for example,\na kernel support vector machine or a trainable FC NN). From an abstract point of view, a feature descriptor\nis a function Ψ mapping from a signal space, such as L2(Rd) or the space of piecewise smooth functions, to\na feature space. In an ideal world, such a classiﬁer should “factor” out invariances that are irrelevant to a\nsubsequent classiﬁcation problem while preserving all other information of the signal. A very simple example\nof a classiﬁer which is invariant under translations is the Fourier modulus Ψ: L2(Rd) →L2(Rd), u 7→|ˆu|.\nThis follows from the fact that a translation of a signal u results in a modulation of its Fourier transform, i.e.,\n\\\nu(· −τ)(ω) = e−2πi⟨τ,ω⟩ˆu(ω), τ, ω ∈Rd. Furthermore, in most cases (for example, if u is a generic compactly\nsupported function [GKR20]), u can be reconstructed up to a translation from its Fourier modulus [GKR20]\nand an energy conservation property of the form ∥Ψ(u)∥L2 = ∥u∥L2 holds true. Translation invariance is,\nfor example, typically exhibited by image classiﬁers, where the label of an image does not change if it is\ntranslated.\nIn practical problems many more invariances arise. Providing an analogous representation that factors\nout general invariances would lead to a signiﬁcant reduction in the problem dimensionality and constitutes an\nextremely promising route towards dealing with the very high dimensionality that is commonly encountered\nin practical problems [Mal16]. This program is carried out in [Mal12] for additional invariances with respect\nto deformations u 7→uτ := u(· −τ(·)), where τ : Rd →Rd is a smooth mapping. Such transformations may\noccur in practice, for instance, as image warpings. In particular, a feature descriptor Ψ is designed that, with\na suitable norm ∥· ∥on the image of Ψ,\n(a) is Lipschitz continuous with respect to deformations in the sense that ∥Ψ(u) −Ψ(uτ)∥≲K(τ, ∇τ, ∇2τ)\nholds for some K that only mildly depends on τ and essentially grows linearly in ∇τ and ∇2τ,\n(b) is almost (i.e., up to a small and controllable error) invariant under translations of the input data, and\n(c) contains all relevant information on the input data in the sense that an energy conservation property\n∥Ψ(u)∥≈∥u∥L2\nholds true.\nObserve that, while the action of translations only represents a d-parameter group, the action of deforma-\ntions/warpings represents an inﬁnite-dimensional group. Hence, a deformation invariant feature descriptor\nrepresents a big potential for dimensionality reduction. Roughly speaking, the feature descriptor Ψ of [Mal12]\n(also coined the scattering transform) is deﬁned by collecting features that are computed by iteratively\napplying a wavelet transform followed by a pointwise modulus non-linearity and a subsequent low-pass\nﬁltering step, i.e.,\n|||u ∗ψj1| ∗ψj2 ∗. . . | ∗ψjℓ| ∗ϕJ,\nwhere ψj refers to a wavelet at scale j and ϕJ refers to a scaling function at scale J. The collection of all\nthese so-called scattering coeﬃcients can then be shown to satisfy the properties in (a)–(c) above in a suitable\n(asymptotic) sense. The proof of this result relies on a subtle interplay between a “deformation covariance”\nproperty of the wavelet transform and a “regularizing” property of the operation of convolution with the\nmodulus of a wavelet. We remark that similar results can be shown also for diﬀerent systems, such as Gabor\nframes [WGB17, CL19].\n7.2\nHierarchical sparse representations\nThe previous approach modeled the learned features by a speciﬁc dictionary, namely wavelets. It is well known\nthat one of the striking properties of wavelets is to provide sparse representations for functions belonging to\ncertain function classes. More generally, we speak of sparse representations with respect to a representation\nsystem. For a vector x ∈Rd, a sparsifying representation system D ∈Rd×p—also called dictionary—is such\nthat x = Dφ with the coeﬃcients φ ∈Rp being sparse in the sense that ∥φ∥0 := | supp(φ)| = |{i ∈[p]: φi ̸= 0}|\nis small compared to p. A similar deﬁnition can be made for signals in inﬁnite-dimensional spaces. Taking\n53\nsparse representations into account, the theory of sparse coding provides an approach to a theoretical\nunderstanding of the features a deep NN learns.\nOne common method in image processing is the utilization of not the entire image but overlapping patches\nof it, coined patch-based image processing. Thus of particular interest are local dictionaries which sparsify\nthose patches, but presumably not the global image. This led to the introduction of the convolutional sparse\ncoding model (CSC model), which links such local and global behaviors. Let us describe this model for\none-dimensional convolutions on the group G := Z/(dZ) with kernels supported on the subgroup H := Z/(nZ),\nwhere d, n ∈N with n < d, see also Subsection 6.1. The corresponding CSC model is based on a decomposition\nof a global signal x ∈(RG)c with c ∈N channels as\nxi =\nC\nX\nj=1\nκi,j ∗φj,\ni ∈[c],\n(7.1)\nwhere φ ∈(RG)C is supposed to be a sparse representation with C ∈N channels and κi,j ∈RG, i ∈[c],\nj ∈[C], are local kernels with supp(κi,j) ⊂H. Let us consider a patch ((xi)g+h)i∈[c],h∈H of n adjacent entries,\nstarting at position g ∈G, in each channel of x. The condition on the support of the kernels κi,j and the\nrepresentation in (7.1) imply that this patch is only aﬀected by a stripe of at most (2n −1) entries in each\nchannel of φ. The local, patch-based sparsity of the representation φ can thus be appropriately measured via\n∥φ∥(n)\n0,∞:= max\ng∈G ∥((φj)g+k)j∈[C],k∈[2n−1]∥0,\nsee [PSE17]. Furthermore, note that we can naturally identify x and φ with vectors in Rdc and RdC and write\nx = Dφ, where D ∈Rdc×dC is a matrix consisting of circulant blocks, typically referred to as a convolutional\ndictionary.\nThe relation between the CSC model and deep NNs is revealed by applying the CSC model in a layer-wise\nfashion [PRE17, SPRE18, PRSE18]. To see this, let C0 ∈N and for every ℓ∈[L] let Cℓ, kℓ∈N and let\nD(ℓ) ∈RdCℓ−1×dCℓbe a convolutional dictionary with kernels supported on Z/(nℓZ). A signal x = φ(0) ∈RdC0\nis said to belong to the corresponding multi-layered CSC model (ML-CSC model) if there exist coeﬃcients\nφ(ℓ) ∈RdCℓwith\nφ(ℓ−1) = D(ℓ)φ(ℓ)\nand\n∥φ(ℓ)∥(nℓ)\n0,∞≤kℓ,\nℓ∈[L].\n(7.2)\nWe now consider the problem of reconstructing the sparse coeﬃcients (φ(ℓ))L\nℓ=1 from a noisy signal ˜x := x + ν,\nwhere the noise ν ∈RdC0 is assumed to have small ℓ2-norm and x is assumed to follow the ML-CSC model\nin (7.2). In general, this problem is NP-hard. However, under suitable conditions on the ML-CSC model, it\ncan be approximately solved, for instance, by a layered thresholding algorithm.\nMore precisely, for D ∈Rdc×dC and b ∈RdC, we deﬁne a soft-thresholding operator by\nTD,b(x) := ϱR(DT x −b) −ϱR(−DT x −b),\nx ∈Rdc,\n(7.3)\nwhere ϱR(x) = max{0, x} is applied componentwise. If x = Dφ as in (7.1), we obtain φ ≈TD,b(x) roughly\nunder the following conditions: The distance of φ and ψ := DT x = DT Dφ can be bounded using the local\nsparsity of φ and the mutual coherence and locality of the kernels of the convolutional dictionary D. For a\nsuitable threshold b, the mapping ψ 7→ϱR(ψ −b) −ϱR(−ψ −b) further recovers the support of φ by nullifying\nentries of ψ with ψi ≤|bi|. Utilizing the soft-thresholding operator (7.3) iteratively for corresponding vectors\nb(ℓ) ∈RdCℓ, ℓ∈[L], then suggests the following approximations:\nφ(ℓ) ≈(TD(ℓ),b(ℓ) ◦· · · ◦TD(1),b(1))(˜x),\nℓ∈[L].\nThe resemblance with the realization of a CNN with ReLU activation function is evident. The transposed\ndictionary (D(ℓ))T can be regarded as modeling the learned convolutional kernels, the threshold b(ℓ) models\nthe bias vector, and the soft-thresholding operator TD(ℓ),b(ℓ) mimics the application of a convolutional block\nwith a ReLU non-linearity in the ℓ-th layer.\n54\nUsing this model, a theoretical understanding of CNNs from the perspective of sparse coding is now at\nhand. This novel perspective gives a precise mathematical meaning of the kernels in a CNN as sparsifying\ndictionaries of an ML-CSC model. Moreover, the forward pass of a CNN can be understood as a layered\nthresholding algorithm for decomposing a noisy signal ˜x. The results derived are then of the following ﬂavor:\nGiven a suitable reconstruction procedure such as thresholding or ℓ1-minimization, the sparse coeﬃcients\n(φ(ℓ))L\nℓ=1 of a signal x following a ML-CSC model can be stably recovered from the noisy signal ˜x under\ncertain hypotheses on the ingredients of the ML-CSC model.\n8\nEﬀectiveness in natural sciences\nThe theoretical insights of the previous sections do not always accurately describe the performance of NNs in\napplications. Indeed, there often exists a considerable gap between the predictions of approximation theory\nand the practical performance of NNs [AD20].\nIn this section, we consider concrete applications which have been very successfully solved with deep-\nlearning-based methods. In Section 8.1 we present an overview of deep-learning-based algorithms applied to\ninverse problems. Section 8.2 then continues by describing how NNs can be used as a numerical ansatz for\nsolving PDEs, highlighting their use in the solution of the multi-electron Schr¨odinger equation.\n8.1\nDeep neural networks meet inverse problems\nThe area of inverse problems, predominantly in imaging, was presumably the ﬁrst class of mathematical\nmethods embracing deep learning with overwhelming success. Let us consider a forward operator K : Y →X\nwith X, Y being Hilbert spaces and the associated inverse problem of ﬁnding y ∈Y such that Ky = x for\ngiven features x ∈X. The classical model-based approach to regularization aims to approximate K by\ninvertible operators, and is hence strongly based on functional analytic principles. Today, such approaches\ntake well-posedness of the approximation, convergence properties, as well as the structure of regularized\nsolutions into account. The last item allows to incorporate prior information of the original solution such as\nregularity, sharpness of edges, or—in the case of sparse regularization [JMS17]—a sparse coeﬃcient sequence\nwith respect to a prescribed representation system. Such approaches are typically realized in a variational\nsetting and hence aim to minimize functionals of the form\n∥Ky −x∥2 + αR(y),\nwhere α ∈(0, ∞) is a regularization parameter, R: Y →[0, ∞) a regularization term, and ∥· ∥denotes the\nnorm on Y. As said, the regularization term aims to model structural information about the desired solution.\nHowever, one main hurdle in this approach is the problem that typically solution classes such as images from\ncomputed tomography cannot be modeled accurately enough to, for instance, allow reconstruction under the\nconstraint of a signiﬁcant amount of missing features.\nThis has opened the door to data-driven approaches, and recently, deep NNs. Solvers of inverse problems\nwhich are based on deep learning techniques can be roughly categorized into three classes:\n1. Supervised approaches: The most straightforward approach is to train a NN Φ(·, θ): X →Y end-to-end,\ni.e., to completely learn the map from data x to the solution y. More advanced approaches in this\ndirection incorporate information about the operator K into the NN such as in [A¨O17, GOW19, MLE21].\nYet another type of approaches aims to combine deep NNs with classical model-based approaches.\nThe ﬁrst suggestion in this realm was to start by applying a standard solver, followed by a deep NN\nΦ(·, θ): Y →Y which serves as a denoiser for speciﬁc reconstruction artifacts, e.g., [JMFU17]. This\nwas followed by more sophisticated methods such as plug-and-play frameworks for coupling inversion\nand denoising [REM17].\n2. Semi-supervised approaches: These type of approaches aim to encode the regularization by a deep NN\nΦ(·, θ): Y →[0, ∞). The underlying idea is often to require stronger regularization on solutions y(i)\n55\nthat are more prone to artifacts or other eﬀects of the instability of the problem. On solutions where\ntypically few artifacts are observed less regularization can be used. Therefore, the learning algorithm\nonly requires a set of labels (y(i))m\ni=1 as well as a method to assess how hard the inverse problem for this\nlabel would be. In this sense, the algorithm can be considered semi-supervised. This idea was followed,\nfor example, in [L¨OS18, LSAH20]. Taking a Bayesian viewpoint, one can also learn prior distributions\nas deep NNs, which was done in [BZAJ20].\n3. Unsupervised approaches: One highlight of what we might coin unsupervised approaches in our problem\nsetting is the introduction of deep image priors in [DKMB20, UVL18]. The key idea is to parametrize\nthe solutions y as the output of a NN Φ(ξ, ·): P →Y with parameters in a suitable space P, applied to\na ﬁxed input ξ. Then, for given features x, one tries to solve minθ∈P ∥KΦ(ξ, θ) −x∥2 in order to obtain\nparameters ˆθ ∈P that yield a solution candidate y = Φ(ξ, ˆθ). Here often early stopping is applied in\nthe training of the network parameters.\nAs can be seen, one key conceptual question is how to “take the best out of both worlds”, in the sense\nof optimally combining classical (model-based) methods—in particular the forward operator K—with deep\nlearning. This is certainly sensitively linked to all characteristics of the particular application at hand, such\nas availability and accuracy of training data, properties of the forward operator, or requirements for the\nsolution. And each of the three classes of hybrid solvers follows a diﬀerent strategy.\nLet us now discuss advantages and disadvantages of methods from the three categories with a particular\nfocus on a mathematical foundation. Supervised approaches suﬀer on the one hand from the problem that\noften ground-truth data is not available or only in a very distorted form, leading to the fact that synthetic\ndata constitutes a signiﬁcant part of the training data. Thus the learned NN will mainly perform as well as\nthe algorithm which generated the data, but not signiﬁcantly improve it—only from an eﬃciency viewpoint.\nOn the other hand, the inversion is often highly ill-posed, i.e., the inversion map has a large Lipschitz constant,\nwhich negatively aﬀects the generalization ability of the NN. Improved approaches incorporate knowledge\nabout the forward operator K as discussed, which helps to circumvent this issue.\nOne signiﬁcant advantage of semi-supervised approaches is that the underlying mathematical model of\nthe inverse problem is merely augmented by the neural network-based regularization. Assuming that the\nlearned regularizer satisﬁes natural assumptions, convergence proofs or stability estimates for the resulting\nregularized methods are still available.\nFinally, unsupervised approaches have the advantage that the regularization is then fully due to the\nspeciﬁc architecture of the deep NN. This makes these methods slightly easier to understand theoretically,\nalthough, for instance, the deep prior approach in its full generality is still lacking a profound mathematical\nanalysis.\n8.2\nPDE-based models\nBesides applications in image processing and artiﬁcial intelligence, deep learning methods have recently\nstrongly impacted the ﬁeld of numerical analysis. In particular, regarding the numerical solution of high-\ndimensional PDEs. These PDEs are widely used as a model for complex processes and their numerical\nsolution presents one of the biggest challenges in scientiﬁc computing. We mention three exemplary problem\nclasses:\n1. Black–Scholes model: The Nobel award-winning theory of Fischer Black, Robert Merton, and Myron\nScholes proposes a linear PDE model for the determination of a fair price of a (complex) ﬁnancial\nderivative. The dimensionality of the model corresponds to the number of ﬁnancial assets which is\ntypically quite large. The classical linear model, which can be solved eﬃciently via Monte Carlo methods\nis quite limited. In order to take into account more realistic phenomena such as default risk, the PDE\nthat models a fair price becomes nonlinear, and much more challenging to solve. In particular (with the\nnotable exception of Multilevel Picard algorithms [EHJK19]) no general algorithm exists that provably\nscales well with the dimension.\n56\n2. Schr¨odinger equation: The electronic Schr¨odinger equation describes the stationary nonrelativistic\nbehavior of a quantum mechanical electron system in the electric ﬁeld generated by the nuclei of\na molecule. Its numerical solution is required to obtain stable molecular conﬁgurations, compute\nvibrational spectra, or obtain forces governing molecular dynamics. If the number of electrons is large,\nthis is again a high-dimensional problem and to date there exist no satisfactory algorithms for its\nsolution: It is well known that diﬀerent gold standard methods may produce completely diﬀerent energy\npredictions, for example, when applied to large delocalized molecules, rendering these methods useless\nfor those problems.\n3. Hamilton–Jacobi–Bellman equation: The Hamilton–Jacobi–Bellman (HJB) equation models the value\nfunction of (deterministic or stochastic) optimal control problems. The underlying dimensionality of the\nmodel corresponds to the dimension of the space of states to be controlled and tends to be rather high\nin realistic applications. The high dimensionality, together with the fact that HJB equations typically\ntend to be fully nonlinear with non-smooth solutions, renders the numerical solution of HJB equations\nextremely challenging and no general algorithms exist for this problem.\nDue to the favorable approximation results of NNs for high-dimensional functions (see especially Subsec-\ntion 4.3), it might not come as a surprise that a NN ansatz has proven to be quite successful in solving the\naforementioned PDE models. A pioneering work in this direction is [HJE18] which uses the backwards SDE\nreformulation of semilinear parabolic PDEs to reformulate the evaluation of such a PDE at a speciﬁc point as\nan optimization problem that can be solved by the deep learning paradigm. The resulting algorithm proves\nquite successful in the high-dimensional regime and, for instance, enables the eﬃcient modeling of complex\nﬁnancial derivatives including nonlinear eﬀects such as default risk. Another approach speciﬁcally tailored to\nthe numerical solution of HJB equations is [NZGK21]. In this work, one uses the Pontryagin principle to\ngenerate samples of the PDE solution along solutions of the corresponding boundary value problem. Other\nnumerical approaches include the Deep Ritz Method [EY18], where a Dirichlet energy is minimized over a\nset of NNs, or so-called Physics Informed Neural Networks [RPK19], where typically the PDE residual is\nminimized along with some natural constraints, for instance, to enforce boundary conditions.\nDeep-learning-based methods arguably work best if they are combined with domain knowledge to inspire\nNN architecture choices. We would like to illustrate this interplay at the hand of a speciﬁc and extremely\nrelevant example: the electronic Schr¨odinger equation (under the Born–Oppenheimer approximation) which\namounts to ﬁnding the smallest nonzero eigenvalue of the eigenvalue problem\nHRψ = λψψ,\n(8.1)\nfor ψ: R3×n →R, where the Hamiltonian\n(HRψ)(r) = −\nn\nX\ni=1\n1\n2(∆riψ)(r) −\n\n\nn\nX\ni=1\np\nX\nj=1\nZj\n∥ri −Rj∥2\n−\np−1\nX\ni=1\np\nX\nj=i+1\nZiZj\n∥Ri −Rj∥2\n−\nn−1\nX\ni=1\nn\nX\nj=i+1\n1\n∥ri −rj∥2\n\nψ(r)\ndescribes the kinetic energy (ﬁrst term) as well as Coulomb attraction force between electrons and nuclei\n(second and third term) and the Coulomb repulsion force between diﬀerent electrons (third term). Here,\nthe coordinates R =\n\u0002R1 . . . Rp\n\u0003\n∈R3×p refer to the positions of the nuclei, (Zi)p\ni=1 ∈Np denote the atomic\nnumbers of the nuclei, and the coordinates r =\n\u0002r1, . . . , rn\n\u0003\n∈R3×n refer to the positions of the electrons.\nThe associated eigenfunction ψ describes the so-called wavefunction which can be interpreted in the sense\nthat |ψ(r)|2/∥ψ∥2\nL2 describes the joint probability density of the n electrons to be located at r. The smallest\nsolution λψ of (8.1) describes the ground state energy associated with the nuclear coordinates R. It is\nof particular interest to know the ground state energy for all nuclear coordinates, the so-called potential\nenergy surface whose gradient determines the forces governing the dynamic motions of the nuclei. The\nnumerical solution of (8.1) is complicated by the Pauli principle which states that the wave function ψ must\nbe antisymmetric in all coordinates representing electrons of equal spin. To state it, we need to clarify that\nevery electron is not only deﬁned by its location but also by its spin which may be positive or negative.\n57\nDepending on whether two electrons have the same spin or not, their interaction changes massively. This is\nreﬂected by the Pauli principle that we already mentioned: Suppose that electrons i and j have equal spin,\nthen the wave function must satisfy\nPi,jψ = −ψ,\n(8.2)\nwhere Pi,j denotes the operator that swaps ri and rj, i.e., (Pi,jψ)(r) = ψ(r1, . . . , rj, . . . , ri, . . . , rn). In\nparticular, no two electrons with the same spin can occupy the same location. The challenges associated with\nsolving the Schr¨odinger equation inspired the following famous quote by Paul Dirac [Dir29]:\n“The fundamental laws necessary for the mathematical treatment of a large part of physics and\nthe whole of chemistry are thus completely known, and the diﬃculty lies only in the fact that\napplication of these laws leads to equations that are too complex to be solved.”\nWe now describe how deep learning methods might help to mitigate this claim to a certain extent. Let X\nbe a random variable with density |ψ(r)|2/∥ψ∥2\nL2. Using the Rayleigh–Ritz principle, ﬁnding the minimal\nnonzero eigenvalue of (8.1) can be reformulated as minimizing the Rayleigh quotient\nR\nR3×n ψ(r)(HRψ)(r) dr\n∥ψ∥2\nL2\n= E\n\u0014(HRψ)(X)\nψ(X)\n\u0015\n(8.3)\nover all ψ’s satisfying the Pauli principle, see [SO12]. Since this represents a minimization problem it can in\nprinciple be solved via a NN ansatz by generating training data distributed according to X using MCMC\nsampling31. Since the wave function ψ will be parametrized as a NN, the minimization of (8.3) will require\nthe computation of the gradient of (8.3) with respect to the NN parameters (the method in [PSMF20] even\nrequires second order derivatives) which, at ﬁrst sight, might seem to require the computation of third order\nderivatives. However, due to the Hermitian structure of the Hamiltonian one does not need to compute the\nderivative of the Laplacian of ψ, see, for example, [HSN20, Equation (8)].\nCompared to the other PDE problems we have discussed, an additional complication arises from the\nneed to incorporate structural properties and invariances such as the Pauli principle. Furthermore, empirical\nevidence shows that it is also necessary to hard code the so-called cusp conditions which describe the\nasymptotic behavior of nearby electrons and electrons close to a nucleus into the NN architecture. A ﬁrst\nattempt in this direction has been made in [HZE19] and signiﬁcantly improved NN architectures have been\ndeveloped in [HSN20, PSMF20, SRG+21] opening the possibility of accurate ab initio computations for\npreviously intractable molecules. The mathematical properties of this exciting line of work remain largely\nunexplored. We brieﬂy describe the main ideas behind the NN architecture of [HSN20, SRG+21]. Standard\nnumerical approaches (notably the Multireference Hartree Fock Method, see [SO12]) use a low rank approach\nto minimize (8.3). Such a low rank approach would approximate ψ by sums of products of one electron\norbitals Qn\ni=1 ϕi(ri) but clearly this does not satisfy the Pauli principle (8.2). In order to ensure the Pauli\nprinciple, one constructs so-called Slater determinants from one electron orbitals with equal spin. More\nprecisely, suppose that the ﬁrst n+ electrons with coordinates r1, . . . , rn+ have positive spin and the last\nn −n+ electrons have negative spin. Then any function of the form\ndet\n\u0010\n(ϕi(rj))n+\ni,j=1\n\u0011\n· det\n\u0010\n(ϕi(rj))n\ni,j=n++1\n\u0011\n(8.4)\nsatisﬁes (8.2) and is typically called a Slater determinant. While the Pauli principle establishes an (non-\nclassical) interaction between electrons of equal spin, the so-called exchange correlation, electrons with\nopposite spins are uncorrelated in the representation (8.4). In particular, (8.4) ignores interactions between\nelectrons that arise through Coulomb forces, implying that no nontrivial wavefunction can be accurately\nrepresented by a single Slater determinant. To capture physical interactions between diﬀerent electrons,\none needs to use sums of Slater determinants as an ansatz. However, it turns out that the number of such\ndeterminants that are needed to guarantee a given accuracy scales very badly with the system size n (to the\n31Observe that for such sampling methods one can just use the unnormalized density |ψ(r)|2 and thus avoid the computation\nof the normalization ∥ψ∥2\nL2.\n58\nbest of our knowledge the best currently known approximation results are contained in [Yse10], where an\nn-independent error rate is shown, however the implicit constant in this rate depends at least exponentially\non the system size n).\nWe would like to highlight the approach of [HSN20] whose main idea is to use NNs to incorporate\ninteractions into Slater determinants of the form (8.4) using what is called the backﬂow trick [RMD+06].\nThe basic building blocks would now consist of functions of the form\ndet\n\u0010\n(ϕi(rj)Ψj(r, θj))n+\ni,j=1\n\u0011\n· det\n\u0010\n(ϕi(rj)Ψj(r, θj))n\ni,j=n++1\n\u0011\n,\n(8.5)\nwhere Ψk(·, θk), k ∈[n], are NNs. If these are arbitrary NNs, it is easy to see that the Pauli principle (8.2)\nwill not be satisﬁed. However, if we require the NNs to be symmetric, for example, in the sense that for\ni, j, s ∈[n+] it holds that\nPi,jΨk(·, θk) =\n\n\n\n\n\nΨk(·, θk),\nif k /∈{i, j},\nΨi(·, θi),\nif k = j,\nΨj(·, θj),\nif k = i,\n(8.6)\nand analogous conditions hold for i, j, k ∈[n] \\ [n+], the expression (8.5) does actually satisfy (8.2). The\nconstruction of such symmetric NNs can be achieved by using a modiﬁcation of the so-called SchNet\nArchitecture [SKS+17] which can be considered as a speciﬁc residual NN.\nWe describe a simpliﬁed construction which is inspired by [HZE19] and used in a slightly more complex\nform in [SRG+21]. We restrict ourselves to the case of positive spin (e.g., the ﬁrst n+ coordinates), the case\nof negative spin being handled in the same way. Let Υ(·, θ+\nemb) be a univariate NN (with possibly multivariate\noutput) and denote\nEmbk(r, θ+\nemb) :=\nn+\nX\ni=1\nΥ(∥rk −ri∥2, θ+\nemb),\nk ∈[n+],\nthe k-th embedding layer. For k ∈[n+], we can now deﬁne\nΨk (r, θk) = Ψk\n\u0000r, (θk,fc, θ+\nemb)\n\u0001\n= Γk\n\u0000\u0000Embk(r, θ+\nemb), (rn++1, . . . , rn)\n\u0001\n, θk,fc\n\u0001\n,\nwhere Γk(·, θk,fc) denotes a standard FC NN with input dimension equal to the output dimension of Ψ+\nplus the dimension of negative spin electrons. The networks Ψk, k ∈[n] \\ [n+], are deﬁned analogously\nusing diﬀerent parameters θ−\nemb for the embeddings. It is straightforward to check that the NNs Ψk, k ∈[n],\nsatisfy (8.6) so that the backﬂow determinants (8.5) satisfy the Pauli principle (8.2).\nIn [HSN20] the backﬂow determinants (8.5) are further augmented by a multiplicative correction term,\nthe so-called Jastrow factor which is also represented by a speciﬁc symmetric NN, as well as a correction\nterm that ensures the validity of the cusp conditions. The results of [HSN20] show that this ansatz (namely\nusing linear combinations of backﬂow determinants (8.5) instead of plain Slater determinants (8.4)) is vastly\nmore eﬃcient in terms of number of determinants needed to obtain chemical accuracy. The full architecture\nprovides a general purpose NN architecture to represent complicated wave functions. A distinct advantage\nof this approach is that some parameters (for example, embedding layers) may be shared across diﬀerent\nnuclear geometries R ∈R3×p which allows for the eﬃcient computation of potential energy surfaces [SRG+21],\nsee Figure 8.1. Finally, we would like to highlight the customized NN design that incorporates physical\ninvariances, domain knowledge (for example, in the form of cusp conditions), and existing numerical methods,\nall of which are required for the method to reach its full potential.\nAcknowledgment\nThe research of JB was supported by the Austrian Science Fund (FWF) under grant I3403-N32. GK\nacknowledges support from DFG-SPP 1798 Grants KU 1446/21-2 and KU 1446/27-2, DFG-SFB/TR 109\nGrant C09, BMBF Grant MaGriDo, and NSF-Simons Foundation Grant SIMONS 81420. The authors would\n59\nFigure 8.1: By sharing layers across diﬀerent nuclear geometries one can eﬃciently compute diﬀerent\ngeometries in one single training step [SRG+21]. Left: Potential energy surface of H10 chain computed by the\ndeep-learning-based algorithm from [SRG+21]. The lowest energy is achieved when pairs of H atoms enter\ninto a covalent bond to form ﬁve H2 molecules. Right: The method of [SRG+21] is capable of accurately\ncomputing forces between nuclei which allows for molecular dynamics simulations from ﬁrst principles.\nlike to thank H´ector Andrade Loarca, Dennis Elbr¨achter, Adalbert Fono, Pavol Harar, Lukas Liehr, Duc Anh\nNguyen, Mariia Seleznova, and Frieder Simon for their helpful feedback on an early version of this article. In\nparticular, Dennis Elbr¨achter was providing help for several theoretical results.\nReferences\n[AAˇC13]\nAntonio Auﬃnger, G´erard Ben Arous, and Jiˇr´ı ˇCern`y, Random matrices and complexity of spin\nglasses, Communications on Pure and Applied Mathematics 66 (2013), no. 2, 165–201.\n[AB99]\nMartin Anthony and Peter L Bartlett, Neural network learning: Theoretical foundations,\nCambridge University Press, 1999.\n[ACGH19]\nSanjeev Arora, Nadav Cohen, Noah Golowich, and Wei Hu, A convergence analysis of gradient\ndescent for deep linear neural networks, International Conference on Learning Representations,\n2019.\n[ACH18]\nSanjeev Arora, Nadav Cohen, and Elad Hazan, On the optimization of deep networks: Implicit\nacceleration by overparameterization, International Conference on Machine Learning, 2018,\npp. 372–389.\n[AD20]\nBen Adcock and Nick Dexter, The gap between theory and practice in function approximation\nwith deep neural networks, 2020, arXiv preprint arXiv:2001.07523.\n[ADH+19]\nSanjeev Arora, Simon S Du, Wei Hu, Zhiyuan Li, Ruslan Salakhutdinov, and Ruosong Wang, On\nexact computation with an inﬁnitely wide neural net, Advances in Neural Information Processing\nSystems, 2019, pp. 8139–8148.\n[AGNZ18]\nSanjeev Arora, Rong Ge, Behnam Neyshabur, and Yi Zhang, Stronger generalization bounds\nfor deep nets via a compression approach, International Conference on Machine Learning, 2018,\npp. 254–263.\n[AHNB+20] Yasmine S Al-Hamdani, P´eter R Nagy, Dennis Barton, Mih´aly K´allay, Jan Gerit Brandenburg,\nand Alexandre Tkatchenko, Interactions between large molecules: Puzzle for reference quantum-\nmechanical methods, 2020, arXiv preprint arXiv:2009.08927.\n60\n[AHS85]\nDavid H Ackley, Geoﬀrey E Hinton, and Terrence J Sejnowski, A learning algorithm for\nBoltzmann machines, Cognitive Science 9 (1985), no. 1, 147–169.\n[AHW96]\nPeter Auer, Mark Herbster, and Manfred K Warmuth, Exponentially many local minima for\nsingle neurons, Advances in Neural Information Processing Systems, 1996, p. 316–322.\n[AM¨OS19]\nSimon Arridge, Peter Maass, Ozan ¨Oktem, and Carola-Bibiane Sch¨onlieb, Solving inverse\nproblems using data-driven models, Acta Numerica 28 (2019), 1–174.\n[A¨O17]\nJonas Adler and Ozan ¨Oktem, Solving ill-posed inverse problems using iterative deep neural\nnetworks, Inverse Problems 33 (2017), no. 12, 124007.\n[AZLS19]\nZeyuan Allen-Zhu, Yuanzhi Li, and Zhao Song, A convergence theory for deep learning via\nover-parameterization, International Conference on Machine Learning, 2019, pp. 242–252.\n[Bar92]\nAndrew R Barron, Neural net approximation, Yale Workshop on Adaptive and Learning Systems,\nvol. 1, 1992, pp. 69–72.\n[Bar93]\n, Universal approximation bounds for superpositions of a sigmoidal function, IEEE\nTransactions on Information Theory 39 (1993), no. 3, 930–945.\n[Bar98]\nPeter L Bartlett, The sample complexity of pattern classiﬁcation with neural networks: the size\nof the weights is more important than the size of the network, IEEE Transactions on Information\nTheory 44 (1998), no. 2, 525–536.\n[BBC17]\nAlfred Bourely, John Patrick Boueri, and Krzysztof Choromonski, Sparse neural networks\ntopologies, 2017, arXiv preprint arXiv:1706.05683.\n[BBC+19]\nChristopher Berner, Greg Brockman, Brooke Chan, Vicki Cheung, Przemyslaw Debiak, Christy\nDennison, David Farhi, Quirin Fischer, Shariq Hashme, and Chris Hesse, Dota 2 with large scale\ndeep reinforcement learning, 2019, arXiv preprint arXiv:1912.06680.\n[BBG+21]\nChristian Beck, Sebastian Becker, Philipp Grohs, Nor Jaafari, and Arnulf Jentzen, Solving the\nkolmogorov pde by means of deep learning, Journal of Scientiﬁc Computing 88 (2021), no. 3,\n1–28.\n[BBL03]\nOlivier Bousquet, St´ephane Boucheron, and G´abor Lugosi, Introduction to statistical learning\ntheory, Summer School on Machine Learning, 2003, pp. 169–207.\n[BBL+17]\nMichael M Bronstein, Joan Bruna, Yann LeCun, Arthur Szlam, and Pierre Vandergheynst,\nGeometric deep learning: going beyond euclidean data, IEEE Signal Processing Magazine 34\n(2017), no. 4, 18–42.\n[BBM05]\nPeter L Bartlett, Olivier Bousquet, and Shahar Mendelson, Local Rademacher complexities, The\nAnnals of Statistics 33 (2005), no. 4, 1497–1537.\n[BCB15]\nDzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio, Neural machine translation by jointly\nlearning to align and translate, International Conference on Learning Representations, 2015.\n[BDG20]\nJulius Berner, Markus Dablander, and Philipp Grohs, Numerically solving parametric families\nof high-dimensional Kolmogorov partial diﬀerential equations via deep learning, Advances in\nNeural Information Processing Systems, 2020, pp. 16615–16627.\n[BE02]\nOlivier Bousquet and Andr´e Elisseeﬀ, Stability and generalization, Journal of Machine Learning\nResearch 2 (2002), no. Mar, 499–526.\n61\n[BEG19]\nJulius Berner, Dennis Elbr¨achter, and Philipp Grohs, How degenerate is the parametrization of\nneural networks with the ReLU activation function?, Advances in Neural Information Processing\nSystems, 2019, pp. 7790–7801.\n[Bel52]\nRichard Bellman, On the theory of dynamic programming, Proceedings of the National Academy\nof Sciences 38 (1952), no. 8, 716.\n[BF19]\nJan Bohn and Michael Feischl, Recurrent neural networks as optimal mesh reﬁnement strategies,\n2019, arXiv preprint arXiv:1909.04275.\n[BFT17]\nPeter L Bartlett, Dylan J Foster, and Matus Telgarsky, Spectrally-normalized margin bounds for\nneural networks, Advances in Neural Information Processing Systems, 2017, pp. 6240–6249.\n[BGJ20]\nJulius Berner, Philipp Grohs, and Arnulf Jentzen, Analysis of the generalization error: Empirical\nrisk minimization over deep artiﬁcial neural networks overcomes the curse of dimensionality in\nthe numerical approximation of black–scholes partial diﬀerential equations, SIAM Journal on\nMathematics of Data Science 2 (2020), no. 3, 631–657.\n[BH89]\nEric B Baum and David Haussler, What size net gives valid generalization?, Neural Computation\n1 (1989), no. 1, 151–160.\n[BHLM19]\nPeter L Bartlett, Nick Harvey, Christopher Liaw, and Abbas Mehrabian, Nearly-tight VC-\ndimension and pseudodimension bounds for piecewise linear neural networks, Journal of Machine\nLearning Research 20 (2019), 63–1.\n[BHMM19]\nMikhail Belkin, Daniel Hsu, Siyuan Ma, and Soumik Mandal, Reconciling modern machine-\nlearning practice and the classical bias–variance trade-oﬀ, Proceedings of the National Academy\nof Sciences 116 (2019), no. 32, 15849–15854.\n[BHX20]\nMikhail Belkin, Daniel Hsu, and Ji Xu, Two models of double descent for weak features, SIAM\nJournal on Mathematics of Data Science 2 (2020), no. 4, 1167–1180.\n[BK18]\nAndrew R Barron and Jason M Klusowski, Approximation and estimation for high-dimensional\ndeep learning networks, 2018, arXiv preprint arXiv:1809.03090.\n[BLLT20]\nPeter L Bartlett, Philip M Long, G´abor Lugosi, and Alexander Tsigler, Benign overﬁtting\nin linear regression, Proceedings of the National Academy of Sciences 117 (2020), no. 48,\n30063–30070.\n[BMM98]\nPeter L Bartlett, Vitaly Maiorov, and Ron Meir, Almost linear VC-dimension bounds for\npiecewise polynomial networks, Neural Computation 10 (1998), no. 8, 2159–2173.\n[BMM18]\nMikhail Belkin, Siyuan Ma, and Soumik Mandal, To understand deep learning we need to\nunderstand kernel learning, International Conference on Machine Learning, 2018, pp. 541–549.\n[BMR+20]\nTom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal,\nArvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, Sandhini Agarwal, Ariel\nHerbert-Voss, Gretchen Krueger, Tom Henighan, Rewon Child, Aditya Ramesh, Daniel Ziegler,\nJeﬀrey Wu, Clemens Winter, Chris Hesse, Mark Chen, Eric Sigler, Mateusz Litwin, Scott Gray,\nBenjamin Chess, Jack Clark, Christopher Berner, Sam McCandlish, Alec Radford, Ilya Sutskever,\nand Dario Amodei, Language models are few-shot learners, Advances in Neural Information\nProcessing Systems, 2020, pp. 1877–1901.\n[BR89]\nAvrim Blum and Ronald L Rivest, Training a 3-node neural network is NP-complete, Advances\nin Neural Information Processing Systems, 1989, pp. 494–501.\n62\n[BRT19]\nMikhail Belkin, Alexander Rakhlin, and Alexandre B Tsybakov, Does data interpolation con-\ntradict statistical optimality?, International Conference on Artiﬁcial Intelligence and Statistics,\n2019, pp. 1611–1619.\n[BSW14]\nPierre Baldi, Peter Sadowski, and Daniel Whiteson, Searching for exotic particles in high-energy\nphysics with deep learning, Nature Communications 5 (2014), no. 1, 1–9.\n[BZAJ20]\nRiccardo Barbano, Chen Zhang, Simon Arridge, and Bangti Jin, Quantifying model uncertainty\nin inverse problems via bayesian deep gradient descent, 2020, arXiv preprint arXiv:2007.09971.\n[Can98]\nEmmanuel J Cand`es, Ridgelets: Theory and applications, Ph.D. thesis, Stanford University,\n1998.\n[CB20]\nLenaic Chizat and Francis Bach, Implicit bias of gradient descent for wide two-layer neural\nnetworks trained with the logistic loss, Conference on Learning Theory, 2020, pp. 1305–1338.\n[CHM+15]\nAnna Choromanska, Mikael Henaﬀ, Michael Mathieu, G´erard Ben Arous, and Yann LeCun,\nThe loss surfaces of multilayer networks, International Conference on Artiﬁcial Intelligence and\nStatistics, 2015, pp. 192–204.\n[CJLZ19]\nMinshuo Chen, Haoming Jiang, Wenjing Liao, and Tuo Zhao, Eﬃcient approximation of deep\nReLU networks for functions on low dimensional manifolds, Advances in Neural Information\nProcessing Systems, 2019, pp. 8174–8184.\n[CK20]\nAlexander Cloninger and Timo Klock, ReLU nets adapt to intrinsic dimensionality beyond the\ntarget domain, 2020, arXiv preprint arXiv:2008.02545.\n[CKP12]\nPeter G Casazza, Gitta Kutyniok, and Friedrich Philipp, Introduction to ﬁnite frame theory,\nFinite Frames: Theory and Applications, Birkh¨auser Boston, 2012, pp. 1–53.\n[CL19]\nWojciech Czaja and Weilin Li, Analysis of time-frequency scattering transforms, Applied and\nComputational Harmonic Analysis 47 (2019), no. 1, 149–171.\n[CLA15]\nAnna Choromanska, Yann LeCun, and G´erard Ben Arous, Open problem: The landscape of the\nloss surfaces of multilayer networks, Conference on Learning Theory, 2015, pp. 1756–1760.\n[CLM94]\nCharles K Chui, Xin Li, and Hrushikesh N Mhaskar, Neural networks for localized approximation,\nMathematics of Computation 63 (1994), no. 208, 607–623.\n[CM18]\nCharles K Chui and Hrushikesh N Mhaskar, Deep nets for local manifold learning, Frontiers in\nApplied Mathematics and Statistics 4 (2018), 12.\n[CMBK20]\nLin Chen, Yifei Min, Mikhail Belkin, and Amin Karbasi, Multiple descent: Design your own\ngeneralization curve, 2020, arXiv preprint arXiv:2008.01036.\n[COB19]\nLenaic Chizat, Edouard Oyallon, and Francis Bach, On lazy training in diﬀerentiable program-\nming, Advances in Neural Information Processing Systems, 2019, pp. 2937–2947.\n[CPV20]\nAndrei Caragea, Philipp Petersen, and Felix Voigtlaender, Neural network approximation and\nestimation of classiﬁers with classiﬁcation boundary in a Barron class, 2020, arXiv preprint\narXiv:2011.09363.\n[CS02]\nFelipe Cucker and Steve Smale, On the mathematical foundations of learning, Bulletin of the\nAmerican Mathematical Society 39 (2002), no. 1, 1–49.\n[CvMG+14] Kyunghyun Cho, Bart van Merri¨enboer, Caglar Gulcehre, Dzmitry Bahdanau, Fethi Bougares,\nHolger Schwenk, and Yoshua Bengio, Learning phrase representations using rnn encoder–decoder\nfor statistical machine translation, Proceedings of the 2014 Conference on Empirical Methods in\nNatural Language Processing, 2014, pp. 1724–1734.\n63\n[Cyb89]\nGeorge Cybenko, Approximation by superpositions of a sigmoidal function, Mathematics of\nControl, Signals and Systems 2 (1989), no. 4, 303–314.\n[CZ07]\nFelipe Cucker and Ding-Xuan Zhou, Learning theory: an approximation theory viewpoint, vol. 24,\nCambridge University Press, 2007.\n[DDS+09]\nJia Deng, Wei Dong, Richard Socher, Li-Jia Li, Kai Li, and Li Fei-Fei, Imagenet: A large-scale\nhierarchical image database, Proceedings of the IEEE Conference on Computer Vision and\nPattern Recognition, 2009, pp. 248–255.\n[DeV98]\nRonald A DeVore, Nonlinear approximation, Acta Numerica 7 (1998), 51–150.\n[DGL96]\nLuc Devroye, L´aszl´o Gy¨orﬁ, and G´abor Lugosi, A probabilistic theory of pattern recognition,\nSpringer, 1996.\n[DHL18]\nSimon S Du, Wei Hu, and Jason D Lee, Algorithmic regularization in learning deep homogeneous\nmodels: Layers are automatically balanced, Advances in Neural Information Processing Systems,\n2018, pp. 384–395.\n[DHP20]\nRonald DeVore, Boris Hanin, and Guergana Petrova, Neural network approximation, 2020, arXiv\npreprint arXiv:2012.14501.\n[Dir29]\nPaul Adrien Maurice Dirac, Quantum mechanics of many-electron systems, Proceedings of the\nRoyal Society of London. Series A, Containing Papers of a Mathematical and Physical Character\n123 (1929), no. 792, 714–733.\n[DKMB20]\nS¨oren Dittmer, Tobias Kluth, Peter Maass, and Daniel Otero Baguer, Regularization by ar-\nchitecture: A deep prior approach for inverse problems, Journal of Mathematical Imaging and\nVision 62 (2020), no. 3, 456–470.\n[DLL+19]\nSimon S Du, Jason D Lee, Haochuan Li, Liwei Wang, and Xiyu Zhai, Gradient descent ﬁnds\nglobal minima of deep neural networks, International Conference on Machine Learning, 2019,\npp. 1675–1685.\n[Don69]\nWilliam F Donoghue, Distributions and fourier transforms, Pure and Applied Mathematics,\nAcademic Press, 1969.\n[DPG+14]\nYann N Dauphin, Razvan Pascanu, Caglar Gulcehre, Kyunghyun Cho, Surya Ganguli, and\nYoshua Bengio, Identifying and attacking the saddle point problem in high-dimensional non-\nconvex optimization, Advances in Neural Information Processing Systems, 2014, pp. 2933–2941.\n[DR17]\nGintare Karolina Dziugaite and Daniel M Roy, Computing nonvacuous generalization bounds for\ndeep (stochastic) neural networks with many more parameters than training data, Conference on\nUncertainty in Artiﬁcial Intelligence, 2017.\n[Dre62]\nStuart Dreyfus, The numerical solution of variational problems, Journal of Mathematical\nAnalysis and Applications 5 (1962), no. 1, 30–45.\n[Dud67]\nRichard M Dudley, The sizes of compact subsets of hilbert space and continuity of Gaussian\nprocesses, Journal of Functional Analysis 1 (1967), no. 3, 290–330.\n[Dud14]\n, Uniform central limit theorems, vol. 142, Cambridge University Press, 2014.\n[DZPS18]\nSimon S Du, Xiyu Zhai, Barnabas Poczos, and Aarti Singh, Gradient descent provably optimizes\nover-parameterized neural networks, International Conference on Learning Representations, 2018.\n[E17]\nWeinan E, A proposal on machine learning via dynamical systems, Communications in Mathe-\nmatics and Statistics 5 (2017), no. 1, 1–11.\n64\n[EGJS18]\nDennis Elbr¨achter, Philipp Grohs, Arnulf Jentzen, and Christoph Schwab, DNN expression\nrate analysis of high-dimensional PDEs: Application to option pricing, 2018, arXiv preprint\narXiv:1809.07669.\n[EHJK19]\nWeinan E, Martin Hutzenthaler, Arnulf Jentzen, and Thomas Kruse, On multilevel picard\nnumerical approximations for high-dimensional nonlinear parabolic partial diﬀerential equations\nand high-dimensional nonlinear backward stochastic diﬀerential equations, Journal of Scientiﬁc\nComputing 79 (2019), no. 3, 1534–1571.\n[EHL19]\nWeinan E, Jiequn Han, and Qianxiao Li, A mean-ﬁeld optimal control formulation of deep\nlearning, Research in the Mathematical Sciences 6 (2019), no. 1, 1–41.\n[Elm90]\nJeﬀrey L Elman, Finding structure in time, Cognitive Science 14 (1990), no. 2, 179–211.\n[EMW19a]\nWeinan E, Chao Ma, and Lei Wu, Barron spaces and the compositional function spaces for\nneural network models, 2019, arXiv preprint arXiv:1906.08039.\n[EMW19b]\n, A priori estimates of the population risk for two-layer neural networks, Communications\nin Mathematical Sciences 17 (2019), no. 5, 1407–1425.\n[EMWW20] Weinan E, Chao Ma, Stephan Wojtowytsch, and Lei Wu, Towards a mathematical understanding\nof neural network-based machine learning: what we know and what we don’t, 2020, arXiv preprint\narXiv:2009.10713.\n[EPGB19]\nDennis Elbr¨achter, Dmytro Perekrestenko, Philipp Grohs, and Helmut B¨olcskei, Deep neural\nnetwork approximation theory, 2019, arXiv preprint arXiv:1901.02220.\n[ES16]\nRonen Eldan and Ohad Shamir, The power of depth for feedforward neural networks, Conference\non Learning Theory, vol. 49, 2016, pp. 907–940.\n[EW20a]\nWeinan E and Stephan Wojtowytsch, On the Banach spaces associated with multi-layer ReLU\nnetworks: Function representation, approximation theory and gradient descent dynamics, 2020,\narXiv preprint arXiv:2007.15623.\n[EW20b]\n, A priori estimates for classiﬁcation problems using neural networks, 2020, arXiv preprint\narXiv:2009.13500.\n[EW20c]\n, Representation formulas and pointwise properties for Barron functions, 2020, arXiv\npreprint arXiv:2006.05982.\n[EY18]\nWeinan E and Bing Yu, The deep ritz method: a deep learning-based numerical algorithm for\nsolving variational problems, Communications in Mathematics and Statistics 6 (2018), no. 1,\n1–12.\n[FB17]\nDaniel C Freeman and Joan Bruna, Topology and geometry of half-rectiﬁed network optimization,\nInternational Conference on Learning Representations, 2017.\n[FC18]\nJonathan Frankle and Michael Carbin, The lottery ticket hypothesis: Finding sparse, trainable\nneural networks, International Conference on Learning Representations, 2018.\n[FHH+17]\nFelix A Faber, Luke Hutchison, Bing Huang, Justin Gilmer, Samuel S Schoenholz, George E\nDahl, Oriol Vinyals, Steven Kearnes, Patrick F Riley, and O Anatole Von Lilienfeld, Prediction\nerrors of molecular machine learning models lower than hybrid DFT error, Journal of Chemical\nTheory and Computation 13 (2017), no. 11, 5255–5264.\n[Fun89]\nKen-Ichi Funahashi, On the approximate realization of continuous mappings by neural networks,\nNeural Networks 2 (1989), no. 3, 183–192.\n65\n[GBC16]\nIan Goodfellow, Yoshua Bengio, and Aaron Courville, Deep learning, MIT Press, 2016.\n[G´er17]\nAurelien G´eron, Hands-on machine learning with scikit-learn and tensorﬂow: Concepts, tools,\nand techniques to build intelligent systems, O’Reilly Media, 2017.\n[GH21]\nPhilipp Grohs and Lukas Herrmann, Deep neural network approximation for high-dimensional\nparabolic Hamilton-Jacobi-Bellman equations, 2021, arXiv preprint arXiv:2103.05744.\n[GH22]\n, Deep neural network approximation for high-dimensional elliptic PDEs with boundary\nconditions, IMA Journal of Numerical Analysis 42 (2022), no. 3, 2055–2082.\n[GHJVW20] Philipp Grohs, Fabian Hornung, Arnulf Jentzen, and Philippe Von Wurstemberger, A proof that\nartiﬁcial neural networks overcome the curse of dimensionality in the numerical approximation\nof Black-Scholes partial diﬀerential equations, Memoirs of the American Mathematical Society\n(2020).\n[GHJY15]\nRong Ge, Furong Huang, Chi Jin, and Yang Yuan, Escaping from saddle points—online stochastic\ngradient for tensor decomposition, Conference on Learning Theory, 2015, pp. 797–842.\n[GJS+20]\nMario Geiger, Arthur Jacot, Stefano Spigler, Franck Gabriel, Levent Sagun, St´ephane d’Ascoli,\nGiulio Biroli, Cl´ement Hongler, and Matthieu Wyart, Scaling description of generalization with\nnumber of parameters in deep learning, Journal of Statistical Mechanics: Theory and Experiment\n(2020), no. 2, 023401.\n[GKP20]\nIngo G¨uhring, Gitta Kutyniok, and Philipp Petersen, Error bounds for approximations with deep\nReLU neural networks in W s,p norms, Analysis and Applications 18 (2020), no. 05, 803–859.\n[GKR20]\nPhilipp Grohs, Sarah Koppensteiner, and Martin Rathmair, Phase retrieval: Uniqueness and\nstability, SIAM Review 62 (2020), no. 2, 301–350.\n[GL13]\nSaeed Ghadimi and Guanghui Lan, Stochastic ﬁrst-and zeroth-order methods for nonconvex\nstochastic programming, SIAM Journal on Optimization 23 (2013), no. 4, 2341–2368.\n[GLSS18a]\nSuriya Gunasekar, Jason D Lee, Daniel Soudry, and Nathan Srebro, Characterizing implicit\nbias in terms of optimization geometry, International Conference on Machine Learning, 2018,\npp. 1832–1841.\n[GLSS18b]\n, Implicit bias of gradient descent on linear convolutional networks, Advances in Neural\nInformation Processing Systems, 2018, pp. 9461–9471.\n[GMMM21] Behrooz Ghorbani, Song Mei, Theodor Misiakiewicz, and Andrea Montanari, Linearized two-\nlayers neural networks in high dimension, The Annals of Statistics 49 (2021), no. 2, 1029–1054.\n[GOW19]\nDavis Gilton, Greg Ongie, and Rebecca Willett, Neumann networks for linear inverse problems\nin imaging, IEEE Transactions on Computational Imaging 6 (2019), 328–343.\n[GPAM+14] Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil\nOzair, Aaron Courville, and Yoshua Bengio, Generative adversarial nets, Advances in Neural\nInformation Processing Systems, 2014, pp. 2672–2680.\n[GRK20]\nIngo G¨uhring, Mones Raslan, and Gitta Kutyniok, Expressivity of deep neural networks, 2020,\narXiv preprint arXiv:2007.04759.\n[GRS18]\nNoah Golowich, Alexander Rakhlin, and Ohad Shamir, Size-independent sample complexity of\nneural networks, Conference On Learning Theory, 2018, pp. 297–299.\n[GS20]\nLukas Gonon and Christoph Schwab, Deep ReLU network expression rates for option prices in\nhigh-dimensional, exponential L´evy models, 2020, ETH Zurich SAM Research Report.\n66\n[GV21]\nPhilipp Grohs and Felix Voigtlaender, Proof of the theory-to-practice gap in deep learning via\nsampling complexity bounds for neural network approximation spaces, 2021, arXiv preprint\narXiv:2104.02746.\n[GW08]\nAndreas Griewank and Andrea Walther, Evaluating derivatives: principles and techniques of\nalgorithmic diﬀerentiation, SIAM, 2008.\n[GZ84]\nEvarist Gin´e and Joel Zinn, Some limit theorems for empirical processes, The Annals of\nProbability (1984), 929–989.\n[Han19]\nBoris Hanin, Universal function approximation by deep neural nets with bounded width and\nReLU activations, Mathematics 7 (2019), no. 10, 992.\n[Hau95]\nDavid Haussler, Sphere packing numbers for subsets of the boolean n-cube with bounded vapnik-\nchervonenkis dimension, Journal of Combinatorial Theory, Series A 2 (1995), no. 69, 217–232.\n[HH19]\nCatherine F Higham and Desmond J Higham, Deep learning: An introduction for applied\nmathematicians, SIAM Review 61 (2019), no. 4, 860–891.\n[HHJ15]\nMartin Hairer, Martin Hutzenthaler, and Arnulf Jentzen, Loss of regularity for Kolmogorov\nequations, The Annals of Probability 43 (2015), no. 2, 468–527.\n[HJE18]\nJiequn Han, Arnulf Jentzen, and Weinan E, Solving high-dimensional partial diﬀerential equations\nusing deep learning, Proceedings of the National Academy of Sciences 115 (2018), no. 34, 8505–\n8510.\n[HJKN20]\nMartin Hutzenthaler, Arnulf Jentzen, Thomas Kruse, and Tuan Anh Nguyen, A proof that recti-\nﬁed deep neural networks overcome the curse of dimensionality in the numerical approximation\nof semilinear heat equations, SN Partial Diﬀerential Equations and Applications 1 (2020), no. 2,\n1–34.\n[HLXZ20]\nJuncai He, Lin Li, Jinchao Xu, and Chunyue Zheng, ReLU deep neural networks and linear\nﬁnite elements, Journal of Computational Mathematics 38 (2020), no. 3, 502–527.\n[HMD16]\nSong Han, Huizi Mao, and William J Dally, Deep compression: Compressing deep neural network\nwith pruning, trained quantization and Huﬀman coding, International Conference on Learning\nRepresentations, 2016.\n[HMRT19]\nTrevor Hastie, Andrea Montanari, Saharon Rosset, and Ryan J Tibshirani, Surprises in high-\ndimensional ridgeless least squares interpolation, 2019, arXiv preprint arXiv:1903.08560.\n[Hoe63]\nWassily Hoeﬀding, Probability inequalities for sums of bounded random variables, Journal of the\nAmerican Statistical Association 58 (1963), no. 301, 13–30.\n[Hop82]\nJohn J Hopﬁeld, Neural networks and physical systems with emergent collective computational\nabilities, Proceedings of the National Academy of Sciences 79 (1982), no. 8, 2554–2558.\n[HR19]\nBoris Hanin and David Rolnick, Deep ReLU networks have surprisingly few activation patterns,\nAdvances in Neural Information Processing Systems, 2019, pp. 359–368.\n[HRS16]\nMoritz Hardt, Ben Recht, and Yoram Singer, Train faster, generalize better: Stability of stochastic\ngradient descent, International Conference on Machine Learning, 2016, pp. 1225–1234.\n[HS97]\nSepp Hochreiter and J¨urgen Schmidhuber, Long short-term memory, Neural Computation 9\n(1997), no. 8, 1735–1780.\n[HS17]\nBoris Hanin and Mark Sellke, Approximating continuous functions by ReLU nets of minimal\nwidth, 2017, arXiv preprint arXiv:1710.11278.\n67\n[HSL+16]\nGao Huang, Yu Sun, Zhuang Liu, Daniel Sedra, and Kilian Q Weinberger, Deep networks with\nstochastic depth, European Conference on Computer Vision, 2016, pp. 646–661.\n[HSN20]\nJan Hermann, Zeno Sch¨atzle, and Frank No´e, Deep-neural-network solution of the electronic\nSchr¨odinger equation, Nature Chemistry 12 (2020), no. 10, 891–897.\n[HSW89]\nKurt Hornik, Maxwell Stinchcombe, and Halbert White, Multilayer feedforward networks are\nuniversal approximators, Neural Networks 2 (1989), no. 5, 359–366.\n[HTF01]\nTrevor Hastie, Robert Tibshirani, and Jerome Friedman, The elements of statistical learning:\nData mining, inference, and prediction, Springer Series in Statistics, Springer, 2001.\n[HV17]\nBenjamin D Haeﬀele and Ren´e Vidal, Global optimality in neural network training, Proceedings\nof the IEEE Conference on Computer Vision and Pattern Recognition, 2017, pp. 7331–7339.\n[HvdG19]\nPeter Hinz and Sara van de Geer, A framework for the construction of upper bounds on the\nnumber of aﬃne linear regions of ReLU feed-forward neural networks, IEEE Transactions on\nInformation Theory 65 (2019), 7304–7324.\n[HZ94]\nGeoﬀrey E Hinton and Richard S Zemel, Autoencoders, minimum description length, and\nhelmholtz free energy, Advances in Neural Information Processing Systems 6 (1994), 3–10.\n[HZE19]\nJiequn Han, Linfeng Zhang, and Weinan E, Solving many-electron Schr¨odinger equation using\ndeep neural networks, Journal of Computational Physics 399 (2019), 108929.\n[HZRS15]\nKaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun, Delving deep into rectiﬁers: Sur-\npassing human-level performance on imagenet classiﬁcation, Proceedings of IEEE International\nConference on Computer Vision, 2015, pp. 1026–1034.\n[HZRS16]\n, Deep residual learning for image recognition, Proceedings of the IEEE Conference on\nComputer Vision and Pattern Recognition, 2016, pp. 770–778.\n[IS15]\nSergey Ioﬀe and Christian Szegedy, Batch normalization: Accelerating deep network training by\nreducing internal covariate shift, International Conference on Machine Learning, 2015, pp. 448–\n456.\n[JGH18]\nArthur Jacot, Franck Gabriel, and Cl´ement Hongler, Neural tangent kernel: Convergence and\ngeneralization in neural networks, Advances in Neural Information Processing Systems, 2018,\npp. 8571–8580.\n[JKMB19]\nYiding Jiang, Dilip Krishnan, Hossein Mobahi, and Samy Bengio, Predicting the generaliza-\ntion gap in deep networks with margin distributions, International Conference on Learning\nRepresentations, 2019.\n[JKNvW20] Arnulf Jentzen, Benno Kuckuck, Ariel Neufeld, and Philippe von Wurstemberger, Strong error\nanalysis for stochastic gradient descent optimization algorithms, IMA Journal of Numerical\nAnalysis 41 (2020), no. 1, 455–492.\n[JMFU17]\nKyong Hwan Jin, Michael T McCann, Emmanuel Froustey, and Michael Unser, Deep convolu-\ntional neural network for inverse problems in imaging, IEEE Transactions on Image Processing\n26 (2017), no. 9, 4509–4522.\n[JMS17]\nBangti Jin, Peter Maaß, and Otmar Scherzer, Sparsity regularization in inverse problems, Inverse\nProblems 33 (2017), no. 6, 060301.\n[JNM+20]\nYiding Jiang, Behnam Neyshabur, Hossein Mobahi, Dilip Krishnan, and Samy Bengio, Fan-\ntastic generalization measures and where to ﬁnd them, International Conference on Learning\nRepresentations, 2020.\n68\n[Jor90]\nMichael I Jordan, Attractor dynamics and parallelism in a connectionist sequential machine,\nArtiﬁcial neural networks: concept learning, IEEE Press, 1990, pp. 112–127.\n[JT19a]\nZiwei Ji and Matus Telgarsky, Gradient descent aligns the layers of deep linear networks,\nInternational Conference on Learning Representations, 2019.\n[JT19b]\n, A reﬁned primal-dual analysis of the implicit bias, 2019, arXiv preprint arXiv:1906.04540.\n[JT20]\n, Directional convergence and alignment in deep learning, Advances in Neural Information\nProcessing Systems, 2020, pp. 17176–17186.\n[Jud90]\nStephen J Judd, Neural network design and the complexity of learning, MIT Press, 1990.\n[Kel60]\nHenry J Kelley, Gradient theory of optimal ﬂight paths, Ars Journal 30 (1960), no. 10, 947–954.\n[KH09]\nAlex Krizhevsky and Geoﬀrey Hinton, Learning multiple layers of features from tiny images,\nTech. report, University of Toronto, 2009.\n[KL18]\nSham M Kakade and Jason D Lee, Provably correct automatic subdiﬀerentiation for qualiﬁed\nprograms, Advances in Neural Information Processing Systems, 2018, pp. 7125–7135.\n[KL20]\nPatrick Kidger and Terry Lyons, Universal approximation with deep narrow networks, Conference\non Learning Theory, 2020, pp. 2306–2327.\n[KM97]\nMarek Karpinski and Angus Macintyre, Polynomial bounds for VC dimension of sigmoidal and\ngeneral Pfaﬃan neural networks, Journal of Computer and System Sciences 54 (1997), no. 1,\n169–176.\n[KMN+17]\nNitish Shirish Keskar, Dheevatsa Mudigere, Jorge Nocedal, Mikhail Smelyanskiy, and Ping\nTak Peter Tang, On large-batch training for deep learning: Generalization gap and sharp minima,\nInternational Conference on Learning Representations, 2017.\n[KPRS19]\nGitta Kutyniok, Philipp Petersen, Mones Raslan, and Reinhold Schneider, A theoretical analysis\nof deep neural networks and parametric PDEs, 2019, arXiv preprint arXiv:1904.00377.\n[KSH12]\nAlex Krizhevsky, Ilya Sutskever, and Geoﬀrey E Hinton, Imagenet classiﬁcation with deep\nconvolutional neural networks, Advances in Neural Information Processing Systems, 2012,\npp. 1097–1105.\n[KW52]\nJack Kiefer and Jacob Wolfowitz, Stochastic estimation of the maximum of a regression function,\nThe Annals of Mathematical Statistics 23 (1952), no. 3, 462–466.\n[LBBH98]\nYann LeCun, L´eon Bottou, Yoshua Bengio, and Patrick Haﬀner, Gradient-based learning applied\nto document recognition, Proceedings of the IEEE 86 (1998), no. 11, 2278–2324.\n[LBD+89]\nYann LeCun, Bernhard Boser, John S Denker, Donnie Henderson, Richard E Howard, Wayne\nHubbard, and Lawrence D Jackel, Backpropagation applied to handwritten zip code recognition,\nNeural Computation 1 (1989), no. 4, 541–551.\n[LBH15]\nYann LeCun, Yoshua Bengio, and Geoﬀrey Hinton, Deep learning, Nature 521 (2015), no. 7553,\n436–444.\n[LBN+18]\nJaehoon Lee, Yasaman Bahri, Roman Novak, Samuel S Schoenholz, Jeﬀrey Pennington, and\nJascha Sohl-Dickstein, Deep neural networks as Gaussian processes, International Conference on\nLearning Representations, 2018.\n[LC19]\nGuillaume Lample and Fran¸cois Charton, Deep learning for symbolic mathematics, International\nConference on Learning Representations, 2019.\n69\n[LD21]\nLicong Lin and Edgar Dobriban, What causes the test error? Going beyond bias-variance via\nANOVA, Journal of Machine Learning Research 22 (2021), no. 155, 1–82.\n[LDS89]\nYann LeCun, John S Denker, and Sara A Solla, Optimal brain damage, Advances in Neural\nInformation Processing Systems, 1989, pp. 598–605.\n[Lew43]\nKurt Lewin, Psychology and the process of group living, The Journal of Social Psychology 17\n(1943), no. 1, 113–131.\n[Li21]\nWeilin Li, Generalization error of minimum weighted norm and kernel interpolation, SIAM\nJournal on Mathematics of Data Science 3 (2021), no. 1, 414–438.\n[Lin70]\nSeppo Linnainmaa, Alogritmin kumulatiivinen py¨oristysvirhe yksitt¨aisten py¨oristysvirheiden\nTaylor-kehitelm¨an¨a, Master’s thesis, University of Helsinki, 1970.\n[LL18]\nYuanzhi Li and Yingyu Liang, Learning overparameterized neural networks via stochastic\ngradient descent on structured data, Advances in Neural Information Processing Systems, 2018,\npp. 8157–8166.\n[LL19]\nKaifeng Lyu and Jian Li, Gradient descent maximizes the margin of homogeneous neural\nnetworks, International Conference on Learning Representations, 2019.\n[LLPS93]\nMoshe Leshno, Vladimir Ya Lin, Allan Pinkus, and Shimon Schocken, Multilayer feedforward\nnetworks with a nonpolynomial activation function can approximate any function, Neural\nNetworks 6 (1993), no. 6, 861–867.\n[LLS19]\nQianxiao Li, Ting Lin, and Zuowei Shen, Deep learning via dynamical systems: An approximation\nperspective, 2019, arXiv preprint arXiv:1912.10382.\n[LML+20]\nYiping Lu, Chao Ma, Yulong Lu, Jianfeng Lu, and Lexing Ying, A mean ﬁeld analysis of\ndeep ResNet and beyond: Towards provably optimization via overparameterization from depth,\nInternational Conference on Machine Learning, 2020, pp. 6426–6436.\n[L¨OS18]\nSebastian Lunz, Ozan ¨Oktem, and Carola-Bibiane Sch¨onlieb, Adversarial regularizers in inverse\nproblems, Advances in Neural Information Processing Systems, 2018, pp. 8507–8516.\n[LP21]\nFabian Laakmann and Philipp Petersen, Eﬃcient approximation of solutions of parametric\nlinear transport equations by ReLU DNNs, Advances in Computational Mathematics 47 (2021),\nno. 1, 1–32.\n[LPRS19]\nTengyuan Liang, Tomaso Poggio, Alexander Rakhlin, and James Stokes, Fisher–Rao metric,\ngeometry, and complexity of neural networks, International Conference on Artiﬁcial Intelligence\nand Statistics, 2019, pp. 888–896.\n[LR20]\nTengyuan Liang and Alexander Rakhlin, Just interpolate: Kernel “ridgeless” regression can\ngeneralize, The Annals of Statistics 48 (2020), no. 3, 1329–1347.\n[LRZ20]\nTengyuan Liang, Alexander Rakhlin, and Xiyu Zhai, On the multiple descent of minimum-norm\ninterpolants and restricted lower isometry of kernels, Conference on Learning Theory, 2020,\npp. 2683–2711.\n[LS17]\nShiyu Liang and R Srikant, Why deep neural networks for function approximation?, International\nConference on Learning Representations, 2017.\n[LSAH20]\nHousen Li, Johannes Schwab, Stephan Antholzer, and Markus Haltmeier, NETT: Solving inverse\nproblems with deep neural networks, Inverse Problems 36 (2020), no. 6, 065005.\n70\n[LSJR16]\nJason D Lee, Max Simchowitz, Michael I Jordan, and Benjamin Recht, Gradient descent only\nconverges to minimizers, Conference on Learning Theory, 2016, pp. 1246–1257.\n[LT91]\nMichel Ledoux and Michel Talagrand, Probability in Banach spaces: Isoperimetry and processes,\nvol. 23, Springer Science & Business Media, 1991.\n[LTY19]\nBo Li, Shanshan Tang, and Haijun Yu, Better approximations of high dimensional smooth\nfunctions by deep neural networks with rectiﬁed power units, Communications in Computational\nPhysics 27 (2019), no. 2, 379–411.\n[LXS+20]\nJaehoon Lee, Lechao Xiao, Samuel S Schoenholz, Yasaman Bahri, Roman Novak, Jascha Sohl-\nDickstein, and Jeﬀrey Pennington, Wide neural networks of any depth evolve as linear models\nunder gradient descent, Journal of Statistical Mechanics: Theory and Experiment 2020 (2020),\nno. 12, 124002.\n[Mal12]\nSt´ephane Mallat, Group invariant scattering, Communications on Pure and Applied Mathematics\n65 (2012), no. 10, 1331–1398.\n[Mal16]\n, Understanding deep convolutional networks, Philosophical Transactions of the Royal\nSociety A: Mathematical, Physical and Engineering Sciences 374 (2016), no. 2065, 20150203.\n[MAV18]\nPoorya Mianjy, Raman Arora, and Rene Vidal, On the implicit bias of dropout, International\nConference on Machine Learning, 2018, pp. 3540–3548.\n[McA99]\nDavid A McAllester, Pac-bayesian model averaging, Conference on Learning Theory, 1999,\npp. 164–170.\n[McD89]\nColin McDiarmid, On the method of bounded diﬀerences, Surveys in Combinatorics 141 (1989),\nno. 1, 148–188.\n[Men14]\nShahar Mendelson, Learning without concentration, Conference on Learning Theory, 2014,\npp. 25–39.\n[Mha96]\nHrushikesh N Mhaskar, Neural networks for optimal approximation of smooth and analytic\nfunctions, Neural Computation 8 (1996), no. 1, 164–177.\n[MHR+18]\nAlexander G de G Matthews, Jiri Hron, Mark Rowland, Richard E Turner, and Zoubin\nGhahramani, Gaussian process behaviour in wide deep neural networks, International Conference\non Learning Representations, 2018.\n[MKS+13]\nVolodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou, Daan\nWierstra, and Martin Riedmiller, Playing atari with deep reinforcement learning, 2013, arXiv\npreprint arXiv:1312.5602.\n[MLE21]\nVishal Monga, Yuelong Li, and Yonina C Eldar, Algorithm unrolling: Interpretable, eﬃcient\ndeep learning for signal and image processing, IEEE Signal Processing Magazine 38 (2021),\nno. 2, 18–44.\n[MM19]\nSong Mei and Andrea Montanari, The generalization error of random features regression: Precise\nasymptotics and double descent curve, 2019, arXiv preprint arXiv:1908.05355.\n[MOPS20]\nCarlo Marcati, Joost Opschoor, Philipp Petersen, and Christoph Schwab, Exponential ReLU\nneural network approximation rates for point and edge singularities, 2020, ETH Zurich SAM\nResearch Report.\n[MP43]\nWarren S McCulloch and Walter Pitts, A logical calculus of the ideas immanent in nervous\nactivity, The Bulletin of Mathematical Biophysics 5 (1943), no. 4, 115–133.\n71\n[MP69]\nMarvin Minsky and Seymour A Papert, Perceptrons, MIT Press, 1969.\n[MP99]\nVitaly Maiorov and Allan Pinkus, Lower bounds for approximation by MLP neural networks,\nNeurocomputing 25 (1999), no. 1-3, 81–91.\n[MPCB14]\nGuido Mont´ufar, Razvan Pascanu, Kyunghyun Cho, and Yoshua Bengio, On the number of\nlinear regions of deep neural networks, Advances in Neural Information Processing Systems,\n2014, pp. 2924–2932.\n[MSL+15]\nJunshui Ma, Robert P Sheridan, Andy Liaw, George E Dahl, and Vladimir Svetnik, Deep\nneural nets as a method for quantitative structure–activity relationships, Journal of chemical\ninformation and modeling 55 (2015), no. 2, 263–274.\n[MV03]\nShahar Mendelson and Roman Vershynin, Entropy and the combinatorial dimension, Inventiones\nmathematicae 152 (2003), no. 1, 37–55.\n[MVSS20]\nVidya Muthukumar, Kailas Vodrahalli, Vignesh Subramanian, and Anant Sahai, Harmless\ninterpolation of noisy data in regression, IEEE Journal on Selected Areas in Information Theory\n1 (2020), no. 1, 67–83.\n[MZ20]\nAndrea Montanari and Yiqiao Zhong, The interpolation phase transition in neural networks:\nMemorization and generalization under lazy training, 2020, arXiv preprint arXiv:2007.12826.\n[NBMS17]\nBehnam Neyshabur, Srinadh Bhojanapalli, David McAllester, and Nati Srebro, Exploring\ngeneralization in deep learning, Advances in Neural Information Processing Systems, 2017,\npp. 5947–5956.\n[NBS18]\nBehnam Neyshabur, Srinadh Bhojanapalli, and Nathan Srebro, A PAC-Bayesian approach to\nspectrally-normalized margin bounds for neural networks, International Conference on Learning\nRepresentations, 2018.\n[NH17]\nQuynh Nguyen and Matthias Hein, The loss surface of deep and wide neural networks, Interna-\ntional Conference on Machine Learning, 2017, pp. 2603–2612.\n[NI20]\nRyumei Nakada and Masaaki Imaizumi, Adaptive approximation and generalization of deep\nneural network with intrinsic dimensionality, Journal of Machine Learning Research 21 (2020),\nno. 174, 1–38.\n[NJLS09]\nArkadi Nemirovski, Anatoli Juditsky, Guanghui Lan, and Alexander Shapiro, Robust stochastic\napproximation approach to stochastic programming, SIAM Journal on Optimization 19 (2009),\nno. 4, 1574–1609.\n[NK19]\nVaishnavh Nagarajan and J Zico Kolter, Uniform convergence may be unable to explain general-\nization in deep learning, Advances in Neural Information Processing Systems, 2019, pp. 11615–\n11626.\n[NKB+20]\nPreetum Nakkiran, Gal Kaplun, Yamini Bansal, Tristan Yang, Boaz Barak, and Ilya Sutskever,\nDeep double descent: Where bigger models and more data hurt, International Conference on\nLearning Representations, 2020.\n[NLG+19]\nMor Shpigel Nacson, Jason D Lee, Suriya Gunasekar, Pedro Henrique Pamplona Savarese, Nathan\nSrebro, and Daniel Soudry, Convergence of gradient descent on separable data, International\nConference on Artiﬁcial Intelligence and Statistics, 2019, pp. 3420–3428.\n[NTS14]\nBehnam Neyshabur, Ryota Tomioka, and Nathan Srebro, In search of the real inductive bias:\nOn the role of implicit regularization in deep learning, 2014, arXiv preprint arXiv:1412.6614.\n72\n[NTS15]\n, Norm-based capacity control in neural networks, Conference on Learning Theory, 2015,\npp. 1376–1401.\n[NW09]\nErich Novak and Henryk Wo´zniakowski, Approximation of inﬁnitely diﬀerentiable multivariate\nfunctions is intractable, Journal of Complexity 25 (2009), no. 4, 398–404.\n[NY83]\nArkadi Semenovich Nemirovsky and David Borisovich Yudin, Problem complexity and method\neﬃciency in optimization, Wiley-Interscience Series in Discrete Mathematics, Wiley, 1983.\n[NZGK21]\nTenavi Nakamura-Zimmerer, Qi Gong, and Wei Kang, Adaptive deep learning for high-\ndimensional Hamilton–Jacobi–Bellman Equations, SIAM Journal on Scientiﬁc Computing 43\n(2021), no. 2, A1221–A1247.\n[OF96]\nBruno A Olshausen and David J Field, Sparse coding of natural images produces localized,\noriented, bandpass receptive ﬁelds, Nature 381 (1996), no. 60, 609.\n[OM98]\nGenevieve B Orr and Klaus-Robert M¨uller, Neural networks: tricks of the trade, Springer, 1998.\n[OPS20]\nJoost Opschoor, Philipp Petersen, and Christoph Schwab, Deep ReLU networks and high-order\nﬁnite element methods, Analysis and Applications (2020), no. 0, 1–56.\n[OS19]\nKenta Oono and Taiji Suzuki, Approximation and non-parametric estimation of ResNet-type\nconvolutional neural networks, International Conference on Machine Learning, 2019, pp. 4922–\n4931.\n[PGZ+18]\nHieu Pham, Melody Guan, Barret Zoph, Quoc Le, and JeﬀDean, Eﬃcient neural architecture\nsearch via parameters sharing, International Conference on Machine Learning, 2018, pp. 4095–\n4104.\n[PKL+17]\nTomaso Poggio, Kenji Kawaguchi, Qianli Liao, Brando Miranda, Lorenzo Rosasco, Xavier\nBoix, Jack Hidary, and Hrushikesh N Mhaskar, Theory of deep learning III: explaining the\nnon-overﬁtting puzzle, 2017, arXiv preprint arXiv:1801.00173.\n[PLR+16]\nBen Poole, Subhaneil Lahiri, Maithra Raghu, Jascha Sohl-Dickstein, and Surya Ganguli,\nExponential expressivity in deep neural networks through transient chaos, Advances in Neural\nInformation Processing Systems, 2016, pp. 3368–3376.\n[PMR+17]\nTomaso Poggio, Hrushikesh N Mhaskar, Lorenzo Rosasco, Brando Miranda, and Qianli Liao,\nWhy and when can deep-but not shallow-networks avoid the curse of dimensionality: a review,\nInternational Journal of Automation and Computing 14 (2017), no. 5, 503–519.\n[PP92]\nEtienne Pardoux and Shige Peng, Backward stochastic diﬀerential equations and quasilin-\near parabolic partial diﬀerential equations, Stochastic partial diﬀerential equations and their\napplications, Springer, 1992, pp. 200–217.\n[PRE17]\nVardan Papyan, Yaniv Romano, and Michael Elad, Convolutional neural networks analyzed via\nconvolutional sparse coding, Journal of Machine Learning Research 18 (2017), no. 1, 2887–2938.\n[PRMN04]\nTomaso Poggio, Ryan Rifkin, Sayan Mukherjee, and Partha Niyogi, General conditions for\npredictivity in learning theory, Nature 428 (2004), no. 6981, 419–422.\n[PRSE18]\nVardan Papyan, Yaniv Romano, Jeremias Sulam, and Michael Elad, Theoretical foundations\nof deep learning via sparse representations: A multilayer sparse model and its connection to\nconvolutional neural networks, IEEE Signal Processing Magazine 35 (2018), no. 4, 72–89.\n[PRV20]\nPhilipp Petersen, Mones Raslan, and Felix Voigtlaender, Topological properties of the set of\nfunctions generated by neural networks of ﬁxed size, Foundations of Computational Mathematics\n(2020), 1–70.\n73\n[PSE17]\nVardan Papyan, Jeremias Sulam, and Michael Elad, Working locally thinking globally: Theoretical\nguarantees for convolutional sparse coding, IEEE Transactions on Signal Processing 65 (2017),\nno. 21, 5687–5701.\n[PSMF20]\nDavid Pfau, James S Spencer, Alexander GDG Matthews, and W Matthew C Foulkes, Ab initio\nsolution of the many-electron schr¨odinger equation with deep neural networks, Physical Review\nResearch 2 (2020), no. 3, 033429.\n[PV18]\nPhilipp Petersen and Felix Voigtlaender, Optimal approximation of piecewise smooth functions\nusing deep ReLU neural networks, Neural Networks 108 (2018), 296–330.\n[PV20]\n, Equivalence of approximation by convolutional neural networks and fully-connected\nnetworks, Proceedings of the American Mathematical Society 148 (2020), no. 4, 1567–1581.\n[REM17]\nYaniv Romano, Michael Elad, and Peyman Milanfar, The little engine that could: Regularization\nby denoising (red), SIAM Journal on Imaging Sciences 10 (2017), no. 4, 1804–1844.\n[RFB15]\nOlaf Ronneberger, Philipp Fischer, and Thomas Brox, U-net: Convolutional networks for\nbiomedical image segmentation, International Conference on Medical image computing and\ncomputer-assisted intervention, 2015, pp. 234–241.\n[RH19]\nLars Ruthotto and Eldad Haber, Deep neural networks motivated by partial diﬀerential equations,\nJournal of Mathematical Imaging and Vision (2019), 1–13.\n[RHW86]\nDavid E Rumelhart, Geoﬀrey E Hinton, and Ronald J Williams, Learning representations by\nback-propagating errors, Nature 323 (1986), no. 6088, 533–536.\n[RM51]\nHerbert Robbins and Sutton Monro, A stochastic approximation method, The Annals of Mathe-\nmatical Statistics (1951), 400–407.\n[RMD+06]\nP L´opez R´ıos, Ao Ma, Neil D Drummond, Michael D Towler, and Richard J Needs, Inhomoge-\nneous backﬂow transformations in quantum Monte Carlo calculations, Physical Review E 74\n(2006), no. 6, 066701.\n[Ros58]\nFrank Rosenblatt, The perceptron: a probabilistic model for information storage and organization\nin the brain, Psychological review 65 (1958), no. 6, 386.\n[RPK+17]\nMaithra Raghu, Ben Poole, Jon Kleinberg, Surya Ganguli, and Jascha Sohl-Dickstein, On the\nexpressive power of deep neural networks, International Conference on Machine Learning, 2017,\npp. 2847–2854.\n[RPK19]\nMaziar Raissi, Paris Perdikaris, and George E Karniadakis, Physics-informed neural networks:\nA deep learning framework for solving forward and inverse problems involving nonlinear partial\ndiﬀerential equations, Journal of Computational Physics 378 (2019), 686–707.\n[RR+07]\nAli Rahimi, Benjamin Recht, et al., Random features for large-scale kernel machines, Advances\nin Neural Information Processing Systems, 2007, pp. 1177–1184.\n[Rud06]\nWalter Rudin, Real and complex analysis, McGraw-Hill Series in Higher Mathematics, Tata\nMcGraw-Hill, 2006.\n[RWK+20]\nVivek Ramanujan, Mitchell Wortsman, Aniruddha Kembhavi, Ali Farhadi, and Mohammad\nRastegari, What’s hidden in a randomly weighted neural network?, Proceedings of the IEEE\nConference on Computer Vision and Pattern Recognition, 2020, pp. 11893–11902.\n[Sak99]\nAkito Sakurai, Tight bounds for the VC-dimension of piecewise polynomial networks, Advances\nin Neural Information Processing Systems, 1999, pp. 323–329.\n74\n[SCC18]\nUri Shaham, Alexander Cloninger, and Ronald R Coifman, Provable approximation properties\nfor deep neural networks, Applied and Computational Harmonic Analysis 44 (2018), no. 3,\n537–557.\n[Sch15]\nJ¨urgen Schmidhuber, Deep learning in neural networks: An overview, Neural Networks 61\n(2015), 85–117.\n[SDR14]\nAlexander Shapiro, Darinka Dentcheva, and Andrzej Ruszczy´nski, Lectures on stochastic pro-\ngramming: modeling and theory, SIAM, 2014.\n[SEJ+20]\nAndrew W Senior, Richard Evans, John Jumper, James Kirkpatrick, Laurent Sifre, Tim Green,\nChongli Qin, Augustin ˇZ´ıdek, Alexander WR Nelson, and Alex Bridgland, Improved protein\nstructure prediction using potentials from deep learning, Nature 577 (2020), no. 7792, 706–710.\n[SGHK18]\nDavid Saxton, Edward Grefenstette, Felix Hill, and Pushmeet Kohli, Analysing mathematical\nreasoning abilities of neural models, International Conference on Learning Representations, 2018.\n[SGS15]\nRupesh Kumar Srivastava, Klaus Greﬀ, and J¨urgen Schmidhuber, Training very deep networks,\nAdvances in Neural Information Processing Systems, 2015, pp. 2377–2385.\n[SH19]\nJohannes Schmidt-Hieber, Deep ReLU network approximation of functions on a manifold, 2019,\narXiv preprint arXiv:1908.00695.\n[She20]\nZuowei Shen, Deep network approximation characterized by number of neurons, Communications\nin Computational Physics 28 (2020), no. 5, 1768–1811.\n[SHK+14]\nNitish Srivastava, Geoﬀrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov,\nDropout: a simple way to prevent neural networks from overﬁtting, Journal of Machine Learning\nResearch 15 (2014), no. 1, 1929–1958.\n[SHM+16]\nDavid Silver, Aja Huang, Chris J Maddison, Arthur Guez, Laurent Sifre, George Van Den Driess-\nche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, and Marc Lanctot, Mas-\ntering the game of go with deep neural networks and tree search, Nature 529 (2016), no. 7587,\n484–489.\n[SHN+18]\nDaniel Soudry, Elad Hoﬀer, Mor Shpigel Nacson, Suriya Gunasekar, and Nathan Srebro, The\nimplicit bias of gradient descent on separable data, 2018.\n[ˇS´ım02]\nJiˇr´ı ˇS´ıma, Training a single sigmoidal neuron is hard, Neural Computation 14 (2002), no. 11,\n2709–2728.\n[SKS+17]\nKristof T Sch¨utt, Pieter-Jan Kindermans, Huziel E Sauceda, Stefan Chmiela, Alexandre\nTkatchenko, and Klaus-Robert M¨uller, Schnet: A continuous-ﬁlter convolutional neural network\nfor modeling quantum interactions, Advances in Neural Information Processing Systems, 2017,\npp. 992–1002.\n[SLJ+15]\nChristian Szegedy, Wei Liu, Yangqing Jia, Pierre Sermanet, Scott Reed, Dragomir Anguelov,\nDumitru Erhan, Vincent Vanhoucke, and Andrew Rabinovich, Going deeper with convolutions,\nProceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2015, pp. 1–9.\n[SO12]\nAttila Szabo and Neil S Ostlund, Modern quantum chemistry: introduction to advanced electronic\nstructure theory, Courier Corporation, 2012.\n[SPRE18]\nJeremias Sulam, Vardan Papyan, Yaniv Romano, and Michael Elad, Multilayer convolutional\nsparse modeling: Pursuit and dictionary learning, IEEE Transactions on Signal Processing 66\n(2018), no. 15, 4090–4104.\n75\n[SRG+21]\nMichael Scherbela, Rafael Reisenhofer, Leon Gerard, Philipp Marquetand, and Philipp Grohs,\nSolving the electronic Schr¨odinger equation for multiple nuclear geometries with weight-sharing\ndeep neural networks, 2021, arXiv preprint arXiv:2105.08351.\n[SS16]\nItay Safran and Ohad Shamir, On the quality of the initial basin in overspeciﬁed neural networks,\nInternational Conference on Machine Learning, 2016, pp. 774–782.\n[SS17]\n, Depth-width tradeoﬀs in approximating natural functions with neural networks, Interna-\ntional Conference on Machine Learning, 2017, pp. 2979–2987.\n[SS18]\n, Spurious local minima are common in two-layer ReLU neural networks, International\nConference on Machine Learning, 2018, pp. 4433–4441.\n[SSBD14]\nShai Shalev-Shwartz and Shai Ben-David, Understanding machine learning: From theory to\nalgorithms, Cambridge University Press, 2014.\n[SSS+17]\nDavid Silver, Julian Schrittwieser, Karen Simonyan, Ioannis Antonoglou, Aja Huang, Arthur\nGuez, Thomas Hubert, Lucas Baker, Matthew Lai, and Adrian Bolton, Mastering the game of\ngo without human knowledge, Nature 550 (2017), no. 7676, 354–359.\n[SSSSS09]\nShai Shalev-Shwartz, Ohad Shamir, Nathan Srebro, and Karthik Sridharan, Stochastic convex\noptimization, Conference on Learning Theory, 2009.\n[STIM18]\nShibani Santurkar, Dimitris Tsipras, Andrew Ilyas, and Aleksander Madry, How does batch\nnormalization help optimization?, Advances in Neural Information Processing Systems, 2018,\npp. 2488–2498.\n[SZ19]\nChristoph Schwab and Jakob Zech, Deep learning in high dimension: Neural network expression\nrates for generalized polynomial chaos expansions in uq, Analysis and Applications 17 (2019),\nno. 01, 19–55.\n[Tal94]\nMichel Talagrand, Sharper bounds for Gaussian and empirical processes, The Annals of Proba-\nbility (1994), 28–76.\n[Tel15]\nMatus Telgarsky, Representation beneﬁts of deep feedforward networks, 2015, arXiv preprint\narXiv:1509.08101.\n[TvG18]\nMatthew Thorpe and Yves van Gennip, Deep limits of residual neural networks, 2018, arXiv\npreprint arXiv:1810.11741.\n[UVL18]\nDmitry Ulyanov, Andrea Vedaldi, and Victor Lempitsky, Deep image prior, Proceedings of the\nIEEE Conference on Computer Vision and Pattern Recognition, 2018, pp. 9446–9454.\n[Vap99]\nVladimir Vapnik, An overview of statistical learning theory, IEEE Transactions on Neural\nNetworks 10 (1999), no. 5, 988–999.\n[Vap13]\n, The nature of statistical learning theory, Springer science & business media, 2013.\n[VBB19]\nLuca Venturi, Afonso S Bandeira, and Joan Bruna, Spurious valleys in one-hidden-layer neural\nnetwork optimization landscapes, Journal of Machine Learning Research 20 (2019), no. 133,\n1–34.\n[VBC+19]\nOriol Vinyals, Igor Babuschkin, Wojciech M Czarnecki, Micha¨el Mathieu, Andrew Dudzik,\nJunyoung Chung, David H Choi, Richard Powell, Timo Ewalds, and Petko Georgiev, Grandmaster\nlevel in StarCraft II using multi-agent reinforcement learning, Nature 575 (2019), no. 7782,\n350–354.\n76\n[VC71]\nVladimir Vapnik and Alexey Chervonenkis, On the uniform convergence of relative frequencies of\nevents to their probabilities, Theory of Probability & Its Applications 16 (1971), no. 2, 264–280.\n[vdVW97]\nAad W van der Vaart and Jon A Wellner, Weak convergence and empirical processes with\napplications to statistics, Journal of the Royal Statistical Society-Series A Statistics in Society\n160 (1997), no. 3, 596–608.\n[Ver18]\nRoman Vershynin, High-dimensional probability: An introduction with applications in data\nscience, vol. 47, Cambridge University Press, 2018.\n[VSP+17]\nAshish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,\n Lukasz Kaiser, and Illia Polosukhin, Attention is all you need, Advances in Neural Information\nProcessing Systems, 2017, pp. 5998–6008.\n[Wer88]\nPaul J Werbos, Generalization of backpropagation with application to a recurrent gas market\nmodel, Neural Networks 1 (1988), no. 4, 339–356.\n[WGB17]\nThomas Wiatowski, Philipp Grohs, and Helmut B¨olcskei, Energy propagation in deep convolu-\ntional neural networks, IEEE Transactions on Information Theory 64 (2017), no. 7, 4819–4842.\n[Whi34]\nHassler Whitney, Analytic extensions of diﬀerentiable functions deﬁned in closed sets, Transac-\ntions of the American Mathematical Society 36 (1934), no. 1, 63–89.\n[WPC+21]\nZonghan Wu, Shirui Pan, Fengwen Chen, Guodong Long, Chengqi Zhang, and S Yu Philip, A\ncomprehensive survey on graph neural networks, IEEE Transactions on Neural Networks and\nLearning Systems 32 (2021), no. 1, 4–24.\n[WZ95]\nRonald J Williams and David Zipser, Gradient-based learning algorithms for recurrent, Back-\npropagation: Theory, Architectures, and Applications 433 (1995), 17.\n[WZZ+13]\nLi Wan, Matthew Zeiler, Sixin Zhang, Yann Le Cun, and Rob Fergus, Regularization of neural\nnetworks using dropconnect, International Conference on Machine Learning, 2013, pp. 1058–1066.\n[XM12]\nHuan Xu and Shie Mannor, Robustness and generalization, Machine learning 86 (2012), no. 3,\n391–423.\n[Yan19]\nGreg Yang, Scaling limits of wide neural networks with weight sharing: Gaussian process\nbehavior, gradient independence, and neural tangent kernel derivation, 2019, arXiv preprint\narXiv:1902.04760.\n[Yar17]\nDmitry Yarotsky, Error bounds for approximations with deep ReLU networks, Neural Networks\n94 (2017), 103–114.\n[Yar18a]\n, Optimal approximation of continuous functions by very deep ReLU networks, Conference\non Learning Theory, 2018, pp. 639–649.\n[Yar18b]\n, Universal approximations of invariant maps by neural networks, 2018, arXiv preprint\narXiv:1804.10306.\n[Yar21]\n, Elementary superexpressive activations, 2021, arXiv preprint arXiv:2102.10911.\n[YGLD17]\nRujie Yin, Tingran Gao, Yue M Lu, and Ingrid Daubechies, A tale of two bases: Local-nonlocal\nregularization on image patches with convolution framelets, SIAM Journal on Imaging Sciences\n10 (2017), no. 2, 711–750.\n[YHC18]\nJong Chul Ye, Yoseob Han, and Eunju Cha, Deep convolutional framelets: A general deep\nlearning framework for inverse problems, SIAM Journal on Imaging Sciences 11 (2018), no. 2,\n991–1048.\n77\n[YHPC18]\nTom Young, Devamanyu Hazarika, Soujanya Poria, and Erik Cambria, Recent trends in deep\nlearning based natural language processing, IEEE Computational Intelligence Magazine 13 (2018),\nno. 3, 55–75.\n[Yse10]\nHarry Yserentant, Regularity and approximability of electronic wave functions, Springer, 2010.\n[YZ20]\nDmitry Yarotsky and Anton Zhevnerchuk, The phase diagram of approximation rates for deep\nneural networks, Advances in Neural Information Processing Systems, vol. 33, 2020.\n[ZAP16]\nHao Zhou, Jose M Alvarez, and Fatih Porikli, Less is more: Towards compact CNNs, European\nConference on Computer Vision, 2016, pp. 662–677.\n[Zas75]\nThomas Zaslavsky, Facing up to arrangements: Face-count formulas for partitions of space\nby hyperplanes: Face-count formulas for partitions of space by hyperplanes, Memoirs of the\nAmerican Mathematical Society, American Mathematical Society, 1975.\n[ZBH+17]\nChiyuan Zhang, Samy Bengio, Moritz Hardt, Benjamin Recht, and Oriol Vinyals, Under-\nstanding deep learning requires rethinking generalization, International Conference on Learning\nRepresentations, 2017.\n[ZBH+20]\nChiyuan Zhang, Samy Bengio, Moritz Hardt, Michael C Mozer, and Yoram Singer, Identity\ncrisis: Memorization and generalization under extreme overparameterization, International\nConference on Learning Representations, 2020.\n[ZBS19]\nChiyuan Zhang, Samy Bengio, and Yoram Singer, Are all layers created equal?, 2019, arXiv\npreprint arXiv:1902.01996.\n[ZCZG20]\nDifan Zou, Yuan Cao, Dongruo Zhou, and Quanquan Gu, Gradient descent optimizes over-\nparameterized deep ReLU networks, Machine Learning 109 (2020), no. 3, 467–492.\n[Zho20a]\nDing-Xuan Zhou, Theory of deep convolutional neural networks: Downsampling, Neural Networks\n124 (2020), 319–327.\n[Zho20b]\n, Universality of deep convolutional neural networks, Applied and Computational Har-\nmonic Analysis 48 (2020), no. 2, 787–794.\n[ZKS+18]\nJure Zbontar, Florian Knoll, Anuroop Sriram, Tullie Murrell, Zhengnan Huang, Matthew J\nMuckley, Aaron Defazio, Ruben Stern, Patricia Johnson, Mary Bruno, Marc Parente, Krzysztof J\nGeras, Joe Katsnelson, Hersh Chandarana, Zizhao Zhang, Michal Drozdzal, Adriana Romero,\nMichael Rabbat, Pascal Vincent, Naﬁssa Yakubova, James Pinkerton, Duo Wang, Erich Owens,\nC Lawrence Zitnick, Michael P Recht, Daniel K Sodickson, and Yvonne W Lui, fastMRI: An\nopen dataset and benchmarks for accelerated MRI, 2018, arXiv preprint arXiv:1811.08839.\n[ZL17]\nBarret Zoph and Quoc V Le, Neural architecture search with reinforcement learning, International\nConference on Learning Representations, 2017.\n78\n",
  "categories": [
    "cs.LG",
    "stat.ML"
  ],
  "published": "2021-05-09",
  "updated": "2023-02-08"
}