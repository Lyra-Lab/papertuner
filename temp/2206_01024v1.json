{
  "id": "http://arxiv.org/abs/2206.01024v1",
  "title": "A Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System",
  "authors": [
    "Han Jipeng",
    "Lichen Zhihang"
  ],
  "abstract": "Since the advent of LISP, the fifth generation programming language has\ndeveloped for decades. However, compared with the fourth generation programming\nlanguage, the fifth generation programming language has not been widely used\nbecause of its obscure semantics, rigorous representation of problems, and\nlimited inference ability. For this reason, COOL (Constraint and Object Ordered\nLanguage), a fifth generation programming language proposed in this paper,\novercomes the problems of intuitive semantics, rigorous restrictions on\nhandling problem conditions, and improves the inference ability of previous\nfifth generation programming languages. Specific improvements are as follows:\nFirst, COOL supports process-oriented and object-oriented for easy application\nin production projects; Second, COOL supports expression as function\ndeclaration and function return, which improves language affinity for\nmathematical formulas, and supports embedding function parameters into function\nname strings to make function naming closer to natural languages. Make\nmathematical problems easier to describe; Third, COOL introduces a weighting\nmechanism and accelerates the inference process through cumulative weighting.\nFourth, COOL introduces the concepts of forward and reverse functions in\nprogramming so that computers can infer and execute problems with logical\nsequential constraints. Fifth, the computer can deduce the reverse solution\nprocess by using the forward solution process through the back-tracking\nalgorithm and the dynamic programming algorithm, so that the computer can\ndeduce the problem with time-sequential constraints. Sixth, the pre-execution\nstep is introduced to separate the inference and function query process of the\nprogram from the execution process, so as to improve the execution speed of the\nprogram.",
  "text": " \n计  算  机  学  报 \n \n2022 年6 月 \nCHINESE JOURNAL OF COMPUTERS \n6. 2022 \nA Constraint and Object Oriented Fifth Generation Programming Language \nand its Compiler and Runtime System  \nHAN Ji-Peng1)  LICHEN Zhi-Hang1)  \n1)(Department of Technology, Beijing Huagui Technology Co., Ltd, Beijing 100081)  \n \nAbstract Since the advent of LISP, the fifth generation programming language has developed for decades. \nHowever, compared with the fourth generation programming language, the fifth generation programming language \nhas not been widely used because of its obscure semantics, rigorous representation of problems, and limited \ninference ability. For this reason, COOL (Constraint and Object Ordered Language), a fifth generation programming \nlanguage proposed in this paper, overcomes the problems of intuitive semantics, rigorous restrictions on handling \nproblem conditions, and improves the inference ability of the fifth generation programming language. Specific \nimprovements are as follows: First, COOL supports process-oriented and object-oriented for easy application in \nproduction projects; Second, COOL supports expression as function declaration and function return, which \nimproves language affinity for mathematical formulas, and supports embedding function parameters into function \nname strings to make function naming closer to natural languages; Third, COOL introduces a weighting mechanism \nand accelerates the inference process through cumulative weighting. Fourth, COOL introduces the concepts of \nforward and reverse functions in programming so that computers can infer and execute problems with logical \nsequential constraints. Fifth, the computer can deduce the reverse solution process by using the forward solution \nprocess through the back-tracking algorithm and the dynamic programming algorithm, so that the computer can \ndeduce the problem with time-sequential constraints. Sixth, the pre-execution step is introduced to separate the \ninference and function query process of the program from the execution process, so as to improve the execution \nspeed of the program. \nKey words The fifth generation programming language; Object-oriented; Automatic reasoning; Reverse \nreasoning; Cumulative weight; Dynamic planning; Pre-Execution;  \n \n \n1 INTRODUCTION \nThe \ndevelopment \nof \nprogramming \nlanguage \nhas \nexperienced machine language, assembly language, advanced \nlanguage, function language, logical language[1]. As the fifth \ngeneration programming language, logical language can \ntheoretically reduce the burden of user thinking through \ncomputer reasoning, so as to improve the efficiency of \nprogramming. However, in actual production, no logical \nprogramming language has become the mainstream production \ntool so far due to its limitations in scope and performance. \nThe oldest logical language to date is the list processing \nlanguage LISP (LISt Processing), created by John McCarthy in \n1958. It is characterized by a symbolic expression rather than a \nnumber, where the symbolic expression is represented by a list \nstructure or an S expression. Compared with other earlier \nprogramming languages, LISP can still be used as a convenient \ntool for developing higher-level symbolic computing systems \nand artificial intelligence because of its runtime system with easy \naccess to host and operating system functions, and its internal \nlanguage as a list structure for high-level language compilation \npurposes. But at the same time, LISP's weakness in numerical \noperation and unclear mathematical semantics restrict its further \nwidespread use[2]. \nIn 1975, the PROLOG (PROgramming in LOGic) \ndeveloped by the Kowalskl, Colmerauer and van Emden teams \nat the University of Marseilles was launched. PROLOG is a \nprogramming language based on symbolic logic. Its basic \ncomputer mechanism is a pattern matching process. Pure LISP \ncan be thought of as a special tool for PROLOG whose processes \nare limited to simple functions and data structures are limited to \nlists. For users, the language is clear, readable, concise, and \neasier to program[3]. However, there is a point of view that \n2 \n计 算 机 学 报 \n20??年 \nPROLOG is actually a deductive inference technology based on \nreverse rules, but with strict restrictions on the representation of \nrules and objectives. Combined with the simplicity of deductive \ninference control mechanism itself, it is difficult to apply to \ncomplex application environment[4]. \nFrom 1982 to 1993, Japan carried out research work on the \nFifth Generation Computer Systems (FGCS), the technical goal \nof which was to develop parallel inference technology. \nResearchers have attempted to develop a kernel language that \ncan express and execute logical programming of various parallel \nalgorithms[5]. However, the project has generally failed because \nits objectives are too ambitious and some initial features such as \nmachine translation, pattern recognition have not been \nachieved[6]. The successful application of neural networks in \nmachine translation and pattern recognition further compresses \nthe application space of logical programming in artificial \nintelligence development. \nIn 1987, the Jaffar team proposed the Constraint Logic \nProgramming(CLP) language, which refers to the basic \ncomponents of a problem as constraints and uses rules to \ncombine constraints to represent the whole problem. The CLP \nlanguage has strong expressive power because the user directly \nmanipulates various constraints. Early representations of the \nCLP language were CAL[8] and CHIP[9]. \nCurrently, the main research directions of logical \nprogramming languages are Probability Logic Programming \nLanguage PROBLOG (PROBabilistic LOGic) and Constraint \nHandling Rules (CHR), both of which introduce probability into \nlogical programming. \nProbability Logic Programming Language mainly studies \nthe probability of inferring and calculating results from given \nrules by labeling certain facts with probability. Constraint \nProcessing Rule Language CHR was developed from the \nConstraint Logic Programming Language CLP and was \noriginally designed by Fr hwirth in 1991 to write a user-defined \nconstraint solver[10]. Later, the CHR language derived the \nProbability Constraint Handling Rules language (PCHR), which \nallows users to \"probability weight\" rules to determine the \nprobability that they will be applied in inference[11]. \nThe development of Constraint Logic Programming and \nProbability Logic Programming has increased the reasoning \ncapabilities of the fifth generation programming languages, and \nhas widened the range of problems they can handle. However, \ntheir difficulties in practical production have not yet \nsubstantially improved. And Philip Wadler et al. pointed out \nsome problems in logical programming and functional \nprogramming: \nThe languages are less efficient and do not have good \ndebuggers. \nA large number of constraints are required in complex \nrelationships. \nUnfamiliarity with the languages makes it difficult to sell \nand maintain products. \nLack of fully functional libraries and interfaces with other \nlanguages; \nResearchers in programming languages focus on system \ndevelopment rather than application development. \nMost importantly, functional programming languages and \nlogical programming languages are preferred only within a \nnarrow range of theorem proving, lacking killer applications that \ncan attract a large number of users[12]. \nIn addition, the author believes that the application of \nlogical programming language is limited for the following \nreasons: \nA large number of symbolic representations may be concise \nfor researchers, but may not be intuitive for most users; \nThe development of neural network has weakened the \nadvantage of logical programming in computer reasoning. \nCurrent logical programming languages are difficult to develop \nneural network. \nThe narrow scope of application makes the logical \nprogramming language can only be used to develop individual \nmodules in the software, and the huge difference between the \nlogical programming language and the common high-level \nlanguage grammar style causes the overall development cost of \nthe project to increase. \nThis paper presents an easy-to-use fifth generation \nprogramming language COOL by analyzing, referencing and \nimproving the characteristics, advantages and disadvantages of \nsome current representative logical programming languages. \nThis language has the main features of CHR, and it also absorbs \nthe design ideas of PCHR and PROBLOG which have been \nstudied extensively in recent years, that is, introducing \nprobability into \"rules\" and \"facts\" to calculate and control. \nProbability will be replaced with weight in this language. In \norder to be closer to the actual production process, this language \nabandons the LISP list style and PROLOG-like language style \nof the traditional logic language, and changes to the C++/JAVA \n \nHAN Ji-Peng, LICHEN Zhi-Hang： \nA Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System \n3 \nstyle to adapt to the mainstream software engineering \ndevelopment process, reduces the learning cost of users and \nenables the modular development of rule libraries. For a piece of \ncode, the order in which the statements are executed also \nconstitutes a constraint. This language solves this constraint by \ndynamic programming, and implements reverse inference for \nsome functions. To better describe the semantics of \nmathematical expressions, this language supports expression as \nfunction declaration. In fact, all function declarations in this \nlanguage are stored in expression form (tree structure). Because \nthe inference mechanism and function query mechanism of this \nlanguage need to match the tree structure and involve a lot of \ntraversal operations, we separate this part of the operation from \nthe execution process, which we call \"pre-execution\", \"pre-\nexecution\" process is similar to Haskell's lazy operation[13], but \nhas a special set of execution rules. Users can combine pre-\nexecution steps with compilation steps to reduce code execution \ntime or with execution procedures to reduce code volume based \non specific circumstances in practice. The main contributions of \nthis paper are as follows: \n·The design idea and specific framework of a Constraint \nand Object Oriented programming language are presented.  \n·A weight-based inference control method is presented for \nthe constraints inference process in a Constraint and Object \nOriented programming language. \n·Reverse reasoning for simple sequential structure \nfunctions is implemented through dynamic programming. \n·Presents a pre-execution step that separates the inference \nprocess and function query process from the execution process. \n2 RELATED WORK \nCOOL is a fifth generation language with CHR language \ncharacteristics. From the user writing the program to the final \nresult, the overall process is: coding (functions, variables, \ncontrol structures, related syntax of classes), precompilation, \ncompilation, pre-execution, execution. This section will be \nintroduced step by step according to the overall process \nsequence. \n2.1 FUNCTION \nFunctions are the most important part of COOL. This \nsection first provides some simple code to familiarize readers \nwith the style of COOL functions, then introduces functions that \nreturn expressions and return operands, functions with additional \nweights, forward and reverse functions, function weights, \nfunction inverses. These constitute the COOL inference \nframework. \n2.1.1 DEFINE FUNCTION \nIn COOL, a function consists of a function declaration and \na body of functions. A function representing addition can be \ndefined as code 1: \nCODE 1 Example function declaration \n@𝑎𝑑𝑑(𝑎, 𝑏){ \n \n 𝑟𝑒𝑡𝑢𝑟𝑛: 𝑎+ 𝑏; \n} \nWhere '@' modifies the subsequent 𝑎𝑑𝑑(𝑎, 𝑏) as a function \ndeclaration rather than a function call. You need to remove '@' \nwhen calling a function: \nCODE 2 Function call example \n𝑎𝑑𝑑(1,2); \nFunctions are called with preference for passing in \nreferences to actual parameters rather than copying, for example, \ncode 3: \nCODE 3 Example function call  \n@𝑎𝑑𝑑(𝑎)𝑡𝑜(𝑏){ \n \n𝑏= 𝑏+ 𝑎; \n} \n𝑎𝑑𝑑(1)𝑡𝑜(𝑥); \nIncrease 𝑥  by 1 after code 3 is executed. In this code, \nfunction parameters are allowed to be embedded in function \nname (predicate) string to enhance expressiveness. \nIn addition, COOL provides built-in functions that can be \nused without definition to provide basic mathematical \noperations. \n2.1.2 \n FUNTION RETURNING EXPRESSION \nand FUNCTION RETURNING VALUE \n \nThe attribute \"exp\" is added to the function declaration to \nindicate that the return of this function is an expression. This \nkind of function is used to express the transformation rules of the \nexpression. Users cannot directly call the function returning \nexpression. \n \nFor example, code 4 describes the inverse operation of the \ndistributive law of multiplication by function: \nCODE 4 Example of function returning expression \n𝑒𝑥𝑝: @{𝑎∗𝑐+ 𝑏∗𝑐}{ \n \n 𝑟𝑒𝑡𝑢𝑟𝑛: (𝑎+ 𝑏) ∗𝑐; \n} \n \nThe pair of curly braces immediately following \"@\" and the \nexpression within them are called function declaration scope, \nand the only internal expression is called function declaration \nexpression. In fact, in the function example in section 2.1.1, the \n4 \n计 算 机 学 报 \n20??年 \nfunction name is also in its function declaration scope, but the \ncurly brackets on the scope boundary are omitted for writing \nconvenience. \n \nIf the function declaration has no attribute \"exp\", the \nfunction returns the computed value. The user can only call value \nreturning function directly. \n \n2.1.3 \n FORWARD FUNCTION and REVERSE \n(BACKWARD) FUNCTION \n \nBoth forward and reverse functions are for value returning \nfunctions; Functions returning expression do not have this \nproperty. \n Forward function refers to the function whose parameters \nare determined and whose return value is undetermined. The \nexecution process of forward function is to deduce the return \nvalue of the function by using the input parameters, such as code \n1. \nReverse function refers to the function whose return value \nis determined and whose input parameters have pending \nparameters (parameters with undetermined values). The \nexecution process of reverse function is to use the return value \nof the function and the determined input parameters to calculate \nthe pending input parameters. \nFor example, code 5 provides the reverse function required to \ncalculate a solution of a quadratic function: \nCODE 5 Example reverse function  \n@{𝑎∗$𝑥^2 + 𝑏∗𝑥+ 𝑐}{ \n \n 𝑥= (−𝑏+ (𝑏^2 −4 ∗𝑎∗(𝑐−𝑎𝑛𝑠))^0.5)/(2 ∗\n𝑎); \n} \n@{$𝑎 ==  𝑏}{ \n \n𝑎= 𝑏; \n} \n The \"$\" symbol acts on parameter x, indicating that \nparameter x is pending in the expression. For variables that \nappear multiple times in an expression, you only need to use \"$\" \nto decorate them once. The return value of the function \nrepresented by the variable \"ans\" appearing in the function body \nis a known parameter, which you can use or not use. \n \nWhen calling the reverse function, the user needs to modify \nthe undetermined variable to be derived with \"$\", for example, \nsolve the univariate quadratic equation with 𝑎 as the unknown \nnumber (code 6): \nCODE 6 Example for calling reverse function \n1 ∗$𝑎^2 + (−2) ∗𝑎+ 1 == 0; \n \n𝑎 needs to be decorated with \"$\". \n2.1.4 \n FUNCTION WEIGHT \n \nThe function weight is used to control the reasoning \ndirection of the reasoning system. Users can give greater weight \nto transformations (i.e. functions) that are easier to lead to correct \nreasoning results, and less weight to transformations that are not \neasy to lead to correct reasoning results. The weight of a function \nis determined at the time of function declaration, between \"@\" \nand the scope of function declaration. For example, code 7 \ndefines a function with a weight of 10: \nCODE 7 Examples of function with weight \n@(10){$𝑎 ==  𝑏; }{  \n \n𝑎 =  𝑏; \n} \n \nA function that is not weighted (such as code 1) has a weight \nof 0. \n2.1.5 \n FUNCTION INVERSION \n \nFunction backstepping is a special way to define reverse \nfunction through forward function. Example code 8: \nCODE 8 Example of using forward function to define \nreverse function \n@ 𝑝𝑟𝑖𝑐𝑒 𝑜𝑓 𝑏𝑢𝑦𝑖𝑛𝑔 (𝑎) 𝑘𝑔 𝑜𝑓 𝑎𝑝𝑝𝑙𝑒 𝑢𝑛𝑖𝑡 𝑝𝑟𝑖𝑐𝑒 (𝑏){ \n \n𝑟𝑒𝑡𝑢𝑟𝑛: 𝑎∗𝑏; \n} => @𝑎𝑝𝑝𝑙𝑒 𝑢𝑛𝑖𝑡 𝑝𝑟𝑖𝑐𝑒 (𝑏)  𝑐𝑎𝑛 𝑏𝑒 𝑏𝑜𝑢𝑔ℎ𝑡 ($𝑎) 𝑘𝑔; \n  \nWhere \"=>\" indicates derivation. The necessary conditions \nfor using this method to define the reverse function in the \nalgorithm to realize this function in this paper are: the names of \nall parameters in the function declaration of the reverse function \nmust correspond to the names of all parameters in the function \ndeclaration of the forward function one by one; The \nundetermined parameter in the reverse function and the variables \nthat depend on this parameter only participate in the sequential \nstructure of the forward function, and do not participate in the \nloop and branch structure of the function body; The function \nbody code of forward function does not modify the parameters \noutside the scope; Variables with the same name and different \nscopes do not exist in the function body of forward function. \nSince it is a necessary condition, it also means that even if these \nrequirements are met, the backstepping may not be completed \nfor other reasons. \n2.2 VARIABLE \n2.2.1 \n DECLARATION and TYPE of VARIABLE \nNon temporary variables of COOL must be declared before \nuse. An example of declaring variable 𝑎 and assigning an initial \nvalue of 1 is shown in code 9: \nCODE 9 Example of variable declaration \n \nHAN Ji-Peng, LICHEN Zhi-Hang： \nA Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System \n5 \n𝑛𝑒𝑤: 𝑎 =  1; \nThe type of the variable is determined by the last assigned \ntype. The basic data types supported by COOL are floating point \nnumbers and strings; When a variable is not assigned a value, its \ntype defaults to floating number. \n2.2.2 ACCESS to VARIABLES \n \nVariables can be accessed from the point where they are \ndeclared to the end of their scope. When an expression needs to \nuse a variable, it takes precedence over the variable in the current \nscope. Users can use \"out\" to modify this variable to force the \nexpression to use variables from the upper scope. For example, \ncode 10: \nCODE 10 \"out\" usage example \n𝑛𝑒𝑤: 𝑎 =  1; \n{ \n \n 𝑛𝑒𝑤: 𝑎= 0; \n \n𝑎= 𝑜𝑢𝑡: 𝑎+ 1; \n} \nThe result of calculation (the final value of 𝑎 in the inner \nscope) is 2. \n \nWhen the \"out\" modifier parameter is used in a function \ndeclaration scope, it is no longer a formal parameter but an actual \nparameter outside the scope of the function declaration. For \nexample, 𝑝𝑖 in the function declaration of code 11: \nCODE 11 Example use of \"out\" in a function declaration \n𝑛𝑒𝑤: 𝑝𝑖 =  3.14159; \n … … \n𝑒𝑥𝑝: @{𝑠𝑖𝑛(𝑜𝑢𝑡: 𝑝𝑖/2 −𝑎)}{ \n  \n𝑟𝑒𝑡𝑢𝑟𝑛: 𝑐𝑜𝑠(𝑎); \n} \n2.3 CONDITIONAL STATEMENT \n2.3.1 \n LOOP \n \nCOOL supports “while” loop structure, such as code 12: \nCODE 12 “while” loop example \n𝑤ℎ𝑖𝑙𝑒(𝑎> 0){ \n  \n… … \n} \n2.3.2 \n BRANCH \n  \n Branch structure of COOL, example code 13: \nCODE 13 Branch structure example \n𝑖𝑓(𝑎== 0){ \n  \n… … \n}𝑒𝑙𝑖𝑓(𝑎> 0){ \n  \n… … \n}𝑒𝑙𝑠𝑒{ \n  \n… … \n} \n \n2.4 COMMENT STATEMENT \nThe comment style is the same as C, for example, code 14: \nCODE 14 Example of comment \n//𝑆𝑖𝑛𝑔𝑙𝑒−𝑙𝑖𝑛𝑒 𝑐𝑜𝑚𝑚𝑒𝑛𝑡𝑠 \n/∗𝑂𝑛𝑒 𝑜𝑟 𝑚𝑜𝑟𝑒 𝑙𝑖𝑛𝑒𝑠 𝑜𝑓 𝑐𝑜𝑚𝑚𝑒𝑛𝑡𝑠∗/ \n2.5 COMPLETE CODE EXAMPLE 1 \nSolve the following mathematical problems: \nFor two numeric quantities 𝑥  and 𝑦 , do the following in \nturn: \n1. Sum 𝑥 and 𝑦 and record the result as 𝑎; \n2. Modify the value of 𝑥 so that it satisfies the value of 𝑥+\n1 equal to 𝑦; \n3. Solve the variable 𝑧, where 𝑧2 + 𝑥∗𝑧+ 𝑦 equals 100; \n4. Sum 𝑎, 𝑥, 𝑧 to get the final result; \nGiven that the result from the fourth step is 50 and that 𝑦 \nhas an initial value of 3, what is the initial value of 𝑥? \nThe complete COOL code for solving the problem, such as \ncode 15, involves function returning expression and value \nreturning function, forward and reverse functions, function \nweights, and function inverse. \nIn the following section, it is used as an example code to \nshow the reasoning mechanism: \nCODE 15 Complete code example 1 \n/∗𝐹𝑢𝑛𝑐𝑡𝑖𝑜𝑛 𝑓𝑜𝑟 𝑠𝑜𝑙𝑣𝑖𝑛𝑔 𝑞𝑢𝑎𝑑𝑟𝑎𝑡𝑖𝑐 𝑒𝑞𝑢𝑎𝑡𝑖𝑜𝑛𝑠∗/ \n@(100){𝑎∗$𝑥^2 + 𝑏∗𝑥+ 𝑐}{ \n \n 𝑥= (−𝑏+ (𝑏^2 −4 ∗𝑎∗(𝑐−𝑎𝑛𝑠))^0.5)/(2 ∗𝑎);  \n} \n/∗ Defines the law of additive exchange 𝑎+ 𝑏→𝑏+ 𝑎, and \nthe function declaration is modified by attribute ”exp”, \nindicating that this function is a function returning \nexpression. For the function returning expression, the \nfunction parameters 𝑎 and b are modified by” #”, indicating \nthat the law of additive exchange can be applied regardless \nof whether 𝑎 or 𝑏 is undetermined. ∗/ \n𝑒𝑥𝑝: @(−1){#𝑎+ #𝑏}{ \n     𝑟𝑒𝑡𝑢𝑟𝑛: 𝑏+ 𝑎; \n} \n/∗𝐷𝑒𝑓𝑖𝑛𝑒 𝑎𝑑𝑑𝑖𝑡𝑖𝑜𝑛−𝑠𝑢𝑏𝑡𝑟𝑎𝑐𝑡𝑖𝑜𝑛 𝑐𝑜𝑛𝑣𝑒𝑟𝑠𝑖𝑜𝑛∶ \n 𝑎−𝑏→𝑎+ (−𝑏);∗/ \n𝑒𝑥𝑝: @(−1){#𝑎−#𝑏}{ \n \n𝑟𝑒𝑡𝑢𝑟𝑛: 𝑎+ (−𝑏); \n} \n/∗𝐷𝑒𝑓𝑖𝑛𝑒 𝑎𝑑𝑑𝑖𝑡𝑖𝑣𝑒 𝑟𝑒𝑣𝑒𝑟𝑠𝑒 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛∗/ \n@(10){$𝑎+ 𝑏}{  \n \n 𝑎= 𝑎𝑛𝑠−𝑏; \n} \n/∗𝐷𝑒𝑓𝑖𝑛𝑒 𝑟𝑒𝑣𝑒𝑟𝑠𝑒 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛 𝑜𝑓 𝑒𝑞𝑢𝑎𝑡𝑖𝑜𝑛∗/ \n@(10){$𝑎 ==  𝑏; }{  \n \n 𝑎 =  𝑏; \n} \n∗𝐷𝑒𝑓𝑖𝑛𝑒 𝑎 𝑓𝑜𝑟𝑤𝑎𝑟𝑑 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛 𝑓𝑜𝑟 𝑑𝑒𝑟𝑖𝑣𝑖𝑛𝑔 𝑡ℎ𝑒 𝑟𝑒𝑣𝑒𝑟𝑠𝑒  \n𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛∗/ \n@𝑔𝑒𝑡 𝑟𝑒𝑠𝑢𝑙𝑡 𝑓𝑟𝑜𝑚 (𝑥) 𝑎𝑛𝑑 (𝑦){  \n \n𝑛𝑒𝑤: 𝑎 =  𝑥+ 𝑦; \n6 \n计 算 机 学 报 \n20??年 \n \n$𝑥+ 1 == 𝑦;  \n \n𝑛𝑒𝑤: 𝑧= 0; \n \n1 ∗$𝑧^2 + 𝑥∗𝑧+ 𝑦== 100; \n \n𝑟𝑒𝑡𝑢𝑟𝑛: 𝑎+ 𝑥+ 𝑧; \n} ⇒@𝑔𝑒𝑡 𝑟𝑒𝑠𝑢𝑙𝑡 𝑓𝑟𝑜𝑚 ($𝑥) 𝑎𝑛𝑑 (𝑦); \n \n𝑛𝑒𝑤: 𝑥 =  0; \n𝑛𝑒𝑤: 𝑦 =  3; \n𝑔𝑒𝑡 𝑟𝑒𝑠𝑢𝑙𝑡 𝑓𝑟𝑜𝑚 ($𝑥) 𝑎𝑛𝑑 (𝑦) == 50; \n𝑥−→0;/∗ “-- >” 𝑖𝑛𝑑𝑖𝑐𝑎𝑡𝑒𝑠 𝑜𝑢𝑡𝑝𝑢𝑡, 𝑤ℎ𝑖𝑐ℎ 𝑚𝑒𝑎𝑛𝑠 𝑡ℎ𝑎𝑡 \n𝑡ℎ𝑒 𝑥 𝑣𝑎𝑙𝑢𝑒 𝑖𝑠 𝑜𝑢𝑡𝑝𝑢𝑡 𝑏𝑦 𝑑𝑒𝑓𝑎𝑢𝑙𝑡*/ \n \n2.6 CLASS \nRules for solving similar problems can be encapsulated into \nclasses. Users can reuse, modify and expand rules more flexibly \nthrough inheritance, so as to realize the division and treatment of \ncomplex problems and the modular development of programs. \n2.6.1 \nDEFINE CLASS \nIn COOL, a class consists of a declaration and the scope of \nthe class (hereinafter referred to as the \"class body\"), such as \ncode 16: \nCODE 16 Example of class \n𝑠𝑦𝑠𝑡𝑒𝑚∶ 𝑂𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝐿𝑎𝑤{ \n \n … … \n} \nWhere, \"system\" is the keyword of the declaration of class; \n\"Operationlaw\" is the name of the class. \n2.6.2 \nINHERIT \nWhen defining a class, you can make it inherit from other \nclasses to use its member functions and variables: \nCODE 17 Class inheritance example \n𝑠𝑦𝑠𝑡𝑒𝑚: 𝑀𝑎𝑖𝑛𝑃𝑟𝑜𝑐𝑒𝑠𝑠<<\n𝑂𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝐿𝑎𝑤,𝑄𝑢𝑎𝑑𝑟𝑎𝑡𝑖𝑐𝐸𝑞𝑢𝑎𝑡𝑖𝑜𝑛 { \n \n … … \n}; \nWhere \"<<\" means inheritance. When a class inherits \nmultiple classes, the names of the inherited classes are separated \nby commas. If a variable with the same name or a function with \nthe same declaration in the parent class exists in the current class, \nthe member variable or function of the current class will be used \nfirst by default; If multiple parent classes have the same member, \nthe member of the class on the left at the time of declaration is \npreferred (for example, if the class 𝑂𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑙𝑎𝑤 has the same \nmember as the class 𝑄𝑢𝑎𝑑𝑟𝑎𝑐𝑢𝑡𝑒𝑞𝑢𝑎𝑡𝑖𝑜𝑛 , the member of \n𝑂𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑙𝑎𝑤  is preferred); If the name of the class is \nspecified, the member function of the specified class is used. \n2.6.3 \nCLASS INSTANCE INITIALIZATION \nAn instance of a class also belongs to a variable. The way \nto declare it is shown in code 18: \nCODE 18 Class instance declaration example \n𝑀𝑎𝑖𝑛𝑃𝑟𝑜𝑐𝑒𝑠𝑠: 𝑚; \nIts initialization is similar to a function call. After entering \nthe scope of the class, it creates an active record and executes the \ncode in the scope of the class in turn. However, when leaving the \nscope of the class, it does not destroy the active record, but takes \nthe active record as the value of the corresponding variable. \n2.6.4 \nACCESS MEMBERS \nBy \".\" Operator to access member variables or call member \nfunctions, such as code 19: \nCODE 19 Example of access members \n𝑚. 𝑥 =  1; \n𝑚. 𝑐𝑜𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟( ) ; \n2.7 COMPLETE CODE EXAMPLE 2 \nCode 20 shows the combined use of cool's classes. \nFirst, two classes are defined. The class 𝑂𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑙𝑎𝑤 \ncontains the transformation rules of some common operations. \nThe class 𝑄𝑢𝑎𝑑𝑟𝑖𝑐𝑒𝑞𝑢𝑎𝑡𝑖𝑜𝑛 contains a formula for solving the \nunivariate quadratic equation. Then, the main program class \n𝑄𝑢𝑎𝑑𝑟𝑖𝑐𝑒𝑞𝑢𝑎𝑡𝑖𝑜𝑛 inherits the two classes previously defined, \nand defines two functions in the program to solve the univariate \nquadratic equation and modify the member variables: \nCODE 20 Complete code example 2 \n//𝐷𝑒𝑓𝑖𝑛𝑒 𝑐𝑙𝑎𝑠𝑠𝑒 𝑐𝑜𝑚𝑝𝑜𝑠𝑒𝑑 𝑜𝑓 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛 𝑙𝑎𝑤𝑠 \n𝑠𝑦𝑠𝑡𝑒𝑚: 𝑂𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝐿𝑎𝑤{  \n \n //𝑡𝑟𝑎𝑛𝑠𝑝𝑜𝑠𝑖𝑡𝑖𝑜𝑛 𝑜𝑓 𝑡𝑒𝑟𝑚𝑠 \n \n 𝑒𝑥𝑝: @(−10){$𝑎== 𝑏}{ \n \n      \n       𝑟𝑒𝑡𝑢𝑟𝑛: 𝑎−𝑏== 0; \n \n } \n \n //𝐴𝑑𝑑𝑖𝑡𝑖𝑜𝑛 𝑎𝑛𝑑 𝑠𝑢𝑏𝑡𝑟𝑎𝑐𝑡𝑖𝑜𝑛 𝑐𝑜𝑛𝑣𝑒𝑟𝑠𝑖𝑜𝑛 \n \n 𝑒𝑥𝑝: @(−10){#𝑎−𝑏}{ \n \n             𝑟𝑒𝑡𝑢𝑟𝑛: 𝑎+ (−𝑏); \n \n } \n}; \n//𝐷𝑒𝑓𝑖𝑛𝑒 𝑐𝑙𝑎𝑠𝑠𝑒𝑠 𝑓𝑜𝑟 𝑠𝑜𝑙𝑣𝑖𝑛𝑔 𝑞𝑢𝑎𝑑𝑟𝑎𝑡𝑖𝑐 𝑒𝑞𝑢𝑎𝑡𝑖𝑜𝑛𝑠 \n𝑠𝑦𝑠𝑡𝑒𝑚: 𝑄𝑢𝑎𝑑𝑟𝑎𝑡𝑖𝑐𝐸𝑞𝑢𝑎𝑡𝑖𝑜𝑛{  \n/∗𝐹𝑢𝑛𝑐𝑡𝑖𝑜𝑛𝑠 𝑓𝑜𝑟 𝑠𝑜𝑙𝑣𝑖𝑛𝑔 𝑠𝑡𝑎𝑛𝑑𝑎𝑟𝑑 𝑞𝑢𝑎𝑑𝑟𝑎𝑡𝑖𝑐  \n \n𝑒𝑞𝑢𝑎𝑡𝑖𝑜𝑛𝑠 𝑜𝑓 𝑜𝑛𝑒 𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒∗/ \n \n @(−100){ 𝑎∗$𝑥^2 + 𝑏∗𝑥+ 𝑐== 0; }{  \n            \n   𝑥= (−𝑏+ (𝑏^2 −4 ∗𝑎∗𝑐)^0.5)/(2 ∗𝑎); \n \n } \n} \n/∗\"<<\"𝑚𝑒𝑎𝑛𝑠 𝑖𝑛ℎ𝑒𝑟𝑖𝑡. 𝑇ℎ𝑒 𝑀𝑎𝑖𝑛𝑃𝑟𝑜𝑐𝑒𝑠𝑠𝑐𝑙𝑎𝑠𝑠 \n𝑖𝑛ℎ𝑒𝑟𝑖𝑡𝑠 𝑡ℎ𝑒 𝑂𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝐿𝑎𝑤 𝑐𝑙𝑎𝑠𝑠 𝑎𝑛𝑑 𝑡ℎ𝑒  \n𝑄𝑢𝑎𝑑𝑟𝑎𝑡𝑖𝑐𝐸𝑞𝑢𝑎𝑡𝑖𝑜𝑛 𝑐𝑙𝑎𝑠𝑠. 𝐼𝑡 𝑐𝑎𝑛 𝑎𝑐𝑐𝑒𝑠𝑠 𝑡ℎ𝑒 𝑚𝑒𝑚𝑏𝑒𝑟𝑠 𝑜𝑓 \n 𝑡ℎ𝑒 𝑡𝑤𝑜 𝑐𝑙𝑎𝑠𝑠𝑒𝑠 𝑎𝑡 𝑡ℎ𝑒 𝑠𝑎𝑚𝑒 𝑡𝑖𝑚𝑒 ∗/ \n𝑠𝑦𝑠𝑡𝑒𝑚: 𝑀𝑎𝑖𝑛𝑃𝑟𝑜𝑐𝑒𝑠𝑠≪ \n 𝑂𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝐿𝑎𝑤, 𝑄𝑢𝑎𝑑𝑟𝑎𝑡𝑖𝑐𝐸𝑞𝑢𝑎𝑡𝑖𝑜𝑛 {  \n \n 𝑛𝑒𝑤: 𝑥= 1; \n \n @𝑐𝑜𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟(){ \n \n              \n 1 ∗$𝑥^2 + 4 ∗𝑥== 100; \n \n           \n 𝑥−−> 0; \n \n } \n \nHAN Ji-Peng, LICHEN Zhi-Hang： \nA Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System \n7 \n \n @𝑖𝑛𝑐𝑟𝑒𝑎𝑠𝑒(𝑛){ \n \n     \n \n 𝑥= 𝑥+ 𝑛; \n \n } \n}; \n𝑀𝑎𝑖𝑛𝑃𝑟𝑜𝑐𝑒𝑠𝑠: 𝑚;//𝑐𝑟𝑒𝑎𝑡𝑒 𝑐𝑙𝑎𝑠𝑠 𝑜𝑏𝑗𝑒𝑐𝑡𝑠 \n𝑚. 𝑐𝑜𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟();//𝐶𝑎𝑙𝑙 𝑚𝑒𝑚𝑏𝑒𝑟 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛 \n𝑚. 𝑖𝑛𝑐𝑟𝑒𝑎𝑠𝑒(10); \n𝑚. 𝑥−→0;//𝑂𝑢𝑡𝑝𝑢𝑡 𝑡ℎ𝑒 𝑣𝑎𝑙𝑢𝑒 𝑜𝑓 𝑡ℎ𝑒 𝑚𝑒𝑚𝑏𝑒𝑟 𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒 \n2.8 PRECOMPILE \nThe precompile process performs the following operations: \n·Delete source code comments; \n·Delete spaces and line breaks in the source code; \n·Merge the source code in multiple files; \n·Code replacement;； \n·Delete invalid source code; Wherein, the invalid source \ncode is the code that is marked by the user through the \npreprocessing instruction that does not need to be compiled and \nthe code that will not be executed due to the non-standard writing \nby the user; \n·Replace the non ASCII code appearing in the source code \nidentifier with ASCII code string \n·Deform the function declaration and its call statements \ncomposed of strings and parameters in the source code; In this \nstep, move all function parameters that are not after the function \nname string to the end of function name string, and keep the \norder of function parameters unchanged; At the same time, a new \nstring is formed by replacing the original position of the function \nparameter with a specific string, which is used to identify a \nparameter originally corresponding to this position, for example: \n\"_ARG_\"; Specifically, 𝑎𝑑𝑑 (𝑎) 𝑎𝑛𝑑 (𝑏) 𝑡𝑜 (𝑐) is transformed \ninto 𝑎𝑑𝑑_ 𝐴𝑅𝐺_ 𝑎𝑛𝑑_ 𝐴𝑅𝐺_𝑡𝑜(𝑎, 𝑏, 𝑐) after precompiling. This \nmethod allows function parameters to embed function name \nstring. \n2.9 COMPILE \nThe precompiled code is compiled into character code \nthrough lexical analysis program and syntax analysis program. \nThe character code consists of three parts, including code type \nflag bit, quaternion and quaternion parameter type flag bit array.  \nCode types and the functions they describe include:  \n\"Variable declaration\", declaring a variable; \n\"Function operation\", including the operation of binding \nthe scope of function declaration to the scope of function body \nand the operation of binding weight and return type to the scope \nof function declaration; \n\"Derivation function\", deriving the implementation logic of \nreverse function according to the function body scope of forward \nfunction;  \n\"Scope start\" is used to declare the start of the scope; \n\"Scope end\" is used to declare the end of the scope; \n\"Expression\", indicating that the quaternion of this line of \ncode is part of the expression; Operations, function calls, and \nassigning attributes (\"$\", \"out\") to variables are \"Expressions\"; \n\"Jump\", when the condition is true, jump to the code \ncorresponding to the address for execution;  \n \"End of expression\" indicates that the expression of the \ncode in the previous line of the current executing code has ended, \nwhich plays the role of truncating the expression;  \n\"Return\" is used for function return; \n \n \"Access member\", the computer is required to access \nparameters according to the given path;  \n\"Class operation\", including declaring a class, binding the \nclass to the scope, and class inheritance;  \n Code types and the functions they describe include: \n\"Variable declaration\", declaring a variable; \n\"Function operation\", including the operation of binding \nthe scope of function declaration to the scope of function body \nand the operation of binding weight and return type to the scope \nof function declaration; \n\"Derivation function\", deriving the implementation logic of \nreverse function according to the function body scope of forward \nfunction; \n\"Scope start\" is used to declare the start of the scope; \n\"Scope end\" is used to declare the end of the scope; \n\"Expression\", indicating that the quaternion of this line of \ncode is part of the expression; Operations, function calls, and \nassigning attributes (\"$\", \"out\") to variables are \"expressions\"; \n\"Jump\", when the condition is true, jump to the code \ncorresponding to the address for execution; \n\"End of expression\" indicates that the expression of the \ncode in the previous line of the current executing code has ended, \nwhich plays the role of truncating the expression; \n\"Return\" is used for function return; \nWhen \"member access\", the computer is required to access \nparameters according to the given path; \n\"Class operation\", including declaring a class, binding the \nclass to the scope, and class inheritance; \nQuaternion and quaternion parameter type flag bit array are used \nto store the left operand, right operand, operator, operation result \nand corresponding data type of quaternion when the code type is \n\"Expression\"; When the code is of other types, it is only used to \n8 \n计 算 机 学 报 \n20??年 \nstore relevant parameters and corresponding data types. \n2.10 PRE-EXECUTION \n2.10.1 LOAD CHARACTER CODE \n In the pre execution process, the compiled character code \nfile will be loaded first, and it will be converted into extended \ncode line by line. At the same time, the conversion will generate \nthe scope table, function table and class table to make it easier to \nobtain the required information. \nThe specific contents of each table generated during the \nloading process are as follows: \n(1) Extended code table \nExtended code table is a two-dimensional table with code \naddress as key and extended code as value; The key-value pairs \n(tuples) in the table are arranged from small to large and from \nfront to back according to the address; \nThe expanded code specifically includes: address of the \nscope where the code is located, code executable flag bit, code \ntype flag bit, quaternion parameter type flag bit array, quaternion \nformal parameter flag bit array, quaternion local scope parameter \nflag bit array, quaternion parameter pending flag bit array,  bound  \nfunction address, function root node flag bit. The functions of \neach part are: \naddress of the scope where the code is located：Used to \nidentify the address in the scope table of the scope where this \nline of code is located; \ncode executable flag bit：It is used to identify whether the \ncode can be executed. The code corresponding to the scope of \nthe function declaration cannot be executed. This flag bit is \n\"false\"; The function body scope, class scope and the jump part \nof the conditional statement can be executed only after certain \nconditions are met. This flag bit is \"execute under certain \nconditions\"; In other cases, this flag bit is \"true\"; \nCode type flag bit, quaternion , quaternion parameter type flag \nbit array: the same functions as those in character codes; \nQuaternion formal parameter flag bit array: valid when the \nexecutable flag bit of the code is \"false\" (that is, the code is in \nthe scope of the function declaration), which is used to identify \nwhether the parameter in the quaternion is a formal parameter; \nQuaternion local scope parameter flag bit array: shares the \nstorage space with quaternion formal parameter flag bit array. It \nis valid when the executable flag bit of the code is not \"false\" \n(that is, the code is not in the scope of the function declaration), \nIt is used to identify whether to query the corresponding \nparameters in the quaternion from the scope of the current code \n(flag bit is \"true\") or from the upper scope of the scope of the \ncurrent code (flag bit is \"false\"); \nQuaternion parameter pending flag bit array: used to identify \nwhether the value of the corresponding parameter in the \nquaternion is pending when this line of code is executed. If the \nparameter is pending (the flag bit is \"true\"), the value of this \nparameter will be regarded as unknown. Even if this parameter \nhas a corresponding value at this time, its value will be regarded \nas invalid; If the parameter is determined (the flag bit is \"false\"), \nthe value of this parameter will be regarded as a known \ncondition; In particular, for the function returning expression, in \nmany cases, the rules it represents can be used regardless of \nwhether the variable is pending, so the parameters in the function \ndeclaration are allowed to have three states: “pending”, \n“determined”, and “unrelated”. Accordingly, the flag bits also \nhave three states: “true”, “false”, and “unrelated”; \nBound function address: The address used to identify the \nfunction bound to the code (segment); Since all function \ndeclarations in COOL are expressions, calling a function \nrequires that the function declaration expression of the function \nbe bound to the expression with the same structure, and the \nbound function is called when the expression corresponding to \nthe code snippet is executed. The address was determined in step \n2.10.2; \n Function root node flag bit: This flag bit is true, indicating \nthat this line of code corresponds to the root node of the function \ndeclaration expression of the bound function and false to the \nchild node. Used to handle situations where a piece of code is \nbound to the same function multiple times in a row (that is, the \nsame function is called in a row), and since each line of code has \nthe same bound function address, it is not possible to directly \ndifferentiate between individual function calls. This flag is \ndetermined at step 2.10.2. \n（2）Scope table \n The scope table is a two-dimensional table with the address \nof the scope as the key and the scope information as the value. \nEach key-value pair in the scope table is arranged from small to \nlarge and from go to back according to the address. \nScope information includes scope type flag bit, scope start \naddress, scope end address, and address of scope used for \nparameter query. The functions of each part are: \nScope type flag bit: used to describe a scope as a function \ndeclaration scope, or, a function body scope; \n \nHAN Ji-Peng, LICHEN Zhi-Hang： \nA Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System \n9 \nScope start address: The address of the scope start code in \nthe code table; \nScope end address: The address of the scope end code in \nthe code table; \nAddress of scope used for parameter query: Address of the \nscope to be accessed when querying parameters that are involved \nin but not declared in this scope and in the outer scope of this \nscope. \"Address of scope used for parameter query\" of the \nfunction implementation (body) scope is the corresponding \nfunction declaration scope address; \n （2）Function table \nFunction table is a two-dimensional table with function \naddress as key and function information as value. The key-value \npairs in the function table are arranged from small to large and \nfrom going to back according to the size of the address. \nFunction information includes: function declaration scope \naddress, function declaration root node address, function body \nscope address, “return” code address array, function returning \nexpression flag bit, reverse function flag bit, function weight; \nThe functions of each part are: \n Function declaration scope address：Identifies the scope \naddress of the function declaration; \n Function declaration expression root node address: address \nof the code where the root node quaternion of function \ndeclaration expression is located; \n Function body scope address: address of function body \nscope \n \"Return\" code address array: code addresses of all return \nstatements in the scope of the function body; \n Function returning expression flag bit：used to identify the \nfunction return expression or return operation value; \n Reverse function flag bit: used to identify the function as \nforward function or reverse function \n Function weight: identifies the weight value of a function; \n（3）Class table \n Class table is a two-dimensional table with class address as \nkey and class information as value; The key value pairs in the \nclass table are arranged from small to large and from front to \nback according to the size of the address; \n The address of the class is the address of the scope of the \nclass body; \nClass information includes: class scope address, class name \nand parent class address array; The functions of each part are: \nClass scope address: the address of the scope of the class \nbody. \nClass name: name of the class. \n Parent class address array：an array that stores the \naddresses of classes directly inherited by the class. \n During loading, all addresses are converted to multi-level \naddresses to facilitate subsequent code table insertion and \ndeletion. Multi level addresses meet: \nMulti level address is an address composed of a one-\ndimensional integer array and the first and last bits of the array \nare not zero; The multi-level address with only one number in \nthe array is the single-level address, and the multi-level address \nwith zero numbers in the array is the empty address; The size \ncomparison method between multi-level addresses is to start \nfrom the starting position of the multi-level address array and \nthen compare their corresponding digits backward: if each digit \nis equal, the two multi-level addresses are equal; if two digits are \nnot equal, the address corresponding to the array where the larger \ndigit is located is larger; If the array of one multi-level address \nis shorter than the array of another multi-level address, the \nnumber of the empty position of the shorter array relative to the \nlonger array is zero by default. \n2.10.2  REASONING PROCESS \n(In this section, for convenience of expression, code \nsegments, expressions and syntax trees are allowed to refer to \neach other without ambiguity.) \n From front to back, execute each line of code in the \nextended code table according to the following rules: \nStep A: for the code whose \"code executable flag bit\" is \n\"false\", directly skip the current execution code;  \nStep B: for the code whose \"code executable flag bit\" is \n\"execute under certain conditions\" or \"true\", execute one or more \nof the following sub steps according to the \"code type flag bit\": \nSub step B-1: when \"code type flag bit\" is \"jump\", skip the \ncurrent execution code; \nSub step B-2: when \"code type flag bit\" is \"return\", skip the \ncurrent execution code; \nSub step B-3: when \"code type flag bit\" is \"function \noperation\", skip the current execution code; \nSub step B-4: when \"code type flag bit\" is \"scope start\", \ncreate an active record for the scope starting from the currently \nexecuted code in the current active record, and mark the created \nactive record as the current active record; In particular, when this \nscope is the scope of a class, if it has an inherited parent class, \nthe pointer to the active record of the parent class is directly \n10 \n计 算 机 学 报 \n20??年 \nadded to the “array of pointers to parameter query active \nrecords” of the current active record; \nThe active record is used to record the context information \ninvolved before and after the specific execution of the code \nwithin a scope and the information generated during the \nexecution, specifically including: data table and active record \ninformation; \nThe data table is a two-dimensional table. The key of the \ntwo-dimensional table is the identifier name, or the address of \nthe parameter, or the address of the scope of the active record. \nThe value of the two-dimensional table is a number, or a string, \nor an active record, or a path to access another parameter, or \nother supported data types. \nThe active record information specifically includes: formal \nparameter and actual parameter cross reference table, active \nrecord scope address, pointer to parent active record, pointer to \nreturn to active record, return address of current active record, \narray of points to parameter query active records; \nThe \"formal parameter and actual parameter cross reference \ntable\" mentioned above is a two-dimensional table with the \nformal parameter identifier as the key and the actual parameter \nidentifier or the actual parameter address as the value. This table \nis created when and only if the active record is an active record \nof a function body scope; During the pre-execution process, this \ntable is only obtained by analyzing the function declaration \nscope, only the formal parameters are stored, and the actual \nparameters corresponding to the formal parameters are empty \n(default value); During execution, this table is obtained by \ncomparing the function declaration scope with the code segment \nthat calls this function to store the formal parameters with the \ncorresponding actual parameters. \nThe active record scope address is the address of the scope \ncorresponding to this active record; \nThe parent activity record described refers to an active \nrecord whose data table range directly contains this active \nrecord. \nThe return to active record described refers to an active \nrecord that should be set as the current active record after it has \nleft the current active record, and the return to active record of \nan active record defaults to its parent active record. If an active \nrecord is created as a result of a function call, its return to active \nrecord should be an active record that records the action of the \nfunction call. When querying the actual parameters, you need to \nvisit return to active record for query. \nThe return address of current active record refers to the \naddress of the code that should be marked as currently executed \nwhen returned from the current active record, defaulting to the \nnext line of code currently executed. If the current active record \nwas created as a function call, the return address should be the \nnext line of code at the function call. \nThe parameter query active record described refers to the \nactive record that needs to be accessed when querying variables \nthat do not appear in the data table of the current active record \nand the formal parameter and actual parameter cross reference \ntable. The parent instance generated when a subclass instance is \ncreated is the parameter query active record corresponding to the \nactive record for this subclass instance. \nSub step B-5, when \"code type flag bit\" is \"Scope end\", \ndestroy and leave the current active record if the current scope is \nnot a class instance, and mark return to active record as the \ncurrent active record; If the current scope is a class instance, \nleave the current active record without destroying it, and mark \nreturn to active record as the current active record. \nSub step B-6, when \"code type flag bit\" is \"Variable \ndeclaration\", add a key-value pair with the parameter identifier \nas the key and the default value of the parameter to the data table \nof the current active record. In particular, when a declared \nvariable is an instance of a class, an active record is no longer \ncreated for that class's instance, but directly references the \nexisting active record corresponding to the class scope, which \nmeans that all instances of the same class use the same active \nrecord during pre-execution. \nSub step B-7, when \"code type flag bit\" is Expression and \nthe current code is not scoped within the body of a function \nreturning expression, execute any of the following sub steps: \nSub step B-7-1 skips the current code directly when the \ncurrently executed code is bound to a function, that is, when the \nbound function address of the currently executed code is not \nempty; \nSub step B-7-2, when the code currently executed is not \nbound to a function, that is, its bound function address is empty, \nperforming code replacement and function binding operations; \nIn this sub-step B-7-2, a data representation format 𝑎(𝑏|𝑐) \nis defined to indicate that data 𝑎 is created or assigned in the 𝑏-\ncycle (number of matching rounds) and used in the 𝑐 -cycle. \nDefine the representation of a key-value pair < 𝑎, 𝑏> , \nindicating that the key is 𝑎 and the value is 𝑏. \nIn this sub-step B-7-2, the conditions for initialization \n \nHAN Ji-Peng, LICHEN Zhi-Hang： \nA Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System \n11 \n(Round 0 Matching), Round 𝑘 Matching, and Exit Matching are \ndone in turn. Specifically, this sub-step B-7-2 performs the \nfollowing operations: \nB-7-2-1, copy the code segment 𝑒  corresponding to the \nexpression with the longest code currently executed, and get the \nkey-value pair < 0, 𝑒> with the initial cumulative weight value \nof 0 as the key and the copied code segment as the value. \nB-7-2-2, add a duplicate code segment key-value pair to the \ncurrent code table silo 𝑆 , where 𝑆  is a two-dimensional table \nwith a cumulative weight value as the key and a code segment \nas the value, and is also considered a set of key-value pairs; \n𝑺(0|1) =< 0, 𝑒>\n(1) \nAt this time, 𝑺(0|1) only has < 0, 𝑒> as an element;； \nThe code table silo described is a two-dimensional table \nwith the cumulative weight value as the key and the code \nsegments as the value. Each key-value pair in the code table silo \nis arranged from small to large according to the cumulative \nweight value. The maximum number of stored key-value pairs \n𝑚 in the code table silo is set by the user. \nOptionally, adding elements to the code table silo meets the \nfollowing requirements a and b: \na: When attempting to add a new key-value pair to a full \ncode table silo, if the cumulative weight value in the key-value \npair is greater than the minimum value of the cumulative weight \nvalue in all keys of the code table silo, the code table silo first \ndeletes its header key-value pair and then adds a new key-value \npair, if the cumulative weight value in the key-value pair is less \nthan or equal to the minimum value of the cumulative weight \nvalue in all keys, Code table silo will not do anything with the \nadded key-value pairs, nor will it add new key-value pairs; \nb: Code table silo allows the existence of key-value pairs \nwith identical keys and different values, and does not allow the \nexistence of two identical key-value pairs. \n. For 𝑘∈𝑁∗, when the current code table silo 𝑆(𝑘−1|𝑘) \nis not empty, for all< 𝑤𝑖, 𝑒𝑖>∈𝑆(𝑘−1|𝑘)， {𝑖|𝑖∈𝑁∧𝑖<\n𝑐𝑎𝑟𝑑(𝑆(𝑘−1|𝑘))} ；Match \nall \nsyntax \ntree \nbranches \n(corresponding sub code segments) in 𝑒𝑖  that meet the \nrequirement that no function is bound to the code of any node, \nwith all accessible functions. The functions that are accessed first \nare matched first. Whenever a syntax tree branch of 𝑒𝑖 matches \na function 𝑓𝑢𝑛  successfully, code replacement or function \nbinding is performed on 𝑒𝑖 according to the type of function to \ngenerate code segment 𝑒𝑗; The corresponding weight value of 𝑒𝑗 \nis the result of adding the weight value of 𝑓𝑢𝑛  to the weight \nvalue of 𝑒𝑖, namely: \n𝑤𝑗= 𝑤𝑖+ 𝑤𝑓𝑢𝑛\n(2) \nThe accessible functions refer to the functions declared \nbefore the current location and located in the current scope or the \nupper scope of the current scope, and if the scope of the current \ncode is the scope of a class or its child scope, the member \nfunctions of the inherited classes of this class can also be \naccessed; Code segment matching function refers to comparing \nthe expression 𝑒𝑥𝑝1 represented by code segment with function \ndeclaration expression 𝑒𝑥𝑝2 . If the syntax tree structures of \n𝑒𝑥𝑝1 and 𝑒𝑥𝑝2 are the same, and any node 𝑛𝑜𝑑𝑒1 of 𝑒𝑥𝑝1 and \n𝑛𝑜𝑑𝑒2  of 𝑒𝑥𝑝2  that is aligned with 𝑛𝑜𝑑𝑒1  are taken, the \nmatching is successful if 𝑛𝑜𝑑𝑒1  and 𝑛𝑜𝑑𝑒2  meet one of the \nfollowing five conditions: \nNode1 node2  \n·Node1 is a concrete value and node2 is a formal \nparameter of the same type \n·Node1 is a variable and node2 is a formal parameter of \nthe same type \n·Node2 is the actual parameter and node2 and node1 are \nthe same variable, for example, code 21: \n·𝑛𝑜𝑑𝑒1 is a specific value and 𝑛𝑜𝑑𝑒2 is the same value \n· 𝑛𝑜𝑑𝑒1 is a specific value and 𝑛𝑜𝑑𝑒2  is \na \nformal \nparameter of the same type \n·𝑛𝑜𝑑𝑒1 is a variable and 𝑛𝑜𝑑𝑒2 is a formal parameter of \nthe same type \n· 𝑛𝑜𝑑𝑒2 is the actual parameter and 𝑛𝑜𝑑𝑒2 and 𝑛𝑜𝑑𝑒1 \nare the same variable, for example, code 21: \nCODE 21 Node matching example \n𝑛𝑒𝑤: 𝑁= 3; \n@{𝑓(𝑁, 𝑎)}{ \n \n 𝑟𝑒𝑡𝑢𝑟𝑛: 𝑁−𝑎; \n} \n@{𝑓(𝑜𝑢𝑡: 𝑁, 𝑎)}{ \n \n 𝑟𝑒𝑡𝑢𝑟𝑛: 𝑁+ 𝑎; \n} \n𝑓(𝑁, 4);/∗ 𝑆𝑢𝑐𝑐𝑒𝑠𝑠𝑓𝑢𝑙𝑙𝑦 𝑚𝑎𝑡𝑐ℎ𝑒𝑑 𝑤𝑖𝑡ℎ  @{𝑓(𝑁, 𝑎)} \n𝑎𝑛𝑑 @{𝑓(𝑜𝑢𝑡: 𝑁, 𝑎)} ∗/ \n{ \n \n 𝑛𝑒𝑤: 𝑁; \n \n 𝑓(𝑁, 4);/∗𝑆𝑢𝑐𝑐𝑒𝑠𝑠𝑓𝑢𝑙𝑙𝑦 𝑚𝑎𝑡𝑐ℎ𝑒𝑑 𝑤𝑖𝑡ℎ \n@{𝑓(𝑁, 𝑎)} and failed to match with @{𝑓(𝑜𝑢𝑡: 𝑁, 𝑎)} ∗/ \n \n 𝑓(𝑜𝑢𝑡: 𝑁, 4);/∗ Successfully matched with \n @{𝑓(𝑁, 𝑎)} and @{𝑓(𝑜𝑢𝑡: 𝑁, 𝑎)} ∗/ \n} \n·If 𝑛𝑜𝑑𝑒1 or 𝑛𝑜𝑑𝑒2 is the access path of a variable, the \nvariable pointed to by the path is taken to replace the original \nnode for comparison, and the comparison results meet one of the \nabove four conditions. \n12 \n计 算 机 学 报 \n20??年 \nPerform code replacement or function binding on 𝑒𝑖 , \nspecifically: \nIf 𝑓𝑢𝑛 is function returning expression, mark its function \ndeclaration expression as 𝑒𝑓𝑢𝑛𝐴𝑛𝑛𝑜𝑢𝑛𝑐𝑒, the expression returned \nby the function is 𝑒𝑓𝑢𝑛𝑅𝑒𝑡𝑢𝑟𝑛, and the weight of the function is \n𝑤𝑓𝑢𝑛; Then the code segment of 𝑒𝑗 is obtained by replacing a sub \ncode segment in the code segment of 𝑒𝑖  that matches \nefunannounce with the code segment corresponding to \n𝑒𝑓𝑢𝑛𝑅𝑒𝑡𝑢𝑟𝑛 after parameter replacement; If there are multiple sub \ncode segments matching 𝑒𝑓𝑢𝑛𝐴𝑛𝑛𝑜𝑢𝑛𝑐𝑒 in the 𝑒𝑖, multiple 𝑒𝑗 are \ngenerated; \nThe parameter replacement operation is performed for code \nsegment, that is, the formal parameter in 𝑒𝑓𝑢𝑛𝐴𝑛𝑛𝑜𝑢𝑛𝑐𝑒  is \nreplaced with the corresponding actual parameter in 𝑒𝑖. \nWhen 𝑓𝑢𝑛 represents a simplification operation, code \nsegments that are separated from the expression syntax tree may \nbe generated after code replacement using function returning \nexpression (for example, transformation (𝑥+ 1) ∗𝑎+ (𝑥+\n1) ∗ 𝑏 →(𝑥+ 1) ∗ (𝑎+ 𝑏)  will make an 𝑥+ 1  separate from \nthe syntax tree); As shown in Figure 1: \n+\nans1\ntmp3\nans1\nAfter applying the simplification \noperation a*c+a*b→ a*(c+b), an expression \nis separated from the syntax tree\nOriginal expression\n+\n1\nx\n*\ntmp1\ny\n+\n1\nx\n*\ntmp3\nz\ntmp2\ntmp4\n+\n1\nx\n*\ntmp1\ntmp2\n+\n1\nx\n+\ny\nz\ndetached \nbranch\n \nFigure 1. Example of syntax tree branch breaking away \nfrom syntax tree \nWhen 𝑓𝑢𝑛 represents a complex operation, the syntax tree \nof the expression may generate a ring structure after using \nfunction returning expression for code replacement (for \nexample, \ntransformation (𝑎+ 𝑏) ∗(𝑥+ 1)→ 𝑎∗(𝑥+ 1) +\n 𝑏∗(𝑥+ 1). When the syntax tree has only one 𝑥+ 1 branch, \n𝑎∗(𝑥+ 1)and 𝑏∗(𝑥+ 1) will reference the root node of the \nsame 𝑥+ 1  branch, and the secondary reference to 𝑥+ 1  will \ngenerate a ring structure); As shown in Figure 2: \n+\nans1\nThe ring structure is formed after applying the complex \noperation a*(c+b)→ a*c+a*b\nans1\nOriginal expression\ntmp1\n+\n1\nx\n*\ntmp1\ny\n*\ntmp1\nz\ntmp2\ntmp4\n+\n1\nx\n*\ntmp1\ntmp2\n+\ny\nz\n \nFigure 2. Example of an expression syntax tree forming a \nring structure \nBased on this, after the code replacement operation, you \nneed to find and delete the code segment that is separated from \nthe expression syntax tree in the code segment, find the ring \nstructure and expand it; To find the ring structure, check whether \nthe new replacement part of the syntax tree refers to the same \nsyntax tree branch at least twice. If this happens, there is a ring \nstructure; To expand the ring structure, copy the code segment \ncorresponding to the syntax tree branch whose root node is \nreferenced at least twice, replace the code address of the code \nsegment corresponding to the copied syntax tree branch and the \naddress used to store the intermediate variables generated at \nruntime with the unused address, so that the code segment copied \nby this syntax tree branch can be inserted into the code segment \nafter the code replacement operation and located before the \nsecond reference position of the root node of the primitive syntax \ntree branch without address conflict; then insert it into the code \nsegment after the code replacement operation, and change the \nsecond reference to the root node of the syntax tree branch \ncausing the ring structure to the reference to the root node of the \ncopied code segment of the inserted syntax tree branch; Repeat \nthe operation of finding and expanding the ring structure until \nthere is no ring structure in the new replacement part of the \nsyntax tree. \nB-7-2-4. The matching process ends when one of the \n \nHAN Ji-Peng, LICHEN Zhi-Hang： \nA Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System \n13 \nfollowing conditions is met: \n·When 𝑒𝑗satisfies that all codes have functions bound to \nit, the matching process ends successfully, and 𝑒𝑗 is used to \nreplace the corresponding code segment in the code table of the \nlongest expression where the currently executing code is located; \nOtherwise, add < 𝑤𝑗, 𝑒𝑗>  to 𝑆(𝑘|𝑘+ 1)  and continue the \nmatching process:： \n𝑆(𝑘|𝑘+ 1) = 𝑆(𝑘|𝑘+ 1) ∪< 𝑤𝑗, 𝑒𝑗>\n(3) \n·When the number of matching rounds 𝑘  exceeds the \nupper limit 𝑘𝑚𝑎𝑥  specified by the user, the matching process \nends in failure;  \n·When there are no available elements to match in this \nround and the next round, it ends with failure: \n𝑆(𝑘−1|𝑘) =  ∅  ∧𝑆(𝑘|𝑘+ 1) =  ∅\n(4) \nFigure 3 shows the binding of expression and function of \ncode 22 (excerpted from code 15) after pre execution: \nCODE 22 Snippet of complete code example 1 \n@𝑔𝑒𝑡 𝑟𝑒𝑠𝑢𝑙𝑡 𝑓𝑟𝑜𝑚 (𝑥) 𝑎𝑛𝑑 (𝑦){   \n \n𝑛𝑒𝑤: 𝑎 =  𝑥+ 𝑦; \n \n$𝑥+ 1 == 𝑦;  \n \n𝑛𝑒𝑤: 𝑧= 0; \n \n1 ∗$𝑧^2 + 𝑥∗𝑧+ 𝑦== 100; \n \n𝑟𝑒𝑡𝑢𝑟𝑛: 𝑎+ 𝑥+ 𝑧; \n} \n \na\n$ans\nz\n+\n+\n==\n$ans2\nans3\n{\nnew:a;\nnew:z;\nreturn:ans3;\n}\nBinding with built-in \nfunction @{a+b}\nBinding with \ninverse function\n@(10){$a == b;}\nBinding with \ninverse function\n@(10){$a+b}\nBinding with \nbuilt-in function \n@{a=b}\nBinding with inverse \nfunction\n@(100){a*$x^2+b*x+c}\nBinding with \ninverse function\n@(10){$a == b;}\nBinding with \nbuilt-in function \n@{a+b}\nBinding with \nbuilt-in function \n@{a+b}\nBinding with built-\nin function @{a=b}\n+\nx\ny\n+\n$x\n1\n==\n$tmp2\ny\n=\nz\n0\n^\n$z\n2\n*\n1\n$tmp3\n*\nx\n$z\n$tmp4\n$tmp5\n$tmp6\ny\n$tmp7\n50\n+\na\nx\n+\ntmp8\nz\n=\ntmp1\na\n \nFigure 3. Binding of expressions and functions in code 22 \nafter pre execution \nSub step B-8: when code type flag bit is \"end of \n14 \n计 算 机 学 报 \n20??年 \nexpression\", it can be known that the longest expression of the \nlast line of code in the currently executed code has ended, and \nthe currently executed code is skipped; \nSub step B-9: when code type flag bit is \"derivation \nfunction\", use the function implementation of forward function \nto derive the function implementation of reverse function; \nThe derivation of the reverse function implementation \nusing the forward function implementation requires the \nfollowing sub steps: \nSub step b-9-1, disassemble the function body code \nsegment of the forward function into code blocks; \nSub step b-9-2, use code blocks to derive the execution \nprocess of reverse function. \nIn sub step b-9-1, the code block is composed of sequence \nnumber, code segment and code block information. The \nsequence number is generated when the code block is created. \nThe earlier the code block is created, the smaller its sequence \nnumber. The code block information includes: the type of code \nblock, which is used to reflect the type of code in code segment, \nand can be \"expression\" \"scope start\" \"scope end\" \"return\" \ndefault; The code block depends on pending input parameters \nflag bit is used to indicate whether there are variables in code \nsegment that depend on pending input parameters; A variable \ndepends on pending input parameters, which means that \ndetermining the value of pending input parameters is a necessary \ncondition for determining the value of this variable during the \nforward execution of function body code. Conversely, a variable \nis independent of the pending input parameter, which means that \ndetermining the value of the pending input parameter is not a \nnecessary condition for determining the value of the parameter \nduring the forward execution of the function body code. \nOptionally, in sub-step B-9-1, the disassembly process \nprogressively analyzes each line of code of the forward \nfunction's function body from front to back, skipping the current \ncode if the code executable flag bit of the current analysis code \nis false; If the code executable flag bit of the current analysis \ncode is \"true\" or \"execute under certain conditions\", perform the \nfollowing steps according to the code type flag bit: \nB-9-1-1, when the code type flag bit is \"scope start\": create \na code block whose type is \"scope start\", whose code block \ndepends on pending input parameters flag bit is \"false\" \n(independent) and code segment is the current analysis code; \nAdd the code block from the end to the code block queue 𝑩; \n \nB-9-1-2, when the code type flag bit is \"scope end\": create \na code block whose type is \"scope end\", whose code block \ndepends on pending input parameters flag bit is \"false\", and \nwhose code segment is the current analysis code; Add the code \nblock from the end to the code block queue 𝑩; \nB-9-1-3, when the code type flag bit is \"end of expression\", \nskip the current code; \nB-9-1-4 when the code type flag bit is \"expression\" and the \nfunction root node flag bit is \"true\", copy the code segment \ncorresponding to the function call expression where the current \ncode is located, and then copy the code segment to create the \ncode block by performing the following operations in sequence: \nB-9-1-4-1, replace variables in the code: \nWhen a variable is modified, it will not be the original \nvariable. In order to avoid confusion between the modified \nvariable and the original variable, it is necessary to use a new \nvariable to represent the modified variable to distinguish it from \nthe original variable; It shall be handled according to the \nfollowing rules: \n·If a non temporary variable is to be determined, replace \nthe variable with a new variable and add the new variable to set \n𝑨𝑟𝑒𝑝𝑙𝑎𝑐𝑒. At the same time, add the key value pair with the old \nvariable replaced as the key and the new variable used to replace \nthe old variable as the value to the variable replacement table; \nThe variable replacement table is a one-to-one mapping table. \nWhen the key values are the same, the newly added key value \npairs will overwrite the previously added key value pairs; \n·If a non temporary variable is determined, query the \nvariable replacement table for a new variable with this variable \nas the key. If a new variable exists, replace it with a new variable; \n·If a variable is the left operand of the assignment \nexpression, replace the variable with a new variable, and add the \nkey value pair with the replaced variable as the key and the new \nvariable as the value to the variable replacement table; \n·A variable in a function call code segment can only be \nreplaced with another variable at most; \nThe function call code segment, that is, all the codes in the \ncode segment are bound to the same function, and only the \nfunction root node flag bit of the last line of code is \"true\", the \nsyntax tree structure of the function call code segment is \ncompletely consistent with the syntax tree structure of the \nfunction declaration of the bound function, and executing the \nfunction call code segment will call the bound function; \nB-9-1-4-2, determine the dependence of each variable in the \n \nHAN Ji-Peng, LICHEN Zhi-Hang： \nA Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System \n15 \ncode on the input parameters to be determined: \nThe code segment containing the variables that depend on \nthe pending input parameters is used to backstep the pending \ninput parameters, while the code segment of the variables that do \nnot contain the pending input parameters serves as the known \ncondition in the backstepping process; Specifically, the \ndependency of each variable in the code on the input parameter \nto be determined shall be determined and handled according to \nthe following rules: \n·If any child node of a variable in the syntax tree depends \non the undetermined input parameter, the variable also depends \non the undetermined input parameter; \n·If a variable is a pending variable, and there is a variable \nthat depends on the pending input parameter in its syntax tree, \nthe variable also depends on the pending input parameter; \n·If a variable is the left operand of the assignment \nexpression and the right operand depends on the pending input \nparameter, the variable also depends on the pending input \nparameter; \n·If a variable depends on a pending input parameter, but it \nwas originally a determined variable in the function body of the \nforward function, change it to a pending variable (that is, make \nthe parameter pending flag bit \"true\"). \nThe temporary variable, that is, the variable used without \ndeclaration, a temporary variable shall be used to store the \noperation result of quaternion when used for the first time; Non \ntemporary variables are variables declared by the user before \nuse. \nB-9-1-4-3, create a code block with the modified code \nsegment: \nCreate a code block of type \"expression\"; if there are \nvariables in the code segment that depend on pending input \nparameters, unbind all codes in the code segment from the \nfunction, and set the flag bit of the code block's dependent \npending input parameters to true; if there is no variable that \ndepends on the pending input parameter in the code segment, set \nthe flag of the pending input parameter of the code block to false; \nadd the code block from the end to the code block queue 𝑩; \nUnbind the code from the function, that is, set the bound \nfunction address of the code to null and the function root node \nflag bit to false; \nB-9-1-5, skip when code type flag bit is \"expression\" and \nfunction root node flag bit is \"false\"; \nB-9-1-6, when the code type flag bit is \"return\", create a \ncode block whose type is \"return\" and code block depends on \npending input parameters flag bit is \"false\"; Since the return \nvalue is known during backstepping process, assign the forward \nfunction return value 𝑎𝑛𝑠  to the returned variable in code \nsegment, and modify the code type \"return\" to \"expression\"; add \nthe code block from the end to the code block queue 𝑩; \nB-9-1-7. In other cases, copy the single line code segment \nwhere the current analysis code is located, and use this copy code \nsegment to create a code block. The type of the code block is \n\"default\", and the code block depends on pending input \nparameters flag bit is \"false\". Add it to the code block queue 𝑩 \nfrom the end;  \nFor example, disassemble code 22 into code blocks. After \ndisassembly: \n𝑩= [1], [2], [3], [4], [5], [6], [7], [8], [9],\n[10], [11], [12], [13], [14]\n(5) \nWhere [𝑛] represents the code block with sequence number \n𝑛, and the content of the code block is as shown in Figure 4 (left: \ncode segment in the code block; right: sequence number, type, \ndependence \non \npending \ninput \nparameters, \nparameter \nreplacement operation information, function bound by code \nsegment on the left): \n16 \n计 算 机 学 报 \n20??年 \n$ans\n_ARG\n_3\n+\n+\n==\n$ans2\n$ans3\n{\nnew:a\nnew:z\n}\n3, expression \n,\ndependent\n6, expression , \nindependent, \nbound with \nreverse function \n@(10){$a == b;}\n5, expression ,  \nindependent, bound with \nreverse function \n@(10){$a+b}, x is replaced by  \n_ARG_2\n8, expression , \nindependent, bound \nwith built-in \nfunction @{a=b}, z \nis replaced by \n_ARG_3\n9, expression , \nindependent,\n bound with reverse \nfunction \n@(100){a*$x^2+b*x+c}, \nx is replaced by _ARG_2, \nz is replaced by _ARG_4\n10, expression , \nindependent, bound \nwith  reverse \nfunction \n@(10){$a == b;}\n11, expression , \ndependent，x is \nreplaced by _ARG_2，a \nis replaced by ARG_1\n12, expression , \ndependent, z is \nreplaced by _ARG_4\n1, scope start ,\nindependent\n2, default ,\nindependent\n7, default , independent\n_AR\nG_1\n4, expression \n,dependent，\na is  replaced \nby _ARG_1\n13, return , \nindependent, bound with \nbuilt-in function \n@{a=b}, here the return \noperation is replaced by \nthe assignment operation\n14, scope end , \nindependent\nans3\n+\n$_ARG_2\n1\n==\n$tmp1\ny\n=\n_ARG_3\n0\n^\n$_ARG_4\n2\n*\n1\n$tmp2\n*\n_ARG_2\n$_ARG_4\n$tmp3\n$tmp4\n$tmp5\ny\n$tmp6\n50\n+\n$_ARG_1\n_ARG_2\n+\n$tmp7\n_ARG_4\n+\n$x\ny\n=\n$tmp1\n_ARG_1\n=\nans3\nans\n \nFigure 4. Contents of code blocks in 𝐵 \nIn sub step B-9-2, the code block is used to deduce the \nexecution process of reverse function. Specifically, the following \noperations are performed in turn: \nB-9-2-1, reorganizes the code blocks in the code block \nqueue 𝑩 into the code block queue 𝑩𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡 which depends on \nthe pending input parameters and the code block queue \n𝑩𝑖𝑛𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡  which is independent of the pending input \nparameters, and reorganizes the code blocks in both queues from \nsmall to large according to the sequence number of the code \nblocks; \nB-9-2-2, when the code block queue  𝑩𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡  is not \nempty, the dynamic programming method is used for reverse \nreasoning; The following actions need to be repeated: \nB-9-2-2-1, take the code block at the end of the code block \nqueue that depends on the pending input parameters as the root \nnode code block, backtrack and determine the dependency tree \nbetween the code blocks, and the number of nodes of the \ndependency tree does not exceed the maximum number \ndetermined by the user; \nThe child node and the parent node of the dependency tree \nmeet the following requirements: at least one undetermined \nvariable of the code segment in the code block of the child node \nis used by the code segment in the code block of its parent node; \nFor example, the dependency tree with code block [12] as the \nroot node and the number of nodes is 4 and its corresponding \ncode segment are shown in Figure 5:  \n$ans3\n_AR\nG_1\n[12]\n+\n$_ARG_1\n_ARG_2\n+\n$tmp7\n_ARG_4\n+\n$x\ny\n=\n$tmp1\n_ARG_1\n[11]\n[4]\n[3]\n \nFigure 5. Dependency tree and corresponding code \nsegment \nB-9-2-2-2, select the dependency tree according to the \npriority, re merge each node of the selected dependency tree into \na code segment, and perform code replacement and function \nbinding operations on the code segment; If there is no \n \nHAN Ji-Peng, LICHEN Zhi-Hang： \nA Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System \n17 \ndependency tree to select, the reverse inference fails; \nThe order of priority adopted, specifically, the less the \nnumber of necessary variables that depend on pending input \nparameters of the dependency tree, the higher the priority. On \nthis basis, the less the number of nodes of the dependency tree, \nthe higher the priority. In general, the less the necessary variables \nthat depend on pending input parameters in the dependency tree, \nthe more likely the code segment it is combined to bind to the \nfunction successfully. The necessary variables that depend on \npending input parameters of the dependency tree, that is, \nvariables that depend on pending input parameters and are used \nby the code blocks of the nodes of the dependency tree and the \nnon dependency tree nodes in 𝑩𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡 ; In contrast, if a \nvariable that depends on the pending input parameters is only \nused in the nodes of the dependency tree and is not used by other \ncode blocks in 𝑩𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡 that do not belong to the dependency \ntree, then this variable is an unnecessary variable of the \ndependency tree that depends on the pending input parameters; \nFor example, for the dependency tree 𝑻, the variable $_𝐴𝑅𝐺_1 \nis a necessary variable that depends on pending input parameters \nbecause it is used in code block [4], and the variables $𝑡𝑚𝑝7 and \n$𝑎𝑛𝑠3 are non essential variables because they are only used in \n𝑇1. \nMerge each node of the dependency tree into a code \nsegment, that is, from the end of the leaf node of the dependency \ntree, merge the code segments of the code block of the leaf node \ninto the code segments of its parent node and remove the merged \nsuccessful leaf nodes from the tree until the dependency tree has \nonly one root node, at which point the dependency tree merges \nsuccessfully. In this case, the root node code segment is the code \nsegment merged from each node of the dependency tree. \nMerging process should follow the following rules: \n·If the root node of the syntax tree of the code segment of \nthe code block of the child node is an assignment expression, the \nsyntax tree with the right value of the assignment expression as \nthe root node (that is, the right subtree) of the code segment of \nthe child node is used to replace all variables in the syntax tree \nof the code segment of the parent node that are the same as the \nleft value of the assignment expression of the root node of the \ncode segment syntax tree of the child node (that is, the left child \nnode);  \n·If the root node of the syntax tree of the code segment of \nthe child node is not an assignment expression, the syntax tree \nof the code segment of the child node is used to replace all \nvariables in the syntax tree of the code segment of the parent \nnode that are the same as the root node variables of the code \nsegment syntax tree of the child node; \n·When a child node is merged into a parent node, the \nsyntax tree of the code segment of the parent node must be \nreplaced at least once; If a replacement is not performed at all, \nthe code block merging fails, Combining code segments using \nthis dependency tree fails, Re execute B-9-2-2-2; \nFigure 6 shows the process of merging the dependency tree \n𝑇= {[12], [11], [4], [3]}  into the root node [12]  (middle: \ndependency tree; left: code segment of the dependency tree node \nbefore merging; right: code segment of the dependency tree node \nafter merging): \n_ARG_1\n=\n[4]\n$_ARG_1\n$_ARG_1\n[11]\n[12]\n$ans3\n$ans3\n+\n$x\ny\n$tmp1\n_ARG_1\n[3]\n+\n$x\ny\n+\n$x\ny\n+\n$_ARG_1\n_ARG_2\n$tmp7\n[4]\n+\n$x\ny\n$tmp7\n+\n$_ARG_1\n_ARG_2\n+\n$x\ny\n$tmp7\n+\n$_ARG_1\n_ARG_2\n+\n$tmp7\n_ARG_4\n[11]\n+\n$x\ny\n+\n$_ARG_1\n_ARG_2\n+\n$tmp7\n_ARG_4\n \nFigure 6. The process of merging the dependency tree 𝑇 \ninto the root node \n18 \n计 算 机 学 报 \n20??年 \nIf a dependency tree is merged successfully, mark the \noriginal dependency tree as 𝑻𝑜𝑟𝑔, and the merged dependency \ntree is 𝑻𝑓𝑖𝑛𝑎𝑙 , 𝑻𝑓𝑖𝑛𝑎𝑙  has only one node [𝑟𝑜𝑜𝑡]𝑓𝑖𝑛𝑎𝑙 . Perform \ncode replacement and function binding operations on the code \nsegment of [𝑟𝑜𝑜𝑡]𝑓𝑖𝑛𝑎𝑙. \nIf the code replacement and function binding operations on \nthe code segment of [𝑟𝑜𝑜𝑡]𝑓𝑖𝑛𝑎𝑙 succeed, push [𝑟𝑜𝑜𝑡]𝑓𝑖𝑛𝑎𝑙 from \nthe end into the reverse execution block queue 𝑩𝑏𝑎𝑐𝑘; Since all \npending variables in  𝑻𝑜𝑟𝑔 are identified after the code segments \nof [𝑟𝑜𝑜𝑡]𝑓𝑖𝑛𝑎𝑙  are executed, all nodes in 𝑻𝑜𝑟𝑔 , need to be \nremoved from 𝑩𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡  and the pending variables in other \ncode blocks in 𝑩𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡  need to be updated before the next \nround of reverse. That is, for each code block in 𝑩𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡, if \nthe pending variables in 𝑻𝑜𝑟𝑔 are used in the syntax tree of its \ncode segment, the pending variables are changed to deterministic \nvariables (that is, the pending flag bit of the variables is changed \nto false), and the flag bit of other variables in the syntax tree is \nmodified according to the following rules: \n·If all the child nodes of a variable in the syntax tree are \ndetermined, the variable is also determined; \n·If a variable is the left operand of the assignment \nexpression and the right operand is determined, the variable is \nalso determined; \nAfter completing the modification of the flag bit, re execute \nsub step B-9-2 to start the next round of backstepping; \nIf the code replacement operation and function binding \noperation fail, re execute B-9-2-2-2; \nB-9-2-3, use the queue 𝑩𝑖𝑛𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡 that is independent of \nthe code block of the pending input parameter and the queue \n𝑩𝑏𝑎𝑐𝑘 of the reverse execution code block that is obtained by \nreverse inference to construct the function body code 𝑒𝑏𝑎𝑐𝑘 of \nthe reverse function, specifically: \nB-9-2-3-1, pop up the header code block in 𝑩𝑖𝑛𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡 . \nThe type of the popped code block is \"scope start\". Add the code \nsegment of this code block to the end of the function body code \nsegment 𝑒𝑏𝑎𝑐𝑘  of the reverse function; The pop-up element \nrefers to deleting and returning a specific element from the set; \nB-9-2-3-2, because new variables are used to replace the \nmodified variables in the reverse process, which are stored in \n𝑨𝑟𝑒𝑝𝑙𝑎𝑐𝑒 and are not declared, you need to append code at the \nend of the 𝑒𝑏𝑎𝑐𝑘 that declares the elements in 𝑨𝑟𝑒𝑝𝑙𝑎𝑐𝑒 with the \ncode type \"variable declaration\"; \nB-9-2-3-3, if there are at least two elements in 𝑩𝑖𝑛𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡, \npop up the header code block in 𝑩𝑖𝑛𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡, append the code \nsegment of the popup code block to the end of 𝑒𝑏𝑎𝑐𝑘; When the \ntype of the code block that pops up is \"Expression\" and there is \nno common temporary variable for the code segments of all \nelements in 𝑒𝑏𝑎𝑐𝑘 and 𝑩𝑖𝑛𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡, a line of code of type \"End \nof expression\" is appended to the end of the function body code \nsegments of reverse function to indicate the end of the \nexpression; Repeat this step until there is only one element in \n𝑩𝑖𝑛𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡; \nB-9-2-3-4, pop up the header code block of the reverse \nexecution code block queue 𝑩𝑏𝑎𝑐𝑘, append the code table of the \npop-up code block to the end of 𝑒𝑏𝑎𝑐𝑘; When the type of the code \nblock that pops up is \"expression\" and the temporary variable \nused in 𝑒𝑏𝑎𝑐𝑘 does not exist in the reverse execution code block \nqueue 𝑩𝑏𝑎𝑐𝑘, code of type \"end of expression\" is appended to \nthe end of the function body code segment of reverse function to \nindicate the end of the expression; Repeat this step until 𝑩𝑏𝑎𝑐𝑘 \nis empty; \nB-9-2-3-5, pop up the only code block in 𝑩𝑖𝑛𝑑𝑒𝑝𝑒𝑑𝑒𝑛𝑡, the \ntype of code block is \"Scope end\", append the code segment of \nthis code block to the end of 𝑒𝑏𝑎𝑐𝑘; \nB-9-2-3-6, replacing the code address of 𝑒𝑏𝑎𝑐𝑘  with an \nunused address, the address used to store temporary variables \ngenerated at runtime, and the scope address so that the body code \nsegment 𝑒𝑏𝑎𝑐𝑘 of the reverse function can be inserted into the \ncode table after the reverse function declaration position, before \nthe next line of code, without any address conflict. After \ninsertion, update the information of scope table and function \ntable; \nThe function body, which is inversely inferred from the \ncode block queue {B}, is structured as shown in Figure 7 (left \nside: function body code segment; right side: basis for generating \nthe corresponding function body code segments on the left side, \nfunction binding operations on the left code segments, code \nblocks used to generate the left code segments, and so on): \n \nHAN Ji-Peng, LICHEN Zhi-Hang： \nA Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System \n19 \n$ans\nnew:z\n}\nbased on [6], \nbound with \nreverse function \n@(10){$a == b;}\nbased on [5], \nbound with  \nreverse function \n@(10){$a+b}\nbased on [14]\n{\nbased on [1]\nnew:_ARG_1\nnew:_ARG_2\nnew:_ARG_3\nnew:_ARG_4\nDeclarAtion of  \nvariables in \nAreplace\nnew:a\nbased on [2], this \nvariable is not used and \ncan be omitted\n;\nend of expression\nbased on [7], this \nvariable is not used \nand can be omitted\n;\nend of expression, can be \nomitted with the preceding \nsentence\n_ARG_3\nbased on [8],bound with \nbuilt-in function \n@{a=b}\n+\n+\n==\n$ans2\nbased on [9], bound \nwith reverse \nfunction \n@(100){a*$x^2+b*x+c}\nbased on \n[10],bound with \nreverse \nfunction \n@(10){$a == b;}\n;\nend of expression\n;\nend of expression\nans3\nbased on [4], bound \nwith built-in \nfunction @{a=b}\n=\n;\nend of expression\n$ans3\n;\nend of expression\nbased on \n[3][4][11][12], \nbound with \n@(10){$a+b},\n+\n$_ARG_2\n1\n==\n$tmp1\ny\n=\n_ARG_3\n0\n^\n$_ARG_4\n2\n*\n1\n$tmp2\n*\n_ARG_2\n$_ARG_4\n$tmp3\n$tmp4\n$tmp5\ny\n$tmp6\n50\nans\nans3\n+\n$x\ny\n+\n$_ARG_1\n_ARG_2\n+\n$tmp7\n_ARG_4\n \nFigure 7. Function body derived from 𝑩 \nSub step B-10, when code type flag bit is \"access member\", \nadd a key value pair with address as the key and access path as \nthe value to the current active record data table; \nSub step B-11, when code type flag bit is \"class operation\", \nskip the current code. \nThe pre execution process only creates variables according \nto the statements to ensure that the parameter environment is \ncorrect without actual function calls and operations. At the same \ntime, all codes in this process are only executed once at most. \nCompared with the simultaneous execution and reasoning, it \navoids the situation that a problem may be reasoned many times. \n2.11 EXECUTE \nThis process will execute the extended code table generated \nby pre execution and get the final result. Generally, the program \nis still executed from front to back. However, due to the \nintroduction of reverse function and forward function, the \nexecution order of local code execution is not necessarily the \nsame as the overall execution order of the program. \nSpecifically, the execution process includes the following \nsteps: \nStep A: skip the code whose code executable flag bit is \n\"false\"; \nStep B: for the code whose \"code executable flag bit\" is \n\"execute under certain conditions\", and this line of code is not \nexecuted by function call or condition statement jump or class \ninstance creation, directly skip the code within the entire scope; \nStep C: for the code whose \"code executable flag bit\" is \n\"execute under certain conditions\" and this line of code is \nexecuted by function call or condition statement jump or class \ninstance creation, or when the code executable flag bit is \"true\", \nany one or more of the following sub steps shall be executed \naccording to the code type: \nSub step C-1: when \"code type flag bit\" is \"jump\", if the \njump condition is true, set the currently executed code to the \ncode corresponding to the jump address and execute it; \notherwise, directly skip the currently executed code; \nSub step C-2: when code type flag bit is \"return operation\", \nreturn the result, end the execution of this function and return to \nthe function call location; Specifically, the returned operation \nvalue is assigned to the actual return parameter corresponding to \nthe formal return parameter in the formal parameter and actual \nparameter cross reference table. If the actual return parameter \ndoes not exist, it will not be assigned; where formal return \nparameter refers to the corresponding parameter of the root node \n20 \n计 算 机 学 报 \n20??年 \nin function declaration expression, and actual return parameter \nrefers to the corresponding parameter (variable) of the root node \nof the corresponding expression of code segment bound to this \nfunction, as shown in Figure 8: \nans\nfunction call  \n(executable)\nfunction declaration \nexpression of the function \nbound to the left code \n(non-executable)\n+\n1\n2\n+\na\nb\ntmp1\nactual \nreturn \nparameter\nformal \nreturn \nparameter\n \nFigure 8. Examples of actual return parameter and formal \nreturn parameter \nMark the current active record as the active record to be \ndestroyed, mark the corresponding code of return address of \ncurrent active record as the currently executed code, mark the \nreturn to active record of the current active record as the current \nactive record, execute the currently executed code, and destroy \nthe active record to be destroyed through the recursive method; \nThe specific process of destroying active records through the \nrecursive method is as follows: if the parent record of a record to \nbe destroyed is not the same active record as the current active \nrecord and is not a class instance, the parent active record of the \nrecord to be destroyed will also be marked as the active record \nto be destroyed, and all the active records to be destroyed will be \ndestroyed together. \nSub step C-3: when code type flag bit is \"function \noperation\", skip the currently executed code; \nSub step C-4: when \"code type flag bit\" is \"scope start\", \ncreate an empty active record in the current active record for the \nscope starting from the currently executed code, initialize the \nactive record information, and set the created active record as the \ncurrent active record; In particular, if the scope is a class scope \nand has a parent class, create the active record of the parent class \nand add its pointer to the array of \"pointers to parameter query \nactive records\" of the current active record before executing the \nnext line of code in the scope; \nSub step C-5, mark the current active record as the one to \nbe destroyed when code type flag bit is \"Scope end\" and the \ncurrent active record is not a class instance. If return to active \nrecord does not exist, destroy the current active record and the \nprogram \nexecution \nends. \nOtherwise, \nmark \nthe \ncode \ncorresponding to return address of current active record as the \ncode currently executing. Mark the return to active record of the \ncurrent active record as the current active record, use the \nrecursive method to destroy the active record, and continue \nexecuting the program; When \"code type flag bit\" is \"Scope end\" \nand the current active record is a class instance, the current active \nrecord is not destroyed, only the return to active record of the \ncurrent active record is marked as the current active record, and \nthe code corresponding to the return address of the current active \nrecord is marked as the code currently executed and the program \ncontinues to execute; \nSub step C-6, when code type flag bit is \"variable \ndeclaration\", add a key-value pair with the parameter identifier \nas the key and the default value of the parameter as value to the \ndata table of the current active record; \n \nSub step C-7: when the code type flag bit is \"expression\", \nfor the code segment of the longest expression where the \ncurrent code is located, first execute the forward functions in \nthe longest expression in forward sequence, and then execute \nthe reverse functions in reverse, as shown in Table 1: \nTable 1. An example of the execution sequence of \ncode segments containing forward functions and \nreverse function calls Sequence in code segmentWhether the bound function is reverse functionActual execution sequence1Y52N13N24Y45Y3\nPerform the following two operations in sequence: \nSub step C-7-1, execute backward from the starting position \nof the longest expression code segment. If function root node \nflag bit is false, skip the currently executed code; If function root \nnode flag bit is true and the bound function is forward function, \ncall the bound function; If the function root node flag bit is true \nand the bound function is reverse function, only the variables \nrequired to call the bound function are initialized and this \nfunction is not called; Until the end of the longest expression is \nreached; \nSub step C-7-2: execute from the end position to the start \nposition of the longest expression code segment (that is, code \nsegment of the longest expression). If function root node flag bit \nis false or the bound function is forward function, skip the \ncurrently executed code; If the function root node flag bit is true \nand the bound function is reverse function, the bound function \n \nHAN Ji-Peng, LICHEN Zhi-Hang： \nA Constraint and Object Oriented Fifth Generation Programming Language and its Compiler and Runtime System \n21 \nwill be called and the return address of the active record created \nfor the function call will be set to the address of the code on the \nprevious line of the function call code segment calling this \nreverse function in the longest expression code segment, If the \nstart position of function call code segment calling this reverse \nfunction coincides with the start position of the code segment of \nthe longest expression, set the return address to the address of \nthe next line of code after the end position of the longest \nexpression code segment. \nSub step C-8, when \"code type flag bit\" is \"end of \nexpression\", it indicates that the longest expression of the code \non the previous line of the currently executed code has ended, \nskipping the currently executed code; \nSub step C-9, when code type flag bit is \"derivation \nfunction\", skip this line of code; \nSub step C-10, when code type flag bit is \"access member\", \nadd a key value pair with address as the key and access path as \nthe value to the current active record data table; \nSub step C-11: when code type flag bit is \"class operation\", \nskip this line of code. \n3 SUMMARY and FORECAST \nCOOL pioneered the use of complex expressions as \nfunction statements, which enhanced the mathematical \nexpression ability of logic programming languages and the \napplicable reasoning range. It reduces the burden of user's \ninverse inference problem by providing the function of reverse \ninference in forward execution process. It is suitable for \nmainstream software development processes by supporting \nprocess-oriented and object-oriented. Nevertheless, COOL still \nhas much room for improvement: \n In terms of reasoning method, the cumulative weight \nmethod is essentially a controller that adjusts the code segment \nwith the matched function as input in each round, and the \ncumulative weight is used as a brief feedback on the effect of \ncode segment adjustment to adjust the matching process. In \norder to achieve quicker and more accurate control through this \ncontroller, more detailed state information needs to be fed back \nin each matching cycle, i.e. the dimension of weight needs to be \nexpanded, and a more reasonable weight accumulation method \nand filtering mechanism should be developed to improve \nreasoning speed. For users, increasing the dimension of the \nweight increases the difficulty of determining the weight and \ndestroys the simplicity, however, machine learning can be \nattempted to determine the multi-dimensional weight of a \nfunction. In addition, further research is needed to expand the \nscope of reversible inference. \n In terms of execution performance, during COOL pre-\nexecution, traversal methods are currently used to determine \nfunctions with the same structure as expressions, which incur \nconsiderable performance overhead. To improve efficiency, we \nneed to design an appropriate sorting and retrieval method for \nfunctions that use expressions as function declarations to avoid \ntraversing operations. \n In terms of debugging, COOL can output the contents of \ncode table silo in the reasoning process and record the \ntransformation process experienced by each piece of code in the \ncode table silo, through which users can \"guess\" what constraints \nor transformation rules are missing in programming. However, \nthis also means that COOL does not perfectly address the pain \npoint in the debugging process of constraint logic programming: \nthat is, to give detailed directions or suggestions for \nimprovement when reasoning fails. This may require a lot of \nresearch. \nREFERENCE \n[1] Wang Li-Guo, Sun Huai-Min. Logic programming language PROLOG \nand its system design principle. Journal of Computer Research and \nDevelopment, 1986 (03): 9-14(in Chinese) \n(王立国,孙怀民.逻辑编程语言PROLOG及其系统设计原理[J].计算\n机研究与发展,1986(03):9-14.) \n[2] McCarthy, John. History of LISP. ACM SIGPLAN Notices. 1978, 13:  \n217-223. \n[3] Warren, David H. D. et al. Prolog - the language and its implementation \ncompared with Lisp. Artificial Intelligence and Programming \nLanguages. 1977. \n[4] Gao Ji, He Qin-Ming, Fundamentals of artificial intelligence (Second \nEdition), Higher Education Press, 2008.10: 68-69 (in Chinese) \n(高济，何钦铭著,人工智能基础 （第二版）,高等教育出版\n社,2008.10: 68-69) \n[5] Ueda, Kazunori. Logic/Constraint Programming and Concurrency: The \nhard-won lessons of the Fifth Generation Computer project. Sci. \nComput. Program. 2018, 164: 3-17. \n[6] Fuchi, Kazuhiro. Launching the new era. CACM. 1993. \n[7] Jaffar, Joxan, Jean-Louis Lassez. Constraint logic programming. // \nProceedings of the ACM SIGPLAN-SIGACT Symposium on \nPrinciples of Programming Languages’ 87. Munich, West Germany, \n1987: 111–119. \n22 \n计 算 机 学 报 \n20??年 \n[8] Sakai, Kô and Akira Aiba. CAL: A theoretical background of constraint \nlogic programming and its applications. J. Symb. Comput. 1989, 8: \n589-603. \n[9] Dincbas M. et al. The Constraint Logic Programming Language CHIP// \nDincbas M. et al. Fifth Generation Computer Systems. Tokyo: 1988. \n[10] Sneyers, Jon et al. As time goes by: Constraint Handling Rules. Theory \nand Practice of Logic Programming. 2009, 10: 1 - 47. \n[11] Frühwirth, Thom W. et al. Probabilistic Constraint Handling Rules. \nElectron. Notes Theor. Comput. Sci. 2002, 76: 115-130. \n[12] Wadler, Philip. How Enterprises Use Functional Languages, and Why \nThey Don't. The Logic Programming Paradigm, 1999. \n[13] So whats haskell. http://learnyouahaskell.com/introduction#so-whats-\nhaskell, 2022. \n \nAPPENDIX 1 \n \nVisit https://github.com/coolang2022/COOLang to get the \nproject source code. \nVisit www.dreameng.tech for more information about us. \n \n \n \n \n \nAuthor1, HAN Ji-Peng, born in 1998, master. His main research \nfield is Programming Language. Email:coolang2022@qq.com \nAuthor2, LICHEN Zhi-Hang, born in 1999, bachelor, His main \nresearch \nfield \nis \nBiomedical \nEngineering. \nE-mail: \n13885398393@163.com  \n \n \nBackground \nThe fifth generation programming language is one of the \nkey research directions in the field of programming languages, \nwhich has been developing for decades. Designers originally \nintended computer reasoning to reduce the burden of logical \nthinking for users, however, the fifth-generation programming \nlanguage has always been unable to be widely used compared to \nthe fourth-generation programming language because of its \nobscure semantics, harsh representation of problems, limited \nreasoning power, and slow execution. In recent years, the \ndevelopment of constrained logic programming and probability \nlogic programming has made the reasoning ability of the fifth \ngeneration programming language continuously improved, and \nthe problems that it can handle have become more and more \nbroad. Based on the ideas of Constraint Logic Programming and \nProbability Logic Programming and the grammatical style of the \nmainstream programming languages, this paper designs a fifth \ngeneration programming language: COOL (Constraint and \nObject Oriented Language), which uses forward functions, \ninverse functions, functions returning expressions, functions \nreturning operation values as the basis of inference, and controls \nthe inference process through weights, and controls the use, \nmanagement and modification of rules through classes. It also \nimproves the execution speed through the pre-execution process. \nWe hope that COOL will be widely used and tested in actual \nproduction activities. \n",
  "categories": [
    "cs.PL"
  ],
  "published": "2022-06-02",
  "updated": "2022-06-02"
}