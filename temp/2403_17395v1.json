{
  "id": "http://arxiv.org/abs/2403.17395v1",
  "title": "An Open-source End-to-End Logic Optimization Framework for Large-scale Boolean Network with Reinforcement Learning",
  "authors": [
    "Zhen Li",
    "Kaixiang Zhu",
    "Xuegong Zhou",
    "Lingli Wang"
  ],
  "abstract": "We propose an open-source end-to-end logic optimization framework for\nlarge-scale boolean network with reinforcement learning.",
  "text": "1\nAn Open-source End-to-End Logic Optimization\nFramework for Large-scale Boolean Network with\nReinforcement Learning\nZhen Li, Kaixiang Zhu, Lingli Wang, Member, IEEE, and Xuegong Zhou\nAbstract—Large scale network,\nIndex Terms—Logic synthesis, Partition, Reinforcement learn-\ning\nI. INTRODUCTION\nL\nOGIC synthesis stands as a crucial process in Electronic\nDesign Automation (EDA) tools for Integrated Circuits\n(ICs) design. Logic synthesis refers to the process producing a\ncompact and fast gate-level implementation from a Register-\nTransfer Level (RTL) design description [1]. The traditional\nprocess of logic synthesis includes translation, logic opti-\nmization, and technology mapping. The overall goal of logic\nsynthesis is to find the best implementation of a boolean\nfunction, from the aspects of several performance metrics[2].\nAt present, the popular academic synthesis tools optimize\nthe circuit incrementally through a serious of predefined fixed\nsynthesis transformations, which may not generate the best\nquality of results (QoR) for all possible logic circuits. To\nachieve better synthesis performance, synthesis scripts need\nto be customized manually for each input design. With the\ndevelopment of machine learning (ML), its integration with\nEDA has emerged as a burgeoning frontier in technology.\nFor logic synthesis problems, For logic synthesis problems,\nreinforcement learning (RL) is leveraged to automatically and\nefficiently explore the the logic synthesis design space.\nHowever, as the complexity and scale of integrated circuits\ncontinue to escalate, traditional methods of logic synthesis\nencounter formidable challenges. First, modern System-on-\nChip (SoC) architectures are heterogeneous and composed by\ndifferent Intellectual Property (IP) blocks. The conventional\none-size-fits-all approach to logic optimization falls short in\naddressing the unique requirements and characteristics of\ndifferent regions within a large circuit. Second, the exponential\nlarge search space of the available logic transformation makes\nlogic synthesis optimization for a large circuit extremely time-\nconsuming. Therefore, it is desirable to partition a large\nheterogeneous circuit and individually optimize each portions.\nThis approach can enhance the QoR of the circuit and improve\nthe efficiency of logic synthesis optimization simultaneously.\nIn our work, we propose a novel methodology that leverages\ncircuit partitioning and enhances logic optimization with RL,\naiming for efficient and effective optimization of large-scale\nBoolean networks. The main contribution of this work are as\nfollows:\n• A partitioning method for large-scale Boolean network\ncircuit is proposed. Our experiments demonstrate that\nconducting logic synthesis optimization on the sub-\ncircuits obtained through this partitioning method yields\nbetter QoR.\n• A parallel RL-based logic synthesis flow exploration is\nconducted for the partitioned sub-circuits, greatly reduc-\ning runtime and significantly increasing scalability.\n• We demonstrate the capabilities of our proposed approach\non the EPFL [3], OPDB [4] VTR [5] and Koios [6]\nbenchmarks with the ASAP 7nm standard cell library [7].\nWe compare our work to logic optimization without cir-\ncuit partitioning. We show that xxx outperforms previous\ntechniques [2], [8], [9], [10]\nThe rest parts of this paper is organized as follows: Section\nII introduces the background information of logic synthesis\nand reinforcement learning. Section III describes the fine-\ngrained partitioning of large circuits. In section IV, the end-\nto-end logic optimization framework for large-scale boolean\nnetwork is proposed. In Section V, the performance results\nof the proposed framework are evaluated for several tasks and\ncompared with existing works. Finally, Section VI summarizes\nthis article.\nII. PRELIMINARIES AND RELATED WORK\nA. Boolean Logic Optimization\nTypically, a boolean network of the circuit is represented by\na directed acyclic graph (DAG), wherein nodes representing\nlogic gates and directed edges representing wires connecting\nthe gates. A well-known example of a Boolean network used\nin logic synthesis is the And-Inverter Graphs (AIGs), which\nis used by the state-of-art academic logci synthesisi tool ABC\n[11]. AIGs consist of nodes representing logic AND functions\nand weighted edges indicating the inversions of the Boolean\nsignals. Similarly, other forms of DAGs exist as well. MIGs\nwere introduced in [12] and XAGs were introduced in [13]\nas a replacement for AIGs. Boolean logic optimization is\ntypically performed by the algebraic minimization of a boolean\nnetwork. The most effective algorithms that optimize the\nboolean network are based DAG-aware boolean transforma-\ntions. DAG-aware boolean transformations have already been\nwidely used in academic tools [11], such as rewrite, refactor,\nand re-substitute. The existing ML-based exploration works\nare mainly implemented on AIGs. This is because AIGs-\nrelated logic optimization algorithms are the most comprehen-\narXiv:2403.17395v1  [cs.AI]  26 Mar 2024\n2\nsive, providing a broader exploration space for logic synthesis\noptimization.\nB. Circuit Partitioning\nCircuit partitioning is the process of dividing a large and\nintricate circuit into smaller, more manageable clusters, usu-\nally with minimized inter-cluster connections. Due to the\ncomplexity of large-scale circuits, traditional optimization\nalgorithms is time consuming for a single iteration over the\nentire system, rendering the optimization process inefficient.\nBy partitioning the circuit into smaller portions, each seg-\nment can be optimized independently, significantly reducing\nthe time required for each iteration. Partitioning plays an\nimportant roles in in modern EDA flows [14]. For example,\nduring the physical design stage, partitioning is instrumental\nin floorplan[15], placement [16], clock tree synthesis [17] and\ngrouping instances within distinct power domains [18].\nC. Reinforcement learning\nThe advances in ML and specially RL open up new op-\nportunities for logic optimizations. RL stands out due to its\nunique approach of learning to make decisions. It involves an\nagent that learns to achieve a goal in an uncertain, potentially\ncomplex environment. In RL, an agent learns from the conse-\nquences of its actions, rather than from being taught explicitly.\nIt makes decisions, receives feedback from the environment in\nthe form of rewards or penalties, and then adjusts its actions\naccordingly. By treating the optimization problem as an envi-\nronment and the decisions regarding logic transformations as\nactions, an RL agent can be trained to navigate the vast search\nspace of possible optimizations. RL has been implemented in\nlogic optimizer to navigate the vast search space of possible\noptimization sequences to identify strategies that yield the best\ntrade-offs between circuit performance metrics, such as power,\narea, and delay. Studies such as DRiLLS, ESE and BOiLS\nhave demonstrated the feasibility and effectiveness of using\nRL in logic synthesis, paving the way for more efficient and\nautomated EDA processes [2], [8], [9].\nD. Prior works\nPrevious works on logic synthesis for heterogeneous circuits\nmainly focus on representing different circuit portions with\nvarious data structures [10], [19], [20]. Specifically, the work\n[10], [19] proposed a logic synthesis framework, LSOracle,\ndesigned to select the most appropriate Boolean network\ndata structure for different portions of logic. This includes\nAnd-Inverter Graphs (AIGs) and Majority-Inverter Graphs\n(MIGs). Building upon this, the work [20] further extends the\nframework by incorporating XOR-And Graphs (XAGs) into\nthe Boolean network data structure used in the logic synthesis\nprocess. In [10], k-way hypergraph partitioning is employed\nduring logic synthesis phase to break the original DAG into\nseveral partitions. Each of these partitions is represented with\nvarious data structures. However, our experimental findings\nsuggest that the optimization impact of different Boolean\nnetwork data structures is somewhat limited, with AIGs\nAdaptive Partitioning\nPartition 1\nPartition 2\n......\nPartition N\nOriginal Logic Network\nRemove Sequential Logic\nMFFC_based KaHyPar/DagP\nPartition 1\nPartition 2\nPartition N\n......\n......\nPartition N+M\nFig. 1. PartitionFlow\ncontinuing to demonstrate superior efficiency as a Boolean\nnetwork representation method.\nThe application of RL in logic synthesis, as explored in\n[8], [9], adopts a holistic approach to circuit optimization.\nHowever, it has been observed that different segments of a\nlarge circuit could potentially derive greater benefits from\ntailored logic optimization scripts. Furthermore, the process\nof exploring and training to determine these optimization\nsequences for large circuits is notably time-consuming and\ndemands extensive computational resources. Acknowledging\nthese challenges, we propose an innovative approach that\ncombines circuit partitioning with reinforcement learning logic\noptimization. This method aims to minimize the interde-\npendencies between partitioned circuits while simultaneously\nenhancing runtime efficiency through parallel processing. The\nultimate goal is to achieve an improved QoR.\nIII. PARTITIONING STRATEGY\nIn the logic synthesis phase, the conventional wisdom sug-\ngests that circuit partitioning might compromise the quality of\nlogic synthesis optimization, as partitioning could potentially\ndegrade the effectiveness of mapping and logic optimiza-\ntion. However, we have discovered that partitioning based\non the maximum fanout-free cone (MFFC) exhibits inherent\nsuitability for logic synthesis optimization. Our experimental\nresults indicate that not only does it not lead to a decline in\noptimization quality, but when combined with the optimization\nof logic synthesis sequences, it actually enhances the QoR.\nDuring logic synthesis, partitioning a DAG based on MFFC\nenables increased independence among individual individual\nsubgraphs. This minimizes the impact of logic optimization\nfor one subgraph on others, thereby enhancing the efficiency\nof logic synthesis and ultimately improving the QoR. In our\nwork, we integrated adaptive partitioning [21] with MFFC-\nbased k-way Hyper-Graph Partitioning (KaHyPar) [22] and\nDirected Acyclic Graph Partitioning (DagP) [23] to divide\nthe logic network into subcircuits. To accelerate the overall\nlogic synthesis optimization process, we limit the size of each\nsubcircuits to no more than 10,000 nodes. Fig.1 presents a\nhigh-level view of the proposed partitioning approach.\n3\nA. Adaptive Partitioning\nThe adaptive partitioning approach in our study utilizes a\ncluster-based strategy, where the circuit is naturally segmented\ninto independent clusters by excluding combinational logic’s\nregisters and macro-blocks, such as DSPs and BRAMs. This\nexclusion naturally divides the original netlist into indepen-\ndent clusters, particularly beneficial for large-scale pipelined\ncircuits. These clusters, defined as sub-netlists with no com-\nmon nodes, are formed without cutting any edges in the\nnetlist, making the cluster-based strategy preferable. Clustering\ninformation is generated by traversing all nodes twice in\nreverse topological order, determining cluster membership.\nTo ensure a balanced workload across clusters, all nodes\nare traversed twice in reverse topological order to determine\ntheir cluster membership, and the potential workload of each\ncluster is calculated by simulating the mapping process. Given\nthe clusters with their workload, the netlist can be naturally\npartitioned into several workload-balanced sub-netlists without\ncutting any edges.\nWhile most large-scale circuits exhibit natural division\nby registers and macro-blocks, some circuits may possess\na single large, interconnected cluster impeding cluster-based\npartitioning. For such cases, the open-source partitioning tool\nnamed Metis is deployed. Metis partitions the netlist by cutting\nedges with minimized weight sums, carefully avoiding critical\npaths by assigning them higher weights to maintain delay con-\nstraints. Edges cut by Metis may require additional handling\nto maintain sub-netlist integrity. Additional PI and PO nodes\nare generated for each cut edge, ensuring connectivity across\npartitions. During sub-netlist merging, these additional nodes\nare omitted, and internal logic nodes are connected directly,\npreserving the structural integrity of the mapped netlist.\nB. MFFC-Based KaHyPar and DagP\nFollowing the implementation of the adaptive partitioning\nstrategy outlined in the preceding section, we observed that\ncertain sub-netlists continue to exhibit large sizes, thereby\nrendering the subsequent logic optimization processes both\ntime-consuming and challenging. In response to this issue, we\nhave opted to utilize a MFFC-based partitioning approach to\neffectively manage instances of oversized sub-netlists.\nThe MFFC decomposition technique was first proposed in\n1993 for combination circuits [24]. It offers a method to\nanalyze and partition circuits based on their logical structure\nand signal flow. In this context, a fanout-free cone (FFC) at\na given node v is a subset of the circuit that includes v and\nall its predecessors, ensuring that any signal path to v remains\nwithin this subset. The MFFC of a node v, then, represents\nthe largest FFC that includes v and adheres to the condition\nthat if any non-primary input (PI) node w has all its outputs\nwithin the MFFC, then w is also included in the MFFCv.\nThis technique is notable for its ability to uniquely identify\nclosely related gates within a circuit, as any gate within an\nMFFC contributes directly to the output of the MFFC’s root\nnode.\nKey properties of MFFC decomposition include:\n• If w ∈MFFCv, then MFFCw ⊂MFFCv.\nFig. 2.\nMFFC decomposition\n• Any two MFFCs are either completely separate or one\nencompasses the other.\nBased on these characteristics, a combinational circuit N\ncan be uniquely decomposed into disjoint MFFCs by: (i)\nselecting a primary output node v and computing its MFFC,\n(ii) redefining N to exclude MFFC and treating nodes with\nfanouts to MFFC as new POs, and (iii) repeating the process\nrecursively. Figure 2 illustrates an example of the MFFC\ndecomposition. MFFC decomposition ensure the logic in-\ndependency of the partitioned subgraphs, thereby not only\nfacilitating efficient optimization of logic synthesis but also\nminimizing the impact of optimizing one subgraph on others.\nThis approach significantly enhances the overall efficiency of\nthe logic synthesis process.\nAfter adaptive partitioning, we continue to divide the over-\nsized sub-nwelists into smaller portions. The MFFCs for\nevery node in the target Boolean network is traversed and\nconstructed. Then the original graph in compressed into a new\ngenerated graph, where each identified mffc is conceptualized\nas a node and dependencies among MFFCs are structured as\nedges.\nTo effectively partition this newly generated graph, we\nemploy either KaHyPar or DagP, aiming primarily to minimize\nthe disruption of edges. KaHyPar, an open-source library,\nleverages a multilevel approach for Hyper-Graph Partitioning\n(HGP), utilizing a progressively refining strategy to efficiently\nhandle large datasets and deliver high-quality partitions. It\nexcels in dividing hypergraphs into k distinct segments, with\nthe goal of reducing the connector size between partitions,\nshowcasing its innovative approach to partitioning. Conversely,\nDagP adopts a multilevel methodology tailored specifically\nfor HGP, with a particular focus on partitioning DAGs. It\ncapitalizes on the topological ordering inherent in DAGs to\nboost parallel computation capabilities. By minimizing inter-\npartition dependencies, DagP enhances task execution within\nparallel computing environments, thereby reducing the latency\ncaused by data transfers between partitions.\nEmploying these strategies significantly reduces dependen-\ncies between partitions, thereby improving the efficiency of\nparallel processing and facilitating more efficient management\nof large-scale computational tasks. Additionally, this approach\nmitigates the mutual interference of logic synthesis optimiza-\ntion across different partitions, thereby enhancing the QoR of\nthe circuit after merging.\n4\nOriginal Logic Network\nRL_based Logic Optimizer\nCircuit Merging\nOptimized Logic Network\nCircuit Partitioning\nPartition 1\nPartition 2\nPartition N\n......\nFig. 3. Optimize Framework\nIV. PROPOSED LOGIC OPTIMIZATION FRAMEWORK\nFigure 3 illustrates the logic optimization framework put\nforth in this study. The methodology commences with the\nOriginal Logic Network, establishing the baseline for the\noptimization. The foremost phase, Circuit Partitioning,\nsegments the network into multiple partitions, each containing\nfewer than 10,000 nodes. This granular division is crafted to\nsimplify the network’s complexity, thereby enabling detailed\noptimization and expediting the process through paralleliza-\ntion.\nSubsequent to the partitioning, the RL based Logic\nOptimizer ESE from [2] embarks on refining each segment.\nGrounded in RL, this optimizer meticulously adjusts the\nlogic optimizations sequences within each partition. Upon\nthe culmination of individual optimizations, the partitions\nconverge during the Circuit Merging phase. Here, the opti-\nmized partitions are amalgamated to reconstruct the enhanced\nlogic network. This crucial phase reintroduces the previously\nremoved sequential elements, safeguarding the integrity of\nthe network’s functionality and performance. The framework\nthus ensures that isolated optimizations confluence seamlessly,\nmaintaining the overarching efficacy and coherence of the\noriginal network.\nV. EXPERIMENTAL RESULTS\nA. Experimental Setup\nOur experimental flow is illustrated in Figure 4. We employ\nplugins to optimize the pure combinational logic within the\ncircuit from the input Verilog files within the circuit using\nABC, LSOracle, and our proposed method, respectively. Sub-\nsequently, the optimized Verilog is evaluated using Synopsys\nDesignCompiler, version s-2021.06-sp5. To minimize circuit\noptimization during mapping, we opted for the compile com-\nmand instead of compile ultra. Additionally, we set the clock\nto 0 to maximize the maximize the maximum frequency.\nOur experiment evaluated re sults from over 150 benchmarks\nVerilogs\nYosys\nDesign Compiler\nABC\nLSOracle\nOurs\nset_max_area 0\ncreate_clocl -period 0\ncompile -map_effort high\nPlugins\nFig. 4. ExperimentFlow\nsourced from EPFL [3], OPDB [4], VTR [5], and Koios [6],\nexcluding a few diminutive examples. These small cases were\nomitted due to the negligible optimization impact attributed to\ntheir size. Furthermore, one large benchmark named hyp was\nremoved, as it cannot be synthesized using DC within a week.\nThe benchmarks were tested using the ASAP 7nm technology\nlibrary [7].\nWe conducted a comparison between our work and that of\nDRiLLS [8], BOiLS [9] and LSOracle[10]. Our approach uses\n200 cores to perform parallel optimization on the partitioned\ncircuits for a duration of 2 hours. To ensure a fair comparison,\nfor the single-core optimization works of BOiLS and DRiLLS,\nwe set the optimization duration using the following formula:\n⌈number of parts\n200\n× 2h⌉. Regarding the time taken to partition the\ncircuits, for the largest circuit in our benchmark (comprising\n106 nodes), it required ten hours. We then synthesize the\noptimized Verilog files using DC and generated reports on\narea, delay, and ADP (area delay product).\nB. End-to-end Results\nOur experimental results are presented in Table I. The\nleftmost column indicates the size of the circuits, ranging\nfrom the largest 10, 20, 30, 40, to all benchmarks. The second\ncolumn delineates the metrics for comparison, including Area,\nDelay, and ADP (Area Delay Product), while the third to sixth\ncolumns display the optimization outcomes from LSOracle,\nBOiLS, DRiLLS, and our work, respectively. The baseline for\ncomparison is the resyn2 command within ABC. As evident\nfrom the table, DRiLLS demonstrates the best optimization\nresults for the largest 10 benchmarks, primarily focusing\non delay improvement. However, for the subsequent groups\nranging from the largest 20 to all benchmarks, our optimization\nmethod achieves superior enhancements in both delay and\narea, yielding an approximately 5% improvement in ADP.\nThe comparative analysis also reveals that LSOracle exhibits\nthe least optimization benefits, with performance even falling\nshort of ABC’s resyn2, showing a negative optimization\neffect. We speculate conjecture that the reason behind this\nis that AIG remains the most efficient DAG representation\nto date. Consequently, partitioning circuits into different parts\nusing various data structures for representation does not yield\nperformance improvements.\n5\nTABLE I\nCOMPARISON WITH LSORACLE, BOILS, DRILLS, AND OUR APPROACH.\nBenchmark Size\nMetric\nLSOracle[10]\nBOiLS[9]\nDRiLLS[8]\nOurs\nLargest 10\nArea\n1.57%\n-10.69%\n-12.00%\n-11.139%\nDelay\n12.10%\n0.69%\n-2.52%\n-0.23%\nADP\n14.35%\n-10.45%\n-14.11%\n-11.52%\nLargest 20\nArea\n1.29%\n-5.80%\n-6.58%\n-6.55%\nDelay\n13.61%\n-0.69%\n-1.74%\n-1.78%\nADP\n15.03%\n-6.72%\n-8.11%\n-8.37%\nLargest 30\nArea\n5.03%\n-5.78%\n-6.19%\n-4.87%\nDelay\n11.12%\n-0.08%\n0.09%\n-0.82%\nADP\n17.55%\n-5.95%\n-5.88%\n-5.73%\nLargest 40\nArea\n4.10%\n-5.04%\n-5.47%\n-5.50%\nDelay\n8.90%\n-0.55%\n-0.29%\n-1.49%\nADP\n14.08%\n-5.41%\n-5.46%\n-6.75%\nAll\nArea\n2.08%\n-3.28%\n-3.61%\n-3.85%\nDelay\n3.81%\n-0.64%\n-0.30%\n-1.70%\nADP\n6.16%\n-3.68%\n-3.73%\n-5.17%\nVI. CONCLUSION\nACKNOWLEDGMENT\nThe authors would like to thank...\nREFERENCES\n[1] G. D. Micheli, Synthesis and Optimization of Digital Circuits, 1st ed.\nMcGraw-Hill Higher Education, 1994.\n[2] Y. Qian, X. Zhou, H. Zhou, and L. Wang, “An efficient reinforcement\nlearning based framework for exploring logic synthesis,” ACM Trans.\nDes. Autom. Electron. Syst., vol. 29, no. 2, jan 2024. [Online].\nAvailable: https://doi.org/10.1145/3632174\n[3] L. G. Amar`u, P.-E. Gaillardon, and G. D. Micheli, “The epfl\ncombinational benchmark suite,” 2015. [Online]. Available: https:\n//api.semanticscholar.org/CorpusID:13971503\n[4] G. Tziantzioulis, T.-J. Chang, J. Balkind, J. Tu, F. Gao, and D. Wentzlaff,\n“Opdb: A scalable and modular design benchmark,” IEEE Transactions\non Computer-Aided Design of Integrated Circuits and Systems, vol. 41,\nno. 6, pp. 1878–1887, 2022.\n[5] K. E. Murray, O. Petelin, S. Zhong, J. M. Wang, M. Eldafrawy,\nJ.-P. Legault, E. Sha, A. G. Graham, J. Wu, M. J. P. Walker,\nH. Zeng, P. Patros, J. Luu, K. B. Kent, and V. Betz, “Vtr 8:\nHigh-performance cad and customizable fpga architecture modelling,”\nACM Trans. Reconfigurable Technol. Syst., vol. 13, no. 2, jun 2020.\n[Online]. Available: https://doi.org/10.1145/3388617\n[6] A. Arora, A. Boutros, D. Rauch, A. Rajen, A. Borda, S. A. Damghani,\nS. Mehta, S. Kate, P. Patel, K. B. Kent, V. Betz, and L. K. John, “Koios:\nA deep learning benchmark suite for fpga architecture and cad research,”\nin 2021 31st International Conference on Field-Programmable Logic\nand Applications (FPL), 2021, pp. 355–362.\n[7] L. T. Clark, V. Vashishtha, L. Shifren, A. Gujja, S. Sinha, B. Cline,\nC. Ramamurthy, and G. Yeric, “Asap7: A 7-nm finfet predictive process\ndesign kit,” Microelectronics Journal, vol. 53, pp. 105–115, 2016.\n[Online]. Available: https://www.sciencedirect.com/science/article/pii/\nS002626921630026X\n[8] A. Hosny, S. Hashemi, M. Shalan, and S. Reda, “Drills: Deep reinforce-\nment learning for logic synthesis,” in 2020 25th Asia and South Pacific\nDesign Automation Conference (ASP-DAC), 2020, pp. 581–586.\n[9] A. Grosnit, C. Malherbe, R. Tutunov, X. Wan, J. Wang, and H. B.\nAmmar, “Boils: Bayesian optimisation for logic synthesis,” in 2022\nDesign, Automation & Test in Europe Conference & Exhibition (DATE),\n2022, pp. 1193–1196.\n[10] W. L. Neto, M. Austin, S. Temple, L. Amaru, X. Tang, and P.-E.\nGaillardon, “Lsoracle: a logic synthesis framework driven by artificial\nintelligence: Invited paper,” in 2019 IEEE/ACM International Confer-\nence on Computer-Aided Design (ICCAD), 2019, pp. 1–6.\n[11] R. Brayton and A. Mishchenko, “Abc: An academic industrial-strength\nverification tool,” in Computer Aided Verification, T. Touili, B. Cook,\nand P. Jackson, Eds.\nBerlin, Heidelberg: Springer Berlin Heidelberg,\n2010, pp. 24–40.\n[12] L. Amar´u, P.-E. Gaillardon, and G. De Micheli, “Majority-inverter\ngraph: A new paradigm for logic optimization,” IEEE Transactions on\nComputer-Aided Design of Integrated Circuits and Systems, vol. 35,\nno. 5, pp. 806–819, 2016.\n[13] E. Testa, M. Soeken, L. Amar`u, and G. D. Micheli, “Reducing the mul-\ntiplicative complexity in logic networks for cryptography and security\napplications,” in 2019 56th ACM/IEEE Design Automation Conference\n(DAC), 2019, pp. 1–6.\n[14] R. Andre, S. Schlag, and C. Schulz, “Memetic multilevel hypergraph\npartitioning,”\nin\nProceedings\nof\nthe\nGenetic\nand\nEvolutionary\nComputation Conference, ser. GECCO ’18.\nNew York, NY, USA:\nAssociation for Computing Machinery, 2018, p. 347–354. [Online].\nAvailable: https://doi.org/10.1145/3205455.3205475\n[15] J. Roy, S. Adya, D. Papa, and I. Markov, “Min-cut floorplacement,”\nIEEE Transactions on Computer-Aided Design of Integrated Circuits\nand Systems, vol. 25, no. 7, pp. 1313–1326, 2006.\n[16] M.\nFogac¸a,\nA.\nB.\nKahng,\nR.\nReis,\nand\nL.\nWang,\n“Finding\nplacement-relevant clusters with fast modularity-based clustering,” in\nProceedings of the 24th Asia and South Pacific Design Automation\nConference, ser. ASPDAC ’19.\nNew York, NY, USA: Association\nfor Computing Machinery, 2019, p. 569–576. [Online]. Available:\nhttps://doi.org/10.1145/3287624.3287676\n[17] R. S. Shelar, “An efficent clustering algorithm for low power clock\ntree synthesis,” in Proceedings of the 2007 International Symposium\non Physical Design, ser. ISPD ’07.\nNew York, NY, USA: Association\nfor Computing Machinery, 2007, p. 181–188. [Online]. Available:\nhttps://doi.org/10.1145/1231996.1232037\n[18] K. Blutman, H. Fatemi, A. B. Kahng, A. Kapoor, J. Li, and J. P.\nde Gyvez, “Floorplan and placement methodology for improved energy\nreduction in stacked power-domain design,” in 2017 22nd Asia and South\nPacific Design Automation Conference (ASP-DAC), 2017, pp. 444–449.\n[19] M. Austin, S. Temple, W. L. Neto, L. Amar`u, X. Tang, and P.-E.\nGaillardon, “A scalable mixed synthesis framework for heterogeneous\nnetworks,” in 2020 Design, Automation & Test in Europe Conference &\nExhibition (DATE), 2020, pp. 670–673.\n[20] S. Temple, W. L. Neto, A. Snelgrove, X. Tang, and P.-E. Gaillardon,\n“Invited: Getting the most out of your circuits with heterogeneous logic\nsynthesis,” in 2021 58th ACM/IEEE Design Automation Conference\n(DAC), 2021, pp. 1331–1334.\n[21] X. Wang, M. Yang, Z. Li, and L. Wang, “Parallelized technology\nmapping to general plbs by adaptive circuit partitioning,” in 2021\nInternational Conference on Field-Programmable Technology (ICFPT),\n2021, pp. 1–5.\n[22] Y. Akhremtsev, T. Heuer, P. Sanders, and S. Schlag, “Engineering\na direct k-way hypergraph partitioning algorithm,” in Workshop on\nAlgorithm Engineering and Experimentation, 2017. [Online]. Available:\nhttps://api.semanticscholar.org/CorpusID:27843658\n[23] J. Herrmann, M. Y. ¨Ozkaya, B. Uc¸ar, K. Kaya, and ¨U. V.C¸ ataly¨urek,\n“Multilevel algorithms for acyclic partitioning of directed acyclic\ngraphs,” SIAM Journal on Scientific Computing (SISC), vol. 41, no. 4,\npp. A2117–A2145, 2019. [Online]. Available: https://doi.org/10.1137/\n18M1176865\n[24] J. Cong and Y. Ding, “On area/depth trade-off in lut-based fpga tech-\nnology mapping,” IEEE Transactions on Very Large Scale Integration\n(VLSI) Systems, vol. 2, no. 2, pp. 137–148, 1994.\n",
  "categories": [
    "cs.AI"
  ],
  "published": "2024-03-26",
  "updated": "2024-03-26"
}